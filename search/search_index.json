{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"my-docs","text":"<ul> <li>SQL</li> <li>PL/SQL</li> </ul>"},{"location":"PLSQL/accessible_by/","title":"ACCESSIBLE BY Clause","text":"<p>The ACCESSIBLE BY clause restricts access to a unit or subprogram by other units. This clause can be used by the following statements:</p> <ul> <li><code>ALTER TYPE</code></li> <li><code>CREATE FUNCTION</code></li> <li><code>CREATE PROCEDURE</code></li> <li><code>CREATE PACKAGE</code></li> <li><code>CREATE TYPE</code></li> <li><code>CREATE TYPE BODY</code></li> </ul> <p>Syntax <pre><code>ACCESSIBLE BY (\n    [FUNCTION | PROCEDURE | PACKAGE | TRIGGER | TYPE]\n    [schema.]unit_name\n)\n</code></pre></p> <ul> <li>unit_name: specifies a stored PL/SQL unit that can invoke the entity.<ul> <li>it's not required for the unit_name to exist.</li> </ul> </li> <li>type of object (Function, Procedure, Package, Trigger, Type) is optional but is recommended to avoid ambiguity (it's possible to have a Trigger with the same name as a Function).</li> </ul> <p>Examples</p> <pre><code>CREATE OR REPLACE PROCEDURE private_procedure\n    ACCESSIBLE BY (PROCEDURE trusted_procedure)\nIS\nBEGIN \n    dbms_output.put_line('executed private_procedure');\nEND;\n/\n-- Procedure PRIVATE_PROCEDURE compiled\n\nCREATE OR REPLACE PROCEDURE trusted_procedure\nIS \nBEGIN \n    dbms_output.put_line('executed trusted_procedure');\n    private_procedure;  \n    dbms_output.put_line('called private_procedure');\nEND;\n/\n-- Procedure TRUSTED_PROCEDURE compiled\n\nEXEC trusted_procedure;\n-- executed trusted_procedure\n-- executed private_procedure\n-- called private_procedure\n\nEXEC private_procedure;\n-- PLS-00904: insufficient privilege to access object PRIVATE_PROCEDURE\n\nBEGIN\n    private_procedure;\nEND;\n-- PLS-00904: insufficient privilege to access object PRIVATE_PROCEDURE\n</code></pre> Sources <ul> <li>Oracle Documentation - ACCESSIBLE BY Clause</li> </ul>"},{"location":"PLSQL/associative_arrays/","title":"Associative Arrays","text":"<p>An Associative Array is a set of key-value pairs:</p> <ul> <li>Each key is unique and it is used to find the associate value.</li> <li>The index's datatype can be a String (VARCHAR2, CHAR, etc) or PLS_INTEGER.</li> <li>Indexes are stored in sorted order, not creation order.</li> <li>For String Indexes, their sort is determined by the parameters NLS_SORT and NLS_COMP.</li> <li>You can use any value that can be converted to char through the TO_CHAR function as index datatype.</li> <li>It is not recommended to use <code>TO_CHAR(SYSDATE)</code> as index datatype because if the value of NLS_DATE_FORMAT changes, then the Associative Array's indexes change too.</li> </ul> <p>An Associative Array...</p> <ul> <li>is empty (but not null) until you populate it</li> <li>can hold unspecified number of elements</li> <li>does not need disk space or network operations</li> <li>cannot be manipulated with DML statements</li> <li>can be defined only in PL/SQL Blocks</li> </ul> <p>Syntax <pre><code>TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY key_type;\n</code></pre></p> <ul> <li>type_name: name of the collection.</li> <li>element_type: datatype of the elements stored.</li> <li><code>NOT NULL</code>: every element in the array must have a value.</li> <li>key_type: datatype of the index.</li> </ul> <p>You must create a variable of the Associative Array datatype to insert or search for values:</p> <pre><code>TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY key_type;\nvariable_name type_name;\n</code></pre> <p>Examples</p> <pre><code>DECLARE\n   TYPE emp_table_type IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;\n   emp_table emp_table_type;\nBEGIN\n   emp_table(1) := 'John Doe';\n   emp_table(2) := 'Jane Smith';\n   emp_table(3) := 'Robert Brown';\n\n   DBMS_OUTPUT.PUT_LINE(emp_table(1));\nEND;\n/\n    -- OUTPUT: John Doe\n</code></pre> Sources <ul> <li>Oracle Documentation - Associative Arrays</li> </ul>"},{"location":"PLSQL/conditional_compilation/","title":"Conditional Compilation","text":"<p>Conditional Compilation in PL/SQL is generally used for code that needs to be ran on multiple Oracle DB versions. Main constructs are <code>$IF</code>, <code>$THEN</code>, <code>$ELSE</code>, <code>$ELSIF</code>, <code>$END</code>, <code>$DEBUG</code> (to check if debug mode is on) <code>$ERROR</code> (for displaying errors) and <code>$WARNING</code> (for displaying warnings).</p> <p>Examples</p> <pre><code>declare\n    v_version varchar2(10);\nbegin\n    $if dbms_db_version.version = 1 2 $then\n        v_version := 'oracle 12c';\n    $elsif dbms_db_version.version = 11 $then\n        v_version := 'oracle 11g';\n    $else\n        v_version := 'other';\n    $end;\n\n    dbms_output.put_line('database version: ' || v_version);\nend;\n</code></pre> <ul> <li>Oracle Live SQL - Examples of Conditional Compilation</li> </ul> Sources <ul> <li>Oracle-Base - Conditional Compilation in Oracle 10g</li> <li>Oracle Book - PL/SQL Conditional Compilation</li> </ul>"},{"location":"PLSQL/deprecate_pragma/","title":"DEPRECATE Pragma","text":"<p>This pragma marks as Deprecated PL/SQL objects. The compiler shows warning if the program uses deprecated objects. The DEPRECATE pragma can only appear in the Declaration Section and can be applied to:</p> <ul> <li>Subprograms (Procedure/Function)</li> <li>Packages</li> <li>Variables</li> <li>Constants</li> <li>Types</li> <li>Subtypes</li> <li>Exceptions</li> <li>Cursors</li> </ul> <p>Syntax <pre><code>PRAGMA DEPRECATE (pls_identifier [,character_literal]);\n</code></pre></p> <ul> <li>pls_identifer: name of the object that is being deprecated.</li> <li>character_literal: optional warning message.</li> </ul> <p>Examples</p> <pre><code>-- deprecation of Package\ncreate package pack1 as  \n    pragma deprecate (pack1);\n    procedure my_procedure;\nend;\n-- warnings will be issued for any reference to this package and its procedures.\n\n-- deprecation of Variable\ncreate package pack2 as  \n    my_variable number := 1;\n    pragma deprecate(my_variable, 'unused variable');\nend;\n</code></pre> Sources <ul> <li>Oracle Documentation - DEPRECATE Pragma</li> </ul>"},{"location":"PLSQL/functions/","title":"Functions","text":"<p>The CREATE FUNCTION statement creates or replaces a standalone Function or a call specification.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION [schema.]function_name\n    [(parameter [IN | OUT | IN OUT] parameter_datatype [, parameter])]\n    RETURN return_datatype\nIS | AS\n    [declaration_section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND [function_name];\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: recreates the function if it exists</li> <li>schema: name of the schema containing the function (default: current schema)</li> <li>function_name: name of the function to be created</li> <li>parameter: list of parameters passed to the function</li> <li><code>IN/OUT/IN OUT</code>:<ul> <li><code>IN</code>: the parameter's value can be read by the function but cannot be changed.</li> <li><code>OUT</code>: the parameter's value cannot be read by the function but can be changed.</li> <li><code>IN OUT</code>: the parameter's can be read and changed by the function.</li> </ul> </li> <li><code>RETURN datatype</code>: the return datatype of the function. Cannot specify a length, precision or scale.</li> </ul> <p>Notes</p> <ul> <li>Every Function must return one or more values.</li> <li>Parameters are always optional.</li> </ul> <p>Examples</p> <pre><code>CREATE OR REPLACE FUNCTION is_odd (in_number IN NUMBER)\nRETURN boolean\nIS\nBEGIN\n    IF (in_number / 2) != 0 THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n/\n-- Function IS_ODD compiled\n\nBEGIN\n    dbms_output.put_line(\n        CASE WHEN IS_ODD(2)\n            THEN '2 is an odd number'\n            ELSE '2 is not an odd number'\n        END\n    );\nEND;\n-- 2 is an odd number\n\nSELECT\n    CASE WHEN IS_ODD(2)\n            THEN '2 is an odd number'\n            ELSE '2 is not an odd number'\n        END\nFROM dual;\n-- ORA-00920: invalid relational operator\n</code></pre> <p>Privilege Restrictions</p> <ul> <li>In your Schema: <code>GRANT CREATE PROCEDURE TO user_name;</code></li> <li>In another's user Schema: <code>GRANT CREATE ANY PROCEDURE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE FUNCTION Statement</li> </ul>"},{"location":"PLSQL/hints/","title":"NOCOPY","text":"<p>It's a Hint used to improve performance of OUT and IN OUT parameters in PL/SQL. There are two methods to pass OUT/IN OUT parameters:</p> <ul> <li>By Value: happens by default: a copy of the variable is created and any modification is done on the copy. Once the Procedure is completed, the data is passed on the original variable.</li> <li>By Reference: happens with the NOCOPY hint: instead of creating a copy of the variable, modifications are done directly to the original variable. In normal Procedures you wouldn't notice the difference between the two methods, but the difference can become considerable when working with large or complex datatypes.</li> </ul> <p>Syntax <pre><code>CREATE [OR REPLACE] PROCEDURE [schema.]procedure_name (parameter_name {OUT | IN OUT} NOCOPY datatype) IS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p> <p>Examples</p> <pre><code>CREATE OR REPLACE PROCEDURE in_out_nocopy (v_number IN OUT NOCOPY NUMBER) IS\nBEGIN\n    v_number := v_number * 2;\n    dmbs_output.put_line(v_number);\nEND;\n</code></pre>"},{"location":"PLSQL/hints/#parallel-enable","title":"PARALLEL ENABLE","text":"<p>This hint enables the Function on which it is declared for parallel execution.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION function_name (parameters) RETURN datatype\n    PARALLEL_ENABLE\nIS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p>"},{"location":"PLSQL/hints/#deterministic","title":"DETERMINISTIC","text":"<p>The DETERMINISTIC Clause marks a function to return predictable results. It is useful for optimizazion purposes: if the function is called multiple times with the same parameters, Oracle can avoid redundant calculations by reusing the previously computed result.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION function_name (parameters) RETURN datatype\n    DETERMINISTIC\nIS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p> <p>Examples</p> <pre><code>CREATE OR REPLACE FUNCTION square(n NUMBER)\n    RETURN NUMBER\n    DETERMINISTIC\nIS\nBEGIN\n    RETURN n * n;\nEND;\n</code></pre> Sources <ul> <li>Oracle Documentation - PARALLEL ENABLE Clause</li> <li>Oracle Documentation - DETERMINISTIC Clause</li> </ul>"},{"location":"PLSQL/subprograms/","title":"Subprograms","text":"<p>A PL/SQL subprogram is a PL/SQL block that can be invoked repeatedly. A PL/SQL subprogram can be created:</p> <ul> <li>inside a Package (which is called a package subprogram)</li> <li>at schema level (which is called a standalone subprogram)</li> <li>inside another PL/SQL subprogram (which is called a nested subprogram)</li> </ul> <p>Syntax to invoke a subprogram <pre><code>subprogram_name [([parameter_1 [, parameter_n]...])]\n</code></pre></p> <p>Notes</p> <ul> <li>Subprograms are divided in three sections:<ul> <li>optional declarative part: here you can declare and define Variables, Cursors, etc.</li> <li>executable part: contains one or more statements that will be executed.</li> <li>optional exception-handling part: code that handles exceptions.</li> </ul> </li> <li>Stored subprogram = package subprogram, standalone subprogram or named subprograms.</li> <li>Stored subprograms are stored in the database server.</li> </ul> Sources <ul> <li>Oracle Documentation - PL/SQL Subprograms</li> </ul>"},{"location":"PLSQL/triggers/","title":"Triggers","text":"<p>A Trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs. The main difference with Constraints is that Triggers apply to new data only.</p> <p>Types of Triggers</p> <ul> <li>DML Trigger: a Trigger created on a Table or View, which is composed by DML Statements.</li> <li>INSTEAD OF Trigger: a Trigger that replaces the original triggering DML Statement.</li> <li>System Trigger: a Trigger created on a Schema or Database, which is composed by DDL or Database Operation Statements.</li> <li>Conditional Trigger: a DML or System Trigger that has a WHEN clause.</li> </ul> Sources <ul> <li>Oracle Documentation - PL/SQL Triggers</li> </ul>"},{"location":"PLSQL/triggers/#dml-trigger","title":"DML Trigger","text":"<p>A DML Trigger fires at exactly one of these timing points:</p> <ul> <li>before the triggering statement runs (BEFORE Statement Trigger)</li> <li>after the triggering statement runs (AFTER Statement Trigger)</li> <li>before each row that the triggering statement affects (BEFORE each row Trigger)</li> <li>after each row that the triggering statemet affects (AFTER each row Trigger)</li> </ul> <p>DML Trigger Syntax <pre><code>CREATE [OR REPLACE] TRIGGER [schema.]trigger_name\n  {BEFORE | AFTER} {INSERT | UPDATE [OF column [, column]] | DELETE [OR INSERT | UPDATE [OF column [, column]] | DELETE]}\n  ON [schema.]object_name \n  [FOR EACH ROW]\n  [FOLLOWS | PRECEDES [schema.]trigger_name]\n  [ENABLE | DISABLE]\n  [WHEN (condition)]\n[DECLARE section]\nBEGIN\n  ...\n[EXCEPTION section]\nEND;\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: re-creates the Trigger if it exists.</li> <li>schema: schema on which the Trigger will be created (default is current schema).</li> <li>trigger_name: name of the Trigger.</li> <li><code>BEFORE</code>: Trigger is fired before running the triggering event.</li> <li><code>AFTER</code>: Trigger is fired after running the triggering event.</li> <li><code>INSERT</code>: Trigger is fired whenever an INSERT Statement adds a row to object_name.</li> <li><code>DELETE</code>: Trigger is fired whenever a DELETE Statement removes a row from object_name.</li> <li><code>UPDATE [OF column [, column]]</code>: Trigger is fired whenever an UPDATE Statement changes a value in a specified column.</li> <li>if no column is specified, then the Trigger is fired whenever any column changes.</li> <li>if you specify a column, then that column's value cannot be changed in the Trigger Body.</li> <li>object_name: Table or View on which the Trigger is defined.</li> <li><code>FOR EACH ROW</code>: creates the Trigger as a Row Trigger. The Trigger is fired for each row that is affected.</li> <li><code>FOLLOWS | PRECEDES schema.trigger_name</code>: indicates if the Trigger should be fired after (FOLLOWS) or before (PRECEDES) another Trigger.</li> <li><code>ENABLE | DISABLE</code>: creates the Trigger in an Enabled/Disabled state. Default is ENABLE.</li> <li><code>WHEN (condition)</code>: specifies a SQL condition that the Database evaluates for each row that the triggering statement affects. Trigger Body will run only when condition is true.</li> </ul> <p>Notes</p> <ul> <li>If a Trigger produces compilation errors, then it is still created, but it fails on execution.<ul> <li>Query to check if compiled Trigger has errors: <code>SELECT * FROM all_errors WHERE type = 'TRIGGER';</code> </li> </ul> </li> <li>If a Trigger has a <code>WHEN (condition)</code> clause, then you must also specify <code>FOR EACH ROW</code>.</li> <li><code>WHEN (condition)</code> cannot include a Subquery or PL/SQL Expression (i.e. invokation of Functions, Procedures).</li> <li><code>WHEN (condition)</code> does not need semicolons (:) for OLD and NEW variables.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - DML Trigger - Example 1</li> <li>Oracle Live SQL - DML Trigger - Example 2</li> </ul> Sources <ul> <li>Oracle Documentation - DML Triggers</li> </ul>"},{"location":"PLSQL/triggers/#conditional-predicates","title":"Conditional Predicates","text":"<p>The Trigger can determine which event is happening thanks to Conditional Predicates. They can be used in Boolean Expressions (IF, CASE, etc.):</p> <ul> <li><code>INSERTING</code>: an INSERT Statement</li> <li><code>UPDATING</code>: an UPDATE Statement</li> <li><code>UPDATING ('column')</code>: an UPDATE Statement that affected the specified column</li> <li><code>DELETING</code>: a DELETE Statement\\</li> </ul> <p>Examples</p> <pre><code>IF INSERTING THEN\n  [PL/SQL Statements]\nEND IF;\n\nCASE\n  WHEN INSERTING THEN\n    [PL/SQL Statements]\n  WHEN UPDATING THEN\n    [PL/SQL Statements]\n  WHEN DELETING THEN\n    [PL/SQL Statements]\nEND CASE;\n</code></pre>"},{"location":"PLSQL/triggers/#correlation-names","title":"Correlation Names","text":"<p>(also know as Pseudorecords) Some Trigger Bodies can also use Correlation Names, which by default are:</p> <ul> <li><code>:NEW.column_name</code>: represents the new value</li> <li><code>:OLD.column_name</code>: represents the old value that is being replaced</li> </ul> Triggering Statement OLD.column_name Value NEW.column_name Value <code>INSERT</code> NULL Post-insert value <code>UPDATE</code> Pre-update value Post-update value <code>DELETE</code> Pre-delete value NULL <p>Notes</p> <ul> <li>A Trigger cannot change the OLD values.<ul> <li>This operation raises the <code>ORA-04085</code> error.</li> </ul> </li> <li>A Trigger cannot change NEW values if the Triggering Statement is DELETE.<ul> <li>This operation raises the <code>ORA-04084</code> error.</li> </ul> </li> <li>An AFTER Trigger cannot change NEW values, because the Triggering Statement runs before the Trigger fires.<ul> <li>This operation raises <code>ORA-04084</code> error.</li> </ul> </li> <li>If a Statement triggers both a BEFORE and an AFTER Trigger, and the BEFORE changes a NEW value, then the AFTER Trigger can see that change.</li> </ul>"},{"location":"PLSQL/triggers/#instead-of-trigger","title":"INSTEAD OF Trigger","text":"<p>An INSTEAD OF Trigger is a DML Trigger created on a noneditioning View. The Database fires the INSTEAD OF Trigger instead of running the triggering DML Statement.</p> <p>INSTEAD OF Triggers are always row-level Triggers. They can also use the OLD and NEW variables, but cannot change them.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] TRIGGER [schema.]trigger_name\n  INSTEAD OF {INSERT | UPDATE | DELETE [OR INSERT | UPDATE | DELETE]}\n  ON view_name\n  FOR EACH ROW\n  [FOLLOWS | PRECEDES [schema.]trigger_name]\n  [ENABLE | DISABLE]\n[DECLARE section]\nBEGIN\n  ...\n[EXCEPTION section]\nEND;\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: re-creates the Trigger if it exists.</li> <li>schema: schema on which the Trigger will be created (default is current schema).</li> <li>trigger_name: name of the Trigger.</li> <li><code>DELETE</code>: the Trigger is fired whenever a row is deleted from the Table on which the View is defined.</li> <li><code>INSERT</code>: the Trigger is fired whenever a new row is inserted into the Table on which the View is defined.</li> <li><code>UPDATE</code>: the Trigger is fired whenever a row is updated on the Table on which the View is defined.</li> <li><code>ON view_name</code>: View on which the Trigger is defined. </li> <li><code>FOR EACH ROW</code>: mandatory for INSTEAD OF Triggers. The Trigger is fired for each row that is affected.</li> <li><code>FOLLOWS | PRECEDES schema.trigger_name</code>: indicates if the Trigger should be fired after (FOLLOWS) or before (PRECEDES) another Trigger.</li> <li><code>ENABLE | DISABLE</code>: creates the Trigger in an Enabled/Disables state. Default is ENABLE.</li> </ul> Sources <ul> <li>Oracle Documentation - INSTEAD OF DML Triggers</li> </ul>"},{"location":"PLSQL/triggers/#system-triggers","title":"System Triggers","text":"<p>A System Trigger is created on either a schema or the database. Its triggering event is composed of either DDL Statements or Database Operation Statements.</p> <p>A System Trigger fires at exactly one of these timing points:</p> <ul> <li>Before the Triggering Statement runs (BEFORE Trigger)</li> <li>After the Triggering Statement runs (AFTER Trigger)</li> <li>Instead of the triggering CREATE Statement (INSTEAD OF CREATE Trigger)</li> </ul> <p>DDL Statements These are the DDL Statements that are part of System Triggers:</p> <ul> <li><code>ALTER</code></li> <li><code>ANALYZE</code></li> <li><code>ASSOCIATE STATISTICS</code></li> <li><code>AUDIT</code></li> <li><code>COMMENT</code></li> <li><code>CREATE</code></li> <li><code>DISASSOCIATE STATISTICS</code></li> <li><code>DROP</code></li> <li><code>GRANT</code></li> <li><code>NOAUDIT</code></li> <li><code>RENAME</code></li> <li><code>REVOKE</code></li> <li><code>TRUNCATE</code></li> <li><code>DDL</code><ul> <li>causes the Trigger to fire whenever any of the preceding DDL Statements is issued</li> </ul> </li> </ul> <p>Database Operation Statements Thesere are the Database Operation Statements that are part of System Triggers:</p> <ul> <li><code>AFTER STARTUP</code></li> <li><code>BEFORE SHUTDOWN</code></li> <li><code>AFTER DB_ROLE_CHANGE</code></li> <li><code>AFTER SERVERERROR</code></li> <li><code>AFTER LOGON</code></li> <li><code>BEFORE LOGOFF</code></li> <li><code>AFTER SUSPEND</code></li> <li><code>AFTER CLONE</code></li> <li><code>BEFORE UNPLUG</code></li> <li><code>[BEFORE | AFTER] SET CONTAINER</code></li> </ul> Sources <ul> <li>Oracle Documentation - System Triggers</li> <li>Oracle Documentation - List of DDL Statements</li> <li>Oracle Documentation - List of Database Events</li> </ul>"},{"location":"PLSQL/triggers/#drop-trigger-statement","title":"DROP TRIGGER Statement","text":"<p>Syntax <pre><code>DROP TRIGGER [schema.]trigger_name;\n</code></pre></p> <p>Privilege Restrictions</p> <ul> <li><code>GRANT DROP ANY TRIGGER TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - DROP TRIGGER Statement</li> </ul>"},{"location":"SQL/DDL/","title":"DDL Statements","text":"<p>The DDL (Data Definition Language) Statements are:</p> <ul> <li><code>ALTER ...</code> (all statements beginning with ALTER)</li> <li><code>ANALYZE</code></li> <li><code>ASSOCIATE STATISTICS</code></li> <li><code>AUDIT</code></li> <li><code>COMMENT</code></li> <li><code>CREATE ...</code> (all statements beginning with CREATE)</li> <li><code>DISASSOCIATE STATISTICS</code></li> <li><code>DROP ...</code> (all statements beginning with DROP)</li> <li><code>FLASHBACK ...</code> (all statements beginning with FLASHBACK)</li> <li><code>GRANT</code></li> <li><code>NOAUDIT</code></li> <li><code>PURGE</code></li> <li><code>RENAME</code></li> <li><code>REVOKE</code></li> <li><code>TRUNCATE</code></li> <li><code>UNDROP</code></li> </ul> <p>Notes</p> <ul> <li>Oracle Database implicitly commits the current Transaction before and after every DDL Statement.</li> <li><code>CREATE</code>, <code>ALTER</code> and <code>DROP</code> requires exclusive access to the specified Table. You cannot execute any of these commands if another User has an open Transaction on the Table.</li> </ul> Sources <ul> <li>Oracle Documentation - Data Definition Language (DDL) Statements</li> </ul>"},{"location":"SQL/DDL/#create-table","title":"CREATE TABLE","text":"<pre><code>-- manual column definition\nCREATE TABLE [schema.]table_name\n    ( column_name datatype [DEFAULT value]\n    [, column_name datatype [DEFAULT value]] );\n\n-- subquery definition\nCREATE TABLE [schema.]table_name\nAS subquery;\n</code></pre> Privilege Restrictions <ul> <li><code>GRANT CREATE ANY TABLE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE TABLE</li> </ul>"},{"location":"SQL/DDL/#create-directory","title":"CREATE DIRECTORY","text":"<pre><code>CREATE [OR REPLACE] DIRECTORY directory_name AS 'path_name';\n</code></pre> Privilege Restrictions <ul> <li><code>GRANT CREATE ANY DIRECTORY TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE DIRECTORY</li> </ul>"},{"location":"SQL/DDL/#drop-directory","title":"DROP DIRECTORY","text":"<pre><code>DROP DIRECTORY directory_name;\n</code></pre> Privilege Restrictions <ul> <li><code>GRANT DROP ANY DIRECTORY TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - DROP DIRECTORY</li> </ul>"},{"location":"SQL/DDL/#alter-table-add","title":"ALTER TABLE ... ADD","text":"<pre><code>ALTER TABLE [schema.]table_name\n    ADD (column_name datatype, [DEFAULT] ...);\n</code></pre> <p>Examples</p> <ul> <li><code>ALTER TABLE my_table ADD (my_column NUMBER(4));</code></li> </ul>"},{"location":"SQL/DDL/#alter-table-modify","title":"ALTER TABLE ... MODIFY","text":"<pre><code>ALTER TABLE [schema.]table_name\n    MODIFY (column_name datatype [DEFAULT], \u2026);\n</code></pre> <p>Examples</p> <ul> <li><code>ALTER TABLE my_table MODIFY (my_column CHAR(1) DEFAULT 'N');</code></li> </ul>"},{"location":"SQL/DDL/#alter-table-drop","title":"ALTER TABLE ... DROP","text":"<pre><code>-- dropping one column\nALTER TABLE [schema.]table_name\n    DROP COLUMN column_name [CASCADE CONSTRAINTS];\n\n-- dropping multiple columns\nALTER TABLE [schema.]table_name\n    DROP (column_name, \u2026) [CASCADE CONSTRAINTS];\n</code></pre> <p>Notes</p> <ul> <li>When the column data is dropped:<ul> <li>all indexes defined on any of the target columns are also dropped</li> <li>all constraints that reference a target column are removed</li> </ul> </li> </ul>"},{"location":"SQL/DDL/#alter-table-set-unused","title":"ALTER TABLE ... SET UNUSED","text":"<pre><code>ALTER TABLE [schema.]table_name\n    SET UNUSED [COLUMN] (column_name);\n</code></pre> <p>Notes</p> <ul> <li>Unused columns are treated as if they were dropped, even though their column data remains in the table rows. After a column has been marked UNUSED, you have no access to that column.</li> <li>You can add to the table a new column with the same name as an unused column.</li> </ul>"},{"location":"SQL/DDL/#alter-table-drop-unused-columns","title":"ALTER TABLE ... DROP UNUSED COLUMNS","text":"<pre><code>ALTER TABLE [schema.]table_name\n    DROP UNUSED COLUMNS;\n</code></pre> <p>Notes</p> <ul> <li>If the table contains no unused columns, then the statement returns with no errors.</li> </ul>"},{"location":"SQL/DDL/#alter-table-exchange-partition","title":"ALTER TABLE ... EXCHANGE PARTITION","text":"<pre><code>ALTER TABLE [schema.]target_table EXCHANGE PARTITION partition_name\n  WITH TABLE [schema.]source_table;\n</code></pre> <ul> <li>Data from the source_table goes into the target_table.</li> </ul>"},{"location":"SQL/DDL/#rename-statement","title":"RENAME Statement","text":"<pre><code>RENAME [schema.]old_object_name TO [schema.]new_object_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - RENAME</li> </ul>"},{"location":"SQL/DDL/#truncate-table","title":"TRUNCATE TABLE","text":"<pre><code>TRUNCATE TABLE [schema.]table_name\n    [{PRESERVE | PURGE} MATERIALIZED VIEW LOG]\n    [{DROP ALL | REUSE} STORAGE]\n    [CASCADE];\n</code></pre> <p>Semantics</p> <ul> <li><code>PRESERVE MATERIALIZED VIEW LOG</code>: specify PRESERVE if any Materialized View Log should be preserved.</li> <li>this is the default option.</li> <li><code>PURGE MATERIALIZED VIEW LOG</code>: specify PURGE if any Materialized View log should be purged.</li> <li><code>DROP STORAGE</code>: specify DROP ALL STORAGE to deallocate all space from the deleted rows from the Table.</li> <li><code>REUSE STORAGE</code>: specify REUSE STORAGE to retain the space from the deleted rows allocated to the table. This space can subsequently be used only by new data in the table resulting from insert or update operations.</li> <li><code>CASCADE</code>: Oracle Database truncates all child Tables that reference table_name with an enabled ON DELETE CASCADE referential constraint.</li> </ul> <p>Notes</p> <ul> <li>Removing rows with the TRUNCATE TABLE statement can be faster than removing all rows with the DELETE statement.</li> <li>You cannot flash back to the state of the Table before the TRUNCATE operation.</li> <li>You cannot TRUNCATE the parent table of an enabled Foreign Key constraint. You must disable the constraint before truncating the Table.</li> </ul> Privilege Restrictions <ul> <li><code>GRANT DROP ANY TABLE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - TRUNCATE TABLE</li> </ul>"},{"location":"SQL/DDL/#drop-table","title":"DROP TABLE","text":"<pre><code>DROP TABLE [schema.]table_name [CASCADE CONSTRAINTS] [PURGE];\n</code></pre> <p>Semantics</p> <ul> <li><code>CASCADE CONSTRAINTS</code>: drop all referential integrity constraints that refer to primary and unique keys in the dropped Table.</li> <li><code>PURGE</code>: drop the Table and release the space associated with it.</li> </ul> <p>Notes</p> <ul> <li>After a successful DROP TABLE...<ul> <li>An uncommited transaction is automatically committed.</li> <li>All indexes and constraints defined on the table are also dropped.</li> <li>The dropped table may be moved to the Recycle Bin.</li> <li>The dropped table cannot be recovered using the ROLLBACK command.</li> <li>Sequences used in the dropped table do remain valid.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - DROP TABLE</li> </ul>"},{"location":"SQL/DDL/#purge-statement","title":"PURGE Statement","text":"<pre><code>PURGE {\nTABLE [schema.]table_name |\nINDEX idx_name |\nTABLESPACE tablespace_name |\nRECYCLEBIN\nDBA_RECYCLEBIN };\n</code></pre> <p>Notes</p> <ul> <li>You cannot recover an object after it is purged.</li> <li>See the contents of the Recycle Bin with the following query: <pre><code>SELECT * FROM RECYCLEBIN;\n</code></pre></li> </ul> Sources <ul> <li>Oracle Documentation - PURGE</li> </ul>"},{"location":"SQL/DDL/#add-a-primary-key-constraint-to-existing-table","title":"Add a PRIMARY KEY Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] PRIMARY KEY (column_name);\n</code></pre>"},{"location":"SQL/DDL/#add-a-foreign-key-constraint-to-existing-table","title":"Add a FOREIGN KEY Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] FOREIGN KEY (column_name)\n    REFERENCES referencedtablename (referencedcolumnname);\n</code></pre>"},{"location":"SQL/DDL/#add-a-unique-constraint-to-existing-table","title":"Add a UNIQUE Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] UNIQUE (column_name);\n</code></pre>"},{"location":"SQL/DDL/#add-a-check-constraint-to-existing-table","title":"Add a CHECK Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] CHECK (condition);\n</code></pre>"},{"location":"SQL/DDL/#add-a-not-null-constraint-to-existing-table","title":"Add a NOT NULL Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    MODIFY (column_name [CONSTRAINT constraint_name] NOT NULL);\n</code></pre>"},{"location":"SQL/DDL/#enabling-constraints","title":"Enabling Constraints","text":"<pre><code>ALTER TABLE table_name\n    DISABLE CONSTRAINT constraint_name;\n\nALTER TABLE table_name\n    ENABLE CONSTRAINT constraint_name;\n</code></pre>"},{"location":"SQL/DDL/#dropping-constraints","title":"Dropping Constraints","text":"<pre><code>ALTER TABLE table_name\n    DROP PRIMARY KEY | UNIQUE (column_name) | CONSTRAINT constraint_name;\n</code></pre>"},{"location":"SQL/DML/","title":"DML Statements","text":"<p>The DML (Data Manipulation Language) Statements are:</p> <ul> <li><code>CALL</code></li> <li><code>DELETE</code></li> <li><code>EXPLAIN PLAN</code></li> <li><code>INSERT</code></li> <li><code>LOCK TABLE</code></li> <li><code>MERGE</code></li> <li><code>SELECT</code></li> <li><code>UPDATE</code></li> </ul> <p>Notes</p> <ul> <li>DML Statementes do not implicitly commit the current Transaction.</li> </ul> Sources <ul> <li>Oracle Documentation - Data Manipulation Language (DML) Statements</li> </ul>"},{"location":"SQL/DML/#insert","title":"INSERT","text":"<pre><code>INSERT [hint]\nINTO {[schema.]table_name | subquery}\n    [column_1, column_n]\n{VALUES (column_1_value, column_n_value) | subquery};\n</code></pre> <p>Notes</p> <ul> <li>If the column list is omitted, then the VALUES clause must specify values for all columns in the Table.</li> <li>If the specified partition_name does not exist, the database returns an error.</li> <li>If a View was created using the <code>WITH CHECK OPTION</code> clause, then you can insert into the View only rows that satisfy the defining query of the View.</li> <li>You cannot specify <code>DEFAULT</code> in the VALUES clause when inserting into a View.</li> <li>column_1_value can be a Subquery, but must return only 1 row.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - INSERT Statement</li> <li>Oracle Live SQL - Inserting Data through a Subquery</li> </ul> Sources <ul> <li>Oracle Documentation - INSERT</li> </ul>"},{"location":"SQL/DML/#insert-all","title":"INSERT ALL","text":"<pre><code>-- unconditional INSERT ALL\nINSERT ALL\nINTO table_1 (column_a, column_b) VALUES (column_1, column_2)\n    INTO table_2 (column_c, column_d) VALUES (column_1, column_2)\n    INTO table_3 (column_e, column_f) VALUES (column_1, column_2)\nSELECT column_1[, column_n]\nFROM source_table;\n\n-- conditional INSERT ALL\nINSERT ALL\n    WHEN condition THEN\n        INTO table_1 (column_a, column_b) VALUES (column_1, column_2)\n    WHEN condition THEN\n        INTO table_2 (column_c, column_d) VALUES (column_1, column_2)\n    WHEN condition THEN\n        INTO table_3 (column_e, column_f) VALUES (column_1, column_2)\nSELECT column_1, column_2\nFROM source_table;\n</code></pre> <p>Notes</p> <ul> <li>When using an unconditional INSERT ALL statement, each row produced by the driving query results in a new row in each of the tables listed in the INTO clauses.</li> <li>In a conditional INSERT ALL statement, conditions can be added to the INTO clauses, which means the total number of rows inserted may be less that the number of source rows multiplied by the number of INTO clauses.</li> <li>Multitable inserts can only be performed on Tables, not on Views or Materialized Views.</li> <li>Sequences cannot be used in the multitable insert statement. It is considered a single statement, so only one sequence value will be generated and used for all rows.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - Unconditional INSERT ALL</li> <li>Oracle Live SQL - Conditional INSERT ALL</li> </ul> Sources <ul> <li>Oracle Documentation - INSERT: multi_table_insert</li> </ul>"},{"location":"SQL/DML/#merge","title":"MERGE","text":"<pre><code>MERGE INTO [hint] [schema.]target_table\nUSING [schema.]source_table\nON (search_condition)\n    WHEN MATCHED THEN\n        UPDATE SET column_1 = value_1, column_2 = value_2, ...\n        WHERE [condition]\n        [DELETE WHERE condition]\n    WHEN NOT MATCHED THEN\n        INSERT (column_1, column_2, ...)\n        VALUES (value_1, value_2, ...)\n        WHERE [condition];\n</code></pre> <p>Notes</p> <ul> <li>You cannot update the same row of the target Table multiple times in the same MERGE statement. </li> <li>You cannot update a column that is referenced in the ON condition clause. </li> </ul> <p>Examples</p> <p><pre><code>MERGE INTO author a\nUSING customers c\nON (a.authorid = TO_CHAR(c.customer#))\n    WHEN MATCHED THEN\n        UPDATE SET a.lname = c.lastname, a.fname = c.firstname\n    WHEN NOT MATCHED THEN\n        INSERT (a.authorid, a.lname, a.fname)\n        VALUES (c.customer#, c.lastname, c.firstname);\n</code></pre> For each row in Author:</p> <ul> <li>If authorid and customer# are equal, then update the Author's lastname (a.lname) and first name (a.fname) with the Customer's last name (c.lastname) and first name (c.firstname).</li> <li>Otherwise inserts a new row in Author with Customer's data.</li> </ul> Sources <ul> <li>Oracle Documentation - MERGE</li> </ul>"},{"location":"SQL/advanced/","title":"Advanced Concepts","text":""},{"location":"SQL/advanced/#arithmetic-operations-on-dates","title":"Arithmetic Operations on Dates","text":"<p>Rules</p> <ul> <li>Operations between DATE value and Binary Operators<ul> <li>+ Addition: adds days to a DATE value; DATE value must be at the left-side.</li> <li>- Subtraction: subtracts days to a DATE value; DATE value must be at the left-side.</li> <li>* Multiplication: NOT ALLOWED</li> <li>/ Division: NOT ALLOWED</li> </ul> </li> <li>Operations between two DATE values<ul> <li>+ Addition: NOT ALLOWED</li> <li>- Subtraction: return number of days between the two Dates</li> <li>* Multiplication: NOT ALLOWED</li> <li>/ Division: NOT ALLOWED</li> </ul> </li> </ul> <p>Supposing SYSDATE is 28-NOV-22:</p> <ul> <li><code>SYSDATE - 1</code> \u2192 27-NOV-22</li> <li><code>1 - SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE + 1</code> \u2192 29-NOV-22</li> <li><code>1 + SYSDATE</code> \u2192 29-NOV-2022</li> <li><code>SYSDATE * 1</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>1 * SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE / 1</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>1 / SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE - TO_DATE('27-NOV-2022')</code> \u2192 1<ul> <li>Calculates number of days between two dates.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - Datetime/Interval Arithmetic</li> </ul>"},{"location":"SQL/advanced/#rrrr-vs-yyyy","title":"RRRR vs. YYYY","text":"<ul> <li>YYYY: first two digits will always be current century (99 \u2192 2099).</li> <li>RRRR: first two digits depend on range:<ul> <li>years in range 00 to 49 are assumed to be in current century (21 \u2192 2021)</li> <li>years in range 50 to 99 are assumed to be in the previous century (99 \u2192 1999)</li> </ul> </li> </ul> <p>There's no difference when working with 4-digits years. \"2022\" will always be 2022 no matter if you're using YYYY or RRRR as format mask.</p>"},{"location":"SQL/advanced/#nls_date_format","title":"NLS_DATE_FORMAT","text":"<p><code>NLS_DATE_FORMAT</code> specifies the default date format to use with the <code>TO_CHAR</code> and <code>TO_DATE</code> functions. The default value of this parameter is determined by <code>NLS_TERRITORY</code>.</p> <p>The value of this parameter can be any valid date format mask, and the value must be surrounded by double quotation marks. For example: <pre><code>NLS_DATE_FORMAT = \"MM/DD/YYYY\"\n</code></pre></p> <p>Current Date Mask <pre><code>SELECT VALUE\nFROM NLS_SESSION_PARAMETERS\nWHERE PARAMETER = 'NLS_DATE_FORMAT';\n</code></pre></p> Sources <ul> <li>Oracle Documentation - NLS_DATE_FORMAT</li> </ul>"},{"location":"SQL/advanced/#pivot","title":"PIVOT","text":"<pre><code>SELECT * FROM\n(\n    SELECT column1, column2\n    FROM tables\n    WHERE condition\n)\nPIVOT\n(\n    aggregate_function(column2)\n    FOR column2\n    IN (expression1, expression2, ... expression_n) | subquery\n)\nORDER BY expression [ASC | DESC];\n</code></pre> <p>Examples</p> <ul> <li>Oracle Live SQL - PIVOT</li> </ul> Sources <ul> <li>Oracle Documentation - SELECT: pivot_clause</li> </ul>"},{"location":"SQL/advanced/#with-function","title":"WITH FUNCTION","text":"<pre><code>WITH FUNCTION function_name (parameters) RETURN datatype\nIS\n    [declaration_statements]\nBEGIN\n    function_statements\n    RETURN variable;\nEND;\nSELECT statement\n</code></pre> <p>Examples</p> <pre><code>WITH FUNCTION get_value (in_value IN number) RETURN NUMBER\nIS\n    final_value NUMBER := 2;\nBEGIN\n    final_value := in_value * final_value;\n    RETURN final_value;\nEND;\nSELECT get_value(2)\nFROM dual;\n</code></pre>"},{"location":"SQL/basics/","title":"Basic Concepts","text":""},{"location":"SQL/basics/#select-statement","title":"SELECT Statement","text":"<pre><code>SELECT      [DISTINCT | UNIQUE] (, columnname [AS alias], \u2026)\nFROM        tablename\n[WHERE      condition]\n[GROUP BY   group_by_expression]\n[HAVING     group_condition]\n[ORDER BY   columnname];\n</code></pre> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#column-aliases","title":"Column Aliases","text":"<pre><code>column_name [AS] alias_name\n</code></pre> <p>Notes</p> <ul> <li>If alias_name contains spaces, you must enclose alias_name in quotes.</li> </ul> <p>Examples</p> <ul> <li><code>first_name AS Employee</code></li> <li><code>first_name Employee</code></li> <li><code>first_name || ' ' || last_name AS \"Employee Details\"</code></li> <li><code>first_name \"Employee's First Name\"</code></li> </ul> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#distinct","title":"DISTINCT","text":"<pre><code>SELECT DISTINCT column_name\nFROM table_name;\n</code></pre> <p>Notes</p> <ul> <li>When only one expression is provided in the DISTINCT clause, the query will return the unique values for that expression.</li> <li>When more than one expression is provided in the DISTINCT clause, the query will retrieve unique combinations for the expressions listed.</li> <li>DISTINCT does not ignore NULL values. If there are multiple NULL values, it will return only one NULL.</li> <li>UNIQUE is a synonym of DISTINCT.</li> <li>You cannot specify DISTINCT if the SELECT list contains LOB columns.</li> </ul> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#query-processing-order-order-of-execution","title":"Query Processing Order / Order of Execution","text":"<pre><code>FROM\nWHERE\nGROUP BY\nSELECT\nHAVING\nORDER BY\n</code></pre> Sources <ul> <li>Oracle SQL and PL/SQL Optimization for Developers - Query Processing Order</li> </ul>"},{"location":"SQL/basics/#alternative-quote-operator-q","title":"Alternative Quote Operator (q)","text":"<pre><code>SELECT  q'{text}', column_1, ..., column_n\nFROM    tablename;\n</code></pre> Examples <ul> <li>Oracle Live SQL - Alternative Quote Operator</li> </ul>"},{"location":"SQL/basics/#operator-and-condition-precedence","title":"Operator and Condition Precedence","text":"<ul> <li>*, /*</li> <li>+, -</li> <li>=, !=, &lt;, &gt;, &lt;=, &gt;=</li> <li><code>IS [NOT] NULL</code>, <code>LIKE</code>, <code>[NOT] BETWEEN</code>, <code>[NOT] IN</code>, <code>EXISTS</code>, <code>IS OF</code></li> <li>NOT</li> <li>AND</li> <li>OR</li> </ul> Sources <ul> <li>Oracle Documentation - Condition Precedence</li> <li>Oracle Documentation - Operator Precedence</li> </ul>"},{"location":"SQL/basics/#describe","title":"DESCRIBE","text":"<pre><code>DESC[RIBE] [schema.]object;\n</code></pre> <p>Notes</p> <ul> <li>object can be:<ul> <li>a Table</li> <li>a View</li> <li>a Synonym</li> <li>a PL/SQL Type</li> <li>a PL/SQL Procedure</li> <li>a PL/SQL Function</li> <li>a PL/SQL Package</li> </ul> </li> <li>the description for object contains the following information:<ul> <li>each column's name</li> <li>whether or not null values are allowed (NULL or NOT NULL) for each column</li> <li>datatype of columns and their precision (and scale, if any, for a numeric column)</li> </ul> </li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - DESC</li> </ul> Sources <ul> <li>Oracle Documentation - DESCRIBE</li> </ul>"},{"location":"SQL/basics/#default-clause","title":"DEFAULT Clause","text":"<pre><code>CREATE TABLE [schema.]table_name (\n    column_1 datatype DEFAULT value\n);\n</code></pre> <p>Semantics</p> <ul> <li><code>DEFAULT value</code>: value must be the same datatype as the column definition (or must be implicitly convertible). </li> </ul> <p>Notes</p> <ul> <li>value cannot be a subquery.</li> <li>value can be a Sequence's CURRVAL or NEXTVAL.</li> <li>If the Sequence is dropped, the Database will return an error for all the subsequent INSERTs.</li> <li>value cannot be an user-defined PL/SQL Function.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - DEFAULT Clause</li> <li>Oracle Live SQL - DEFAULT Clause - Using a Sequence</li> </ul> Sources <ul> <li>Oracle Documentation - DEFAULT</li> </ul>"},{"location":"SQL/constraints/","title":"Constraints","text":"<p>The following Constraints are available in Oracle Database:</p> <ul> <li><code>NOT NULL</code></li> <li><code>UNIQUE</code></li> <li><code>PRIMARY KEY</code></li> <li><code>FOREIGN KEY</code></li> <li><code>CHECK</code></li> </ul> <p>Constraints can appear in the following statements:</p> <ul> <li><code>CREATE TABLE</code></li> <li><code>ALTER TABLE</code></li> <li><code>CREATE VIEW</code></li> <li><code>ALTER VIEW</code></li> </ul> <p>and they can be defined in two ways:</p> <ul> <li>inline: as part of the definition of an individual column</li> <li>out-of-line: as part of the Table definition</li> </ul>"},{"location":"SQL/constraints/#unique-constraint","title":"UNIQUE Constraint","text":"<pre><code>-- inline syntax\nCREATE TABLE table_name(\n    column_name datatype [CONSTRAINT constraint_name] UNIQUE\n);\n\n-- out of line syntax\nCREATE TABLE table_name(\n    column_name datatype,\n    [column_name_n datatype,]\n    [CONSTRAINT constraint_name] UNIQUE (column_name)\n);\n\n-- composite UNIQUE Key\nCREATE TABLE table_name(\n    column_name_1 datatype,\n    [column_name_n datatype,]\n    [CONSTRAINT constraint_name] UNIQUE (column_name_1, column_name_2)\n);\n</code></pre> <p>Notes</p> <ul> <li>A UNIQUE Constraint prohibits multiple rows from having the same value in the same column or combination of columns but allows some values to be NULL.</li> <li>When defining a UNIQUE Constraint on one or more columns, Oracle automatically creates an index on the column(s).</li> <li>To improve queries performance, it is recommended to create an UNIQUE INDEX instead of a UNIQUE Constraint.</li> <li>Despite the UNIQUE constraint allowing multiple NULL values, if only one column of a Composite Unique Key has a NULL value, then the other column must have a different value. See this example.</li> <li>A Primary Key column cannot be part of a UNIQUE Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Unique Constraints</li> </ul>"},{"location":"SQL/constraints/#not-null-constraint","title":"NOT NULL Constraint","text":"<pre><code>CREATE TABLE table_name(\n    column_name_1 datatype [NULL | NOT NULL]\n);\n</code></pre> <p>Notes</p> <ul> <li>A NOT NULL constraint prohibits a column from containing nulls.</li> <li>A NOT NULL Constraint must be defined inline. </li> <li>It is possible to specify NULL to explicitly permit a column to contain NULLs.</li> </ul> Sources <ul> <li>Oracle Documentation - NOT NULL Constraints</li> </ul>"},{"location":"SQL/constraints/#primary-key-constraint","title":"PRIMARY KEY Constraint","text":"<pre><code>-- inline syntax\nCREATE TABLE table_name(\n    column_name datatype [CONSTRAINT constraint_name] PRIMARY KEY\n);\n\n-- out of line syntax\nCREATE TABLE table_name(\n    column_name datatype,\n    [column_name_n datatype]\n    [CONSTRAINT constraint_name] PRIMARY KEY (column_name)\n);\n</code></pre> <p>Notes</p> <ul> <li>A Primary Key constraint designates a column as the Primary Key of a Table or View.</li> <li>A Primary Key constraint cannot contain duplicated values nor NULL values.</li> <li>Multiple columns can be part of a Primary Key (Composite Primary Key).</li> <li>If no Index is defined on the PRIMARY KEY columns, then Oracle automatically creates an Unique Index.<ul> <li>If an Unique Index is already defined on the Primary Key columns, then no new Index will be created and when the Primary Key Constraint is dropped, the Index will stay on the columns.</li> <li>Otherwise, the related Index will be dropped as well.</li> </ul> </li> <li>A Table or View can have only one Primary Key.</li> <li>A Primary Key column cannot be part of a UNIQUE Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Primary Key Constraints</li> </ul>"},{"location":"SQL/constraints/#foreign-key-constraints","title":"FOREIGN KEY Constraints","text":"<pre><code>CREATE TABLE parent_table_name(\n    parent_column_name datatype {PRIMARY KEY | UNIQUE}\n);\n\n-- out of line declaration\nCREATE TABLE child_table_name(\n    child_column_name datatype,\n    [column_name_n datatype]\n    [CONSTRAINT constraint_name] FOREIGN KEY (child_column_name)\n        REFERENCES parent_table_name (parent_column_name)\n        [ON DELETE {CASCADE | SET NULL}]\n);\n\n-- inline declaration\nCREATE TABLE child_table_name(\n    child_column_name datatype [CONSTRAINT constraint_name]\n        REFERENCES parent_table_name (parent_column_name)\n        [ON DELETE {CASCADE | SET NULL}]\n);\n</code></pre> <p>Semantics</p> <ul> <li><code>ON DELETE CASCADE</code>: remove dependent Foreign Key values (will remove the entire child row).</li> <li><code>ON DELETE SET NULL</code>: convert dependent Foreign Key values to NULL.<ul> <li>cannot be specified for Virtual Columns</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>A Foreign Key Constraint (also called a Referential Integrity Constraint) designates a column as the Foreign Key and establishes a relationship between that Foreign Key and a specified Primary or Unique key, called the Referenced Key.</li> <li>The Foreign Key and the Referenced Key can be in the same Table or View.</li> <li>Multiple columns can be part of a Foreign Key (Composite Foreign Key).</li> <li>A single column can be part of more than one Foreign Key.</li> <li>A Table can have multiple Foreign Keys.</li> <li>A Primary Key can also be a Foreign Key.</li> <li>The Referenced Unique or Primary Key constraint on the Parent Table or View must already be defined.</li> <li>The ON DELETE Clause cannot be specified for a View Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Foreign Key Constraints</li> </ul>"},{"location":"SQL/data-dictionary/","title":"Data Dictionary","text":"<p>Work in Progress Section</p>"},{"location":"SQL/data-dictionary/#prefixes-of-data-dictionary-views","title":"Prefixes of Data Dictionary Views","text":"<ul> <li><code>USER_</code> \u2192 objects owned by the current user accessing the view.</li> <li><code>ALL_</code> \u2192 objects owned by any user in the Database to which the current user has privileges.</li> <li><code>DBA_</code> \u2192 all objects in the Database.</li> <li><code>V_$</code> (Views) or <code>V$</code> (public synonyms) \u2192 Dynamic Pperformance Views, each of which has a public synonym counterpart. Stores information about the local database instance.</li> <li><code>GV_$</code> (Views) or <code>GV$</code> (public synonyms) \u2192 Global Dynamic Performance Views.</li> </ul>"},{"location":"SQL/data-dictionary/#dynamic-performance-views","title":"Dynamic Performance Views","text":"<ul> <li><code>V$DATABASE</code>: includes information about the Database itself, including the database name, the date created, etc.</li> <li><code>V$INSTANCE</code>: includes the instance name, host name, etc.</li> <li><code>V$PARAMETER</code>: current settings for system parameters such as NLS_LANGUAGE, NLS_DATE_LANGUAGE, NLS_CURRENCY, etc.</li> <li><code>V$SESSION</code>: current settings for each individual user session, showing active connections, login times, etc.</li> <li><code>V$RESERVED_WORDS</code>: current list of reserved words, including information indicating whether the keyword is always reserved, and if not, under what circumstances it is reserved.</li> <li><code>V$OBJECT_USAGE</code>: useful for monitoring the usage of INDEX objects</li> <li><code>V$TIMEZONE_NAMES</code>: includes two columns:<ul> <li><code>TZNAME</code>: time zone region</li> <li><code>TZABBREV</code>: time zone abbreviation</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - Overview of the Dynamic Performance Views</li> </ul>"},{"location":"SQL/data-dictionary/#checking-privileges-in-the-data-dictionary","title":"Checking Privileges in the Data Dictionary","text":"<p>Privileges can be inspected using the following views:</p> <ul> <li><code>USER_SYS_PRIVS</code>: System privileges granted to the current user</li> <li><code>USER_TAB_PRIVS</code>: Granted privileges on objects for which the user is the owner, grantor or grantee.</li> <li><code>USER_ROLE_PRIVS</code>: Roles granted to the current user.</li> <li><code>DBA_SYS_PRIVS</code>: System privileges granted to users and roles.</li> <li><code>DBA_TAB_PRIVS</code>: All grants on objects in the Database.</li> <li><code>DBA_ROLE_PRIVS</code>: Role granted to users and roles.</li> <li><code>ROLE_SYS_PRIVS</code>: System privileges granted to roles.</li> <li><code>ROLE_TAB_PRIVS</code>: Table privileges granted to roles.</li> <li><code>SESSION_PRIVS</code>: Session privileges that the user currenlty has set.</li> </ul>"},{"location":"SQL/data-dictionary/#user_catalog","title":"USER_CATALOG","text":"<p>The USER_CATALOG view displays a summary listing of tables, views, synonym, and sequences owned by the user. There are two columns in USER_CATALOG:</p> <ul> <li><code>TABLE_TYPE</code>: indicates the Database Object (SEQUENCE, TABLE, VIEW, etc.).</li> <li><code>TABLE_NAME</code>: name of the Table.</li> </ul> Sources <ul> <li>Oracle Documentation - USER_CATALOG</li> </ul>"},{"location":"SQL/data-dictionary/#user_objects","title":"USER_OBJECTS","text":"<p>The USER_OBJECTS view contain information about all objects owned by the user.</p> Sources <ul> <li>Oracle Documentation - USER_OBJECTS</li> </ul>"},{"location":"SQL/data-dictionary/#user_synonyms","title":"USER_SYNONYMS","text":"<p>The USER_SYNONYMS View describes the private synonyms (synonyms owned by the current user). Its columns (except for OWNER) are the same as those in ALL_SYNONYMS.</p> Sources <ul> <li>Oracle Documentation - USER_SYNONYMS</li> </ul>"},{"location":"SQL/data-dictionary/#user_tables","title":"USER_TABLES","text":"<p>The USER_TABLES view shows detailed information about the Tables owned by current session account.</p> <p>Some of the columns include:</p> <ul> <li><code>TABLE_NAME</code>: Name of the Table.</li> <li><code>STATUS</code>: Indicates whether the Table is currently valid and therefore available for use.</li> <li><code>ROW_MOVEMENT</code>: Indicates whether ROW MOVEMENT has been enabled for the Table.</li> <li><code>AVG_ROW_LEN</code>: Average length of the rows currently stored in the Table.</li> </ul> Sources <ul> <li>Oracle Documentation - USER_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#all_tables","title":"ALL_TABLES","text":"<p>The ALL_TABLES view shows detailed information about the Tables to which the current User has privileges, regardless of owner.</p> Sources <ul> <li>Oracle Documentation - ALL_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#dba_tables","title":"DBA_TABLES","text":"<p>The DBA_TABLES view shows detailed information about the Tables in the entire Database, regardless of owner or Table privileges.</p> Sources <ul> <li>Oracle Documentation - DBA_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#all_constraints","title":"ALL_CONSTRAINTS","text":"<p>ALL_CONSTRAINTS describes constraint definitions on tables accessible to the current user.</p> <p>Columns</p> <ul> <li><code>OWNER</code>: owner of the constraint</li> <li><code>CONSTRAINT_NAME</code>: constraint name</li> <li><code>CONSTRAINT_TYPE</code>: type of constraint (full list below)</li> <li><code>TABLE_NAME</code>: table on which the constraint is defined</li> <li><code>SEARCH_CONDITION</code>: text of search condition for a CHECK constraint</li> <li><code>R_OWNER</code>: owner of the parent constraint</li> <li><code>R_CONSTRAINT_NAME</code>: name of parent constraint (only for Foreign Keys)</li> <li><code>DELETE_RULE</code>: delete rule for a referential constraint (CASCADE, SET NULL, NO ACTION)</li> <li><code>STATUS</code>: constraint status (ENABLED, DISABLED)</li> <li><code>DEFERRABLE</code>: indicates if the constraint is DEFERRABLE or NOT DEFERRABLE</li> <li><code>DEFERRED</code>: indicates if the constraint was initially DEFERRED or not (IMMEDIATE)</li> <li><code>VALIDATED</code>:<ul> <li>if STATUS=ENABLED, possible values are:<ul> <li>VALIDATED: all data in the table obeys the constraint</li> <li>NOT VALIDATED: alla data in the table may not obey the constraint</li> </ul> </li> <li>if STATUS=DISABLED, possible values are:<ul> <li>VALIDATED: all data obeys the constraint but the unique index on the constraint has been dropped.</li> <li>NOT VALIDATED: all data may not obey the constraint</li> </ul> </li> </ul> </li> <li><code>GENERATED</code>: indicates if the constraint name is user-generated (USER NAME) or system-generated (GENERATED NAME)</li> <li><code>BAD</code>: indicates whether this constraint specifies a century in an ambiguous manner (BAD) or not (NULL).<ul> <li>to resolve the issue, rewrite the constraint using the TO_DATE function with a four-digit year</li> </ul> </li> <li><code>RELY</code>: [...]</li> <li><code>LAST_CHANGE</code>: when the constraint was last enabled or disabled</li> <li><code>INDEX_OWNER</code>: name of the user owning the index</li> <li><code>INDEX_NAME</code>: name of the index (only for UNIQUE and Primary Key constraints)</li> <li><code>INVALID</code>: indicates if the constraint is INVALID or not (NULL).</li> <li><code>VIEW_RELATED</code>: indicated if the constraint depends on a view (DEPEND ON VIEW) or not</li> <li><code>ORIGIN_CON_ID</code>: [...]</li> </ul> <p>Constraint Types</p> <ul> <li>C \u2192 CHECK Constraint</li> <li>P \u2192 PRIMARY KEY Constraint</li> <li>U \u2192 UNIQUE Key</li> <li>R \u2192 Referential Integrity</li> <li>V \u2192 WITH CHECK OPTION, on a View</li> <li>O \u2192 WITH READ ONLY, on a View</li> <li>H \u2192 Hash Expression</li> <li>F \u2192 Constraint that involves a REF Column</li> <li>S \u2192 Supplemental Logging</li> </ul> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> </ul>"},{"location":"SQL/data-dictionary/#get-existing-constraints-on-a-table","title":"Get existing Constraints on a Table","text":"<pre><code>SELECT \n    constraint_name\n    , constraint_type\n    , search_condition\n    , r_constraint_name\n    , delete_rule\n    , status\nFROM all_constraints\nWHERE UPPER(table_name) = UPPER('tablename');\n</code></pre> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> </ul>"},{"location":"SQL/data-dictionary/#get-primary-key-details-about-table","title":"Get Primary Key details about Table","text":"<pre><code>SELECT\n    cols.table_name\n    , cols.column_name\n    , cols.position\n    , cons.status, cons.owner\nFROM\n    all_constraints cons\n    INNER JOIN all_cons_columns cols\n        ON cons.constraint_name = cols.constraint_name\n        AND cons.owner = cols.owner\nWHERE cons.constraint_type = 'P'\nAND UPPER(cols.table_name) = UPPER('table_name')\nORDER BY cols.table_name, cols.position;\n</code></pre> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> <li>Oracle Documentation - ALL_CONS_COLUMNS</li> </ul>"},{"location":"SQL/data-dictionary/#get-current-date-format","title":"Get current Date format","text":"<pre><code>SELECT *\nFROM nls_session_parameters\nWHERE parameter = 'NLS_DATE_FORMAT';\n</code></pre> Sources <ul> <li>Oracle Documentation - NLS_SESSION_PARAMETERS</li> </ul>"},{"location":"SQL/data-dictionary/#get-list-of-updatable-columns-on-a-view","title":"Get List of updatable Columns on a View","text":"<pre><code>SELECT \n    table_name\n    , column_name\n    , updatable\n    , insertable\n    , deletable\nFROM USER_UPDATABLE_COLUMNS\nWHERE table_name= 'view_name'; \n</code></pre> Sources <ul> <li>Oracle Documentation - USER_UPDATABLE_COLUMNS</li> </ul>"},{"location":"SQL/data-dictionary/#nls_length_semantics","title":"NLS_LENGTH_SEMANTICS","text":"<p>Syntax <pre><code>SELECT PARAMETER, VALUE \nFROM NLS_SESSION_PARAMETERS \nWHERE PARAMETER = 'NLS_LENGTH_SEMANTICS';\n</code></pre></p> <p>Examples</p> <pre><code>SELECT PARAMETER, VALUE \nFROM NLS_SESSION_PARAMETERS \nWHERE PARAMETER = 'NLS_LENGTH_SEMANTICS';\n\n/*\nPARAMETER            | VALUE\n-------------------- | -----\nNLS_LENGTH_SEMANTICS | BYTE\n*/\n</code></pre> Sources <ul> <li>Oracle Documentation - NLS_LENGTH_SEMANTICS</li> </ul>"},{"location":"SQL/data-dictionary/#updating-nls_length_semantics","title":"Updating NLS_LENGTH_SEMANTICS","text":"<p>Syntax <pre><code>-- for the current session\nALTER SESSION SET NLS_LENGTH_SEMANTICS = '{CHAR | BYTE}';\n\n-- for the Database\nALTER SYSTEM SET NLS_LENGTH_SEMANTICS = '{CHAR | BYTE}' SCOPE = {BOTH | SPFILE};\n</code></pre></p> <ul> <li><code>CHAR | BYTE</code>: any new Character column will use CHAR or BYTE by default.</li> <li><code>BOTH</code>: makes the change for the running istance and in the parameter file (so it persists across database restarts)</li> <li><code>SPFILE</code>: makes the change after the next database restart.</li> </ul> <p>Notes</p> <ul> <li>This change only affects new Tables and not existing ones.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>ALTER SESSION</code>:<ul> <li>no Privilege is required to change the value for the current session.</li> </ul> </li> <li><code>ALTER SYSTEM</code>:<ul> <li><code>GRANT ALTER SYSTEM TO user_name;</code></li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - ALTER SESSION</li> <li>Oracle Documentation - ALTER SYSTEM</li> </ul>"},{"location":"SQL/datatypes/","title":"Datatypes","text":""},{"location":"SQL/datatypes/#character-dataypes","title":"Character Dataypes","text":"<ul> <li><code>CHAR</code></li> <li><code>VARCHAR2</code></li> <li><code>NCHAR</code></li> <li><code>NVARCHAR2</code></li> </ul>"},{"location":"SQL/datatypes/#char","title":"CHAR","text":"<pre><code>CHAR[(size [BYTE | CHAR])]\n</code></pre> <p>Notes</p> <ul> <li>Default and minimum size is 1.</li> <li>Maximum size is 2000 Bytes or Characters.</li> <li>If neither BYTE nor CHAR are specified, then the Database uses the value of <code>NLS_LENGTH_SEMANTICS</code>.</li> <li>If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length.</li> </ul> Sources <ul> <li>Oracle Documentation - CHAR Data Type</li> </ul>"},{"location":"SQL/datatypes/#varchar2","title":"VARCHAR2","text":"<pre><code>VARCHAR2(size [BYTE | CHAR])\n</code></pre> <p>Notes</p> <ul> <li>Minimum size is 1.</li> <li>Maximum size is 32767 for Bytes or 4000 for Characters.</li> <li>If neither BYTE nor CHAR are specified, then the Database uses the value of <code>NLS_LENGTH_SEMANTICS</code>.</li> </ul> Sources <ul> <li>Oracle Documentation - VARCHAR2 Data Type</li> </ul>"},{"location":"SQL/datatypes/#nchar","title":"NCHAR","text":"<pre><code>NCHAR[(size)]\n</code></pre> <p>Notes</p> <ul> <li>If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length.</li> <li>This datatype is generally used for storing characters in multiple languages.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - CHAR vs. NCHAR</li> </ul> Sources <ul> <li>Oracle Documentation - NCHAR Data Type</li> </ul>"},{"location":"SQL/datatypes/#nvarchar2","title":"NVARCHAR2","text":"<pre><code>NVARCHAR2(size)\n</code></pre> Sources <ul> <li>Oracle Documentation - NVARCHAR2 Data Type</li> </ul>"},{"location":"SQL/datatypes/#number-datatypes","title":"Number Datatypes","text":"<ul> <li><code>NUMBER</code></li> <li><code>FLOAT</code></li> <li><code>BINARY_FLOAT</code></li> <li><code>BINARY_DOUBLE</code></li> </ul>"},{"location":"SQL/datatypes/#number","title":"NUMBER","text":"<pre><code>NUMBER[(precision [,scale])]\n</code></pre> <p>Notes</p> <ul> <li>The precision can range from 1 to 38.</li> <li>The scale can range from -84 to 127.</li> <li>If not specified, the scale is 0.</li> <li>Numbers can go from \\(1.0\\) x \\(10^{-130}\\) to \\(1.0\\) x \\(10^{126}\\).</li> <li>If a value exceeds the precision, then Oracle returns an error. If a value exceeds the scale, then Oracle rounds it.</li> <li>The absence of precision and scale designators specifies the maximum range and precision for an Oracle number.</li> </ul> <p>Examples</p> <pre><code>NUMBER      \u2192 123.89 \u2192 123.89\nNUMBER(3)   \u2192 123.89 \u2192 124\nNUMBER(3,2) \u2192 123.89 \u2192 ORA-01438: value larger than specified precision allowed for this column\nNUMBER(5,2) \u2192 123.89 \u2192 123.89\nNUMBER(6,1) \u2192 123.89 \u2192 123.9 \n</code></pre> Sources <ul> <li>Oracle Documentation - NUMBER Data Type</li> </ul>"},{"location":"SQL/datatypes/#float-data-type","title":"FLOAT Data Type","text":"<pre><code>FLOAT[(precision)]\n</code></pre> <p>Notes</p> <ul> <li>Oracle recommends that you use the <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> data types instead.</li> </ul>"},{"location":"SQL/datatypes/#datetime-datatypes","title":"Datetime Datatypes","text":"<ul> <li><code>DATE</code></li> <li><code>TIMESTAMP</code></li> <li><code>INTERVAL YEAR TO MONTH</code></li> <li><code>INTERVAL DAY TO SECOND</code></li> </ul>"},{"location":"SQL/datatypes/#ansi-datatypes","title":"ANSI Datatypes","text":"<ul> <li><code>CHARACTER</code></li> <li><code>CHAR VARYING</code></li> <li><code>NCHAR VARYING</code></li> <li><code>VARCHAR</code></li> <li><code>NATIONAL CHARACTER</code>, <code>NATIONAL CHAR</code></li> <li><code>NUMERIC</code>, <code>DECIMAL</code>, <code>DEC</code></li> <li><code>INTEGER</code>, <code>INT</code>, <code>SMALLINT</code></li> <li><code>FLOAT</code></li> <li><code>DOUBLE PRECISION</code></li> <li><code>REAL</code></li> </ul>"},{"location":"SQL/datatypes/#other-datatypes","title":"Other Datatypes","text":"<ul> <li><code>LONG</code></li> <li><code>LONG RAW</code></li> <li><code>RAW</code></li> <li><code>BLOB</code></li> <li><code>CLOB</code></li> <li><code>NCLOB</code></li> <li><code>BFILE</code></li> <li><code>ROWID</code></li> <li><code>UROWID</code></li> </ul>"},{"location":"SQL/functions/","title":"Functions","text":""},{"location":"SQL/functions/#character-functions","title":"Character Functions","text":"<ul> <li><code>CONCAT</code></li> <li><code>INITCAP</code></li> <li><code>LOWER</code></li> <li><code>LPAD</code></li> <li><code>LTRIM</code></li> <li><code>REPLACE</code></li> <li><code>RPAD</code></li> <li><code>RTRIM</code></li> <li><code>SUBSTR</code></li> <li><code>TRIM</code></li> <li><code>UPPER</code></li> <li><code>INSTR</code></li> <li><code>LENGTH</code></li> </ul>"},{"location":"SQL/functions/#concat","title":"CONCAT","text":"<pre><code>CONCAT(string1, string2)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the first string to concatenate.</li> <li>string2: the second string to concatenate.</li> </ul> <p>Notes</p> <ul> <li>The CONCAT Function concatenates two strings and returns the combined string.</li> <li>The two strings do not need to be the same data type.</li> </ul> Sources <ul> <li>Oracle Documentation - CONCAT</li> </ul>"},{"location":"SQL/functions/#initcap","title":"INITCAP","text":"<pre><code>INITCAP(string1)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string argument whose first character in each word will be converted to uppercase and all remaining characters converted to lowercase.</li> </ul> <p>Notes</p> <ul> <li>The INITCAP Function sets the first character in each word to uppercase and the rest to lowercase.</li> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT INITCAP('hello everyone!') FROM dual;\n-- Hello Everyone!\n\nSELECT INITCAP(1234567890) FROM dual;\n-- 1234567890\n\nSELECT INITCAP(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-Nov-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - INITCAP</li> </ul>"},{"location":"SQL/functions/#lower","title":"LOWER","text":"<pre><code>LOWER(string1)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to convert to lowercase.</li> </ul> <p>Notes</p> <ul> <li>The LOWER Function converts all letters in the specified string to lowercase.</li> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT LOWER('hello EVERYONE!') FROM dual;\n-- hello everyone!\n\nSELECT LOWER(1234567890) FROM dual;\n-- 1234567890\n\nSELECT LOWER(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-nov-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - LOWER</li> </ul>"},{"location":"SQL/functions/#upper","title":"UPPER","text":"<pre><code>UPPER(string1)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to convert to uppercase.</li> </ul> <p>Notes</p> <ul> <li>The UPPER Function converts all letters in the specified string to uppercase.</li> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT UPPER('hello EVERYONE!') FROM dual;\n-- HELLO EVERYONE!\n\nSELECT UPPER(1234567890) FROM dual;\n-- 1234567890\n\nSELECT UPPER(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-NOV-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - UPPER</li> </ul>"},{"location":"SQL/functions/#lpad-rpad","title":"LPAD &amp; RPAD","text":"<pre><code>LPAD(string1, padded_length, [, pad_string])\nRPAD(string1, padded_length, [, pad_string])\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to pad characters to (the left/right-hand side).</li> <li>padded_length: the number of characters to return.</li> <li>pad_string the string that will be padded to the left/right-hand side of string1.</li> <li>optional value; default is blank space.</li> </ul> <p>Notes</p> <ul> <li>The LPAD &amp; RPAD Functions pad the left/right-side of a string with a specific set of characters.</li> <li>If string1 is NULL, the function returns NULL.</li> <li>If the padded_length is smaller than the original string, the function will truncate the string to the size of padded_length.</li> </ul> <p>Examples</p> <pre><code>SELECT LPAD('Hello!', 10, 'a') FROM dual;\n-- aaaaHello!\n\nSELECT RPAD('Hello!', 10, 'a') FROM dual;\n-- Hello!aaaa\n</code></pre> Sources <ul> <li>Oracle Documentation - LPAD</li> <li>Oracle Documentation - RPAD</li> </ul>"},{"location":"SQL/functions/#ltrim-rtrim","title":"LTRIM &amp; RTRIM","text":"<pre><code>LTRIM(string1, [, trim_string])\nRPAD(string1, [, trim_string])\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to trim the characters from the left/right-hand side.</li> <li>trim_string: the string that will be removed from the left/right-hand side of string1.<ul> <li>default is blank space.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The LTRIM &amp; RTRIM Functions remove all specified characters from the left/right-hand side of a string.</li> </ul> <p>Examples</p> <pre><code>SELECT LTRIM('Hello!','H') FROM dual;\n-- ello!\n\nSELECT RTRIM('Hello!', '!') FROM dual;\n-- Hello\n\nSELECT LTRIM('Hello!', 'h') FROM dual;\n-- Hello!\n</code></pre> Sources <ul> <li>Oracle Documentation - LTRIM</li> <li>Oracle Documentation - RTRIM</li> </ul>"},{"location":"SQL/functions/#trim","title":"TRIM","text":"<pre><code>TRIM([[LEADING | TRAILING | BOTH] trim_character FROM] string1)\n</code></pre> <p>Semantics</p> <ul> <li><code>LEADING</code>: the function will remove trim_character from the front of string1.</li> <li><code>TRAILING</code>: the function will remove trim_character from the end of string1.</li> <li><code>BOTH</code>: the function will remove trim_character from the front and end of string1.</li> <li>trim_character: the character that will be removed from string1.<ul> <li>optional value; default is blank space.</li> <li>this argument cannot contain more than 1 character.</li> </ul> </li> <li>string1: the string to trim.</li> </ul> <p>Notes</p> <ul> <li>The TRIM Function removes all specified characters either from the beginning or the end of a string.</li> </ul> <p>Examples</p> <pre><code>SELECT TRIM(LEADING 'H' FROM 'Hello!') FROM dual;\n-- ello!\n\nSELECT TRIM(TRAILING 'o' FROM 'Hello') FROM dual;\n-- Hell\n\nSELECT TRIM('!' FROM 'Hello!') FROM dual;\n-- Hello\n</code></pre> Sources <ul> <li>Oracle Documentation - TRIM</li> </ul>"},{"location":"SQL/functions/#replace","title":"REPLACE","text":"<pre><code>REPLACE(string1, string_to_replace [, replacement_string])\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to replace a sequence of characters with another set of characters.</li> <li>string_to_replace: the string that will be searched for in string1.</li> <li>replacement_string: all occurrences of string_to_replace will be replaced with replacement_string in string1.<ul> <li>if omitted, the function removes all occurrences of string_to_replace.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The REPLACE Function replaces a sequence of characters in a string with another set of characters.</li> </ul> <p>Examples</p> <pre><code>SELECT REPLACE('123Hello123', '123') FROM dual;\n-- Hello\n\nSELECT REPLACE('123Hello123', '456') FROM dual;\n-- 456Hello456\n\nSELECT REPLACE('0123456789', '0') FROM dual;\n-- 123456789\n</code></pre> Sources <ul> <li>Oracle Documentation - REPLACE</li> </ul>"},{"location":"SQL/functions/#length","title":"LENGTH","text":"<pre><code>LENGTH(string1)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to return the length for.</li> </ul> <p>Notes</p> <ul> <li>The LENGTH Function returns the length of the specified string.</li> <li>LENGTH does not count dashes in DATE values.</li> </ul> <p>Examples</p> <pre><code>SELECT LENGTH('Hello World!') FROM dual;\n-- 12\n\nSELECT LENGTH(1234567890) FROM dual;\n-- 10\n\nSELECT LENGTH(TO_DATE('20-NOV-2022')) FROM dual;\n-- 9\n</code></pre> Sources <ul> <li>Oracle Documentation - LENGTH</li> </ul>"},{"location":"SQL/functions/#substr","title":"SUBSTR","text":"<pre><code>SUBSTR(string. start_position [, length])\n</code></pre> <p>Semantics</p> <ul> <li>string: the source string.</li> <li>start_position: the starting position for extraction. First position is always 1.</li> <li>length: number of characters to extract.    </li> </ul> <p>Notes</p> <ul> <li>The SUBSTR Function allows to extract a substring from a string.</li> <li>If string is SYSDATE, Oracle will execute an implicit data type conversion.</li> <li>If start_position is 0, SUBSTR treats start_position as 1.</li> <li>If start_position is negative, SUBSTR start from the end of the string and count backwards.</li> <li>If length is omitted, SUBSTR will return the entire string.</li> <li>If length is negative, SUBSTR returns a NULL value.</li> </ul> Sources <ul> <li>Oracle Documentation - SUBSTR</li> </ul>"},{"location":"SQL/functions/#instr","title":"INSTR","text":"<pre><code>INSTR(string, substring [, start_position [, nth_appearance]])\n</code></pre> <p>Semantics</p> <ul> <li>string: the string to search.</li> <li>substring: substring to search for in string.</li> <li>start_position: position in string where the search will start.<ul> <li>default is 1.</li> </ul> </li> <li>nth_appearance: the nth appearance of substring.<ul> <li>default is 1.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The INSTR Function returns the location of a substring in a string.</li> <li>If either string or substring is NULL, INSTR returns NULL.</li> <li>If substring is not found in string, INSTR returns 0.</li> <li>If start_position negative, the INSTR function counts backwards.</li> </ul> <p>Examples</p> <pre><code>SELECT INSTR('ciaoc', 'c', 1, 2)\nFROM dual;\n-- 5\n</code></pre> Sources <ul> <li>Oracle Documentation - INSTR</li> </ul>"},{"location":"SQL/functions/#least","title":"LEAST","text":"<pre><code>LEAST(expr1 [, expr2, ... expr_n])\n</code></pre> <p>Semantics</p> <ul> <li>expr1: the first expression to evaluate whether it is the smallest.</li> <li>expr2, expr_n: additional expressions that are to be evaluated.</li> </ul> <p>Notes</p> <ul> <li>The LEAST Function returns the smallest value in a list of expressions.</li> <li>If either expr1 or expr2 is NULL, LEAST returns NULL.</li> </ul> <p>Examples</p> <pre><code>SELECT LEAST('hello', 'HELLO', 'z') FROM dual;\n-- HELLO\n\nSELECT LEAST(NULL, 'HELLO', 'hELLO', 'zzz') FROM dual;\n-- NULL\n\nSELECT LEAST(8, 56, 99, 5, NULL) FROM dual;\n-- NULL\n</code></pre> Sources <ul> <li>Oracle Documentation - LEAST</li> </ul>"},{"location":"SQL/functions/#numeric-functions","title":"Numeric Functions","text":"<ul> <li><code>CEIL</code></li> <li><code>FLOOR</code></li> <li><code>MOD</code></li> <li><code>POWER</code></li> <li><code>REMAINDER</code></li> <li><code>ROUND</code></li> <li><code>TRUNC</code></li> </ul>"},{"location":"SQL/functions/#ceil","title":"CEIL","text":"<pre><code>CEIL(number)\n</code></pre> <p>Semantics</p> <ul> <li>number: the value used to find the smallest integer value.</li> </ul> <p>Notes</p> <ul> <li>The CEIL Function returns the smallest integer value that is greater than or equal to a number.</li> <li>If either expr1 or expr2 is NULL, LEAST returns NULL.</li> </ul> <p>Examples</p> <pre><code>SELECT CEIL(21.65) FROM dual;\n-- 21\n\nSELECT CEIL(21.21) FROM dual;\n-- 22\n\nSELECT CEIL(21) FROM dual;\n-- 21\n\nSELECT CEIL(-21.65) FROM dual;\n-- -21\n</code></pre> Sources <ul> <li>Oracle Documentation - CEIL</li> </ul>"},{"location":"SQL/functions/#floor","title":"FLOOR","text":"<pre><code>FLOOR(number)\n</code></pre> <p>Semantics</p> <ul> <li>number: the value used to determine the largest integer value that is equal to or less than a number.</li> </ul> <p>Notes</p> <ul> <li>The FLOOR Function returns the largest integer value that is equal to or less than a number.</li> </ul> <p>Examples</p> <pre><code>SELECT FLOOR(21.65) FROM dual;\n-- 21\n\nSELECT FLOOR(21.21) FROM dual;\n-- 21\n\nSELECT FLOOR(21) FROM dual;\n-- 21\n\nSELECT FLOOR(-21.65) FROM dual;\n-- -22\n</code></pre> Sources <ul> <li>Oracle Documentation - FLOOR</li> </ul>"},{"location":"SQL/functions/#mod","title":"MOD","text":"<pre><code>MOD(m, n)\n</code></pre> <p>Semantics</p> <ul> <li>m: the numeric value used in the calculation.</li> <li>n: the numeric value used in the calculation.</li> </ul> <p>Notes</p> <ul> <li>The MOD Function returns the remainder of m divided by n.</li> <li>The difference with the REMAINDER function is that REMAINDER uses ROUND in its calculation, and MOD uses the FLOOR function.</li> <li>MOD returns m if n is 0.</li> </ul> <p>Examples</p> <pre><code>SELECT MOD(15, 4) FROM dual;\n-- 3\n\nSELECT MOD(15, 0) FROM dual;\n-- 0\n\nSELECT MOD(11.6, 2) FROM dual;\n-- 1.6\n</code></pre> Sources <ul> <li>Oracle Documentation - MOD</li> </ul>"},{"location":"SQL/functions/#power","title":"POWER","text":"<pre><code>POWER(m, n)\n</code></pre> <p>Semantics</p> <ul> <li>m: the base used in the calculation.<ul> <li>if m s negative, then n must be an integer.</li> </ul> </li> <li>n: the exponent used in the calculation.</li> </ul> <p>Notes</p> <ul> <li>The POWER Function returns m raised to the nth power.</li> </ul> <p>Examples</p> <pre><code>SELECT POWER(3, 2) FROM dual;\n-- 9\n\nSELECT POWER(5, 3) FROM dual;\n-- 125\n\nSELECT POWER(-5, 3) FROM dual;\n-- -125\n</code></pre> Sources <ul> <li>Oracle Documentation - POWER</li> </ul>"},{"location":"SQL/functions/#remainder","title":"REMAINDER","text":"<pre><code>REMAINDER(m, n)\n</code></pre> <p>Semantics</p> <ul> <li>m: a numeric value used in the calculation.</li> <li>n: a numeric value used in the calculation.</li> </ul> <p>Notes</p> <ul> <li>The REMAINDER Function returns the remainder of m divided by n.</li> <li>The difference with the MOD function is that REMAINDER uses ROUND in its calculation, and MOD uses the FLOOR function.</li> <li>The REMAINDER is calculated as follows: <code>m - (n * X)</code>  where X is the integer nearest n / n.</li> </ul> <p>Examples</p> <pre><code>SELECT REMAINDER(15, 6) FROM dual;\n-- 3\n\nSELECT REMAINDER(15, 5) FROM dual;\n-- 0\n\nSELECT REMAINDER(15, 4) FROM dual;\n-- -1\n</code></pre> Sources <ul> <li>Oracle Documentation - REMAINDER</li> </ul>"},{"location":"SQL/functions/#round-number","title":"ROUND (number)","text":"<pre><code>ROUND(number [, decimal_places])\n</code></pre> <p>Semantics</p> <ul> <li>number: the number to round.</li> <li>decimal_places: the number of decimal places rounded to.<ul> <li>if omitted, the ROUND function will round the number to 0 decimal places.</li> <li>ff negative, rounds a number one digit to the left of the decimal point.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The ROUND Function returns a number rounded to a certain number of decimal places.</li> </ul> <p>Examples</p> <pre><code>SELECT ROUND(152.3435, -1)\nFROM dual;\n-- 150\n</code></pre> Sources <ul> <li>Oracle Documentation - ROUND (number)</li> </ul>"},{"location":"SQL/functions/#trunc-number","title":"TRUNC (number)","text":"<pre><code>TRUNC(number [, decimal_places])\n</code></pre> <p>Semantics</p> <ul> <li>number: the number to truncate.</li> <li>decimal_places: the number of decimal places to truncate to.<ul> <li>if omitted, the TRUNC function will truncate the number to 0 decimal places.</li> <li>if negative, replaces digits to the left of the decimal point with 0.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The TRUNC Function returns a number truncated to a certain number of decimal places.</li> </ul> <p>Examples</p> <pre><code>SELECT TRUNC(152.3435, -1)\nFROM dual;\n-- 150\n</code></pre> Sources <ul> <li>Oracle Documentation - TRUNC (number)</li> </ul>"},{"location":"SQL/functions/#date-functions","title":"Date Functions","text":"<ul> <li><code>ADD_MONTHS</code></li> <li><code>CURRENT_DATE</code></li> <li><code>CURRENT_TIMESTAMP</code></li> <li><code>DBTIMEZONE</code></li> <li><code>LAST_DAY</code></li> <li><code>LOCALTIMESTAMP</code></li> <li><code>MONTHS_BETWEEN</code></li> <li><code>NEXT_DAY</code></li> <li><code>ROUND</code></li> <li><code>SESSIONTIMEZONE</code></li> <li><code>SYSDATE</code></li> <li><code>SYSTIMESTAMP</code></li> <li><code>TRUNC</code></li> </ul>"},{"location":"SQL/functions/#add_months","title":"ADD_MONTHS","text":"<pre><code>ADD_MONTHS(date1, number_months)\n</code></pre> <p>Semantics</p> <ul> <li>date1: the starting date (before the n months have been added).</li> <li>number_months: number of months to add to date1.</li> </ul> <p>Notes</p> <ul> <li>The ADD_MONTHS Function returns a date with a specified number of months added.</li> </ul> Sources <ul> <li>Oracle Documentation - ADD_MONTHS</li> </ul>"},{"location":"SQL/functions/#current_date","title":"CURRENT_DATE","text":"<pre><code>SELECT CURRENT_DATE\nFROM DUAL;\n-- 06-DEC-2022\n</code></pre> <p>Notes</p> <ul> <li>CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.</li> </ul> Sources <ul> <li>Oracle Documentation - CURRENT_DATE</li> </ul>"},{"location":"SQL/functions/#current_timestamp","title":"CURRENT_TIMESTAMP","text":"<pre><code>SELECT CURRENT_TIMESTAMP\nFROM DUAL;\n-- 06-DEC-22 03.20.35.553971000 PM EUROPE/BERLIN\n</code></pre> <p>Notes</p> <ul> <li>CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session.</li> </ul> Sources <ul> <li>Oracle Documentation - CURRENT_TIMESTAMP</li> </ul>"},{"location":"SQL/functions/#dbtimezone","title":"DBTIMEZONE","text":"<pre><code>SELECT DBTIMEZONE\nFROM DUAL;\n-- +00:00\n</code></pre> <p>Notes</p> <ul> <li>DBTIMEZONE returns the value of the database time zone.</li> </ul> Sources <ul> <li>Oracle Documentation - DBTIMEZONE</li> </ul>"},{"location":"SQL/functions/#last_day","title":"LAST_DAY","text":"<pre><code>LAST_DAY(date)\n</code></pre> <p>Semantics</p> <ul> <li>date: the date value to use to calculate the last day of the month</li> </ul> <p>Notes</p> <ul> <li>The LAST_DAY Function returns the last day of the month based on a date value.</li> </ul> <p>Examples</p> <pre><code>SELECT LAST_DAY(TO_DATE('01-DEC-2022')) FROM dual;\n-- 31-DEC-2022\n\nSELECT LAST_DAY(TO_DATE('31-DEC-2022')) FROM dual;\n-- 31-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - LAST_DAY</li> </ul>"},{"location":"SQL/functions/#localtimestamp","title":"LOCALTIMESTAMP","text":"<pre><code>SELECT LOCALTIMESTAMP\nFROM DUAL;\n-- 06-DEC-22 03.20.04.446137000 PM\n</code></pre> <p>Notes</p> <ul> <li>LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP.</li> </ul> Sources <ul> <li>Oracle Documentation - LOCALTIMESTAMP</li> </ul>"},{"location":"SQL/functions/#current_date-vs-current_timestamp-vs-localtimestamp","title":"CURRENT_DATE vs. CURRENT_TIMESTAMP vs. LOCALTIMESTAMP","text":""},{"location":"SQL/functions/#months_between","title":"MONTHS_BETWEEN","text":"<pre><code>MONTHS_BETWEEN(date1, date2)\n</code></pre> <p>Semantics</p> <ul> <li>date1: the first date used to calculate the number of months between.</li> <li>date2: the second date used to calculate the number of months between.</li> </ul> <p>Notes</p> <ul> <li>The MONTHS_BETWEEN Function returns the number of months between date1 and date2.</li> </ul> <p>Examples</p> <pre><code>SELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('01-JAN-2023')) FROM dual;\n-- -1\n\nSELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('01-NOV-2022')) FROM dual;\n-- 1\n\nSELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('31-DEC-2022')) FROM dual;\n-- 0.96\n</code></pre> Sources <ul> <li>Oracle Documentation - MONTHS_BETWEEN</li> </ul>"},{"location":"SQL/functions/#next_day","title":"NEXT_DAY","text":"<pre><code>NEXT_DAY(date, weekday)\n</code></pre> <p>Semantics</p> <ul> <li>date: a date value used to find the next weekday.</li> <li>weekday: the day of the week that you wish to return.<ul> <li>must be one of the following:<ul> <li>SUNDAY or SUN</li> <li>MONDAY or MON</li> <li>TUESDAY or TUE</li> <li>WEDNESDAY or WED</li> <li>THURSDAY or THU</li> <li>FRIDAY or FRI</li> <li>SATURDAY or SAT</li> </ul> </li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The NEXT_DAY Function returns the first weekday that is greater than a date.</li> </ul> <p>Examples</p> <pre><code>-- considering 6 December 2022 was a Tuesday:\nSELECT NEXT_DAY(TO_DATE('06-DEC-2022'), 'Sunday') FROM dual;\n-- 11-DEC-2022\n\nSELECT NEXT_DAY(TO_DATE('06-DEC-2022'), 'Tuesday') FROM dual;\n-- 13-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - NEXT_DAY</li> </ul>"},{"location":"SQL/functions/#round-date","title":"ROUND (date)","text":"<pre><code>ROUND(date [, format])\n</code></pre> <p>Semantics</p> <ul> <li>date: the date to round.</li> <li>format: the unit of measure to apply for rounding.<ul> <li>if omitted, the function will round to the nearest day</li> <li>must be one of the following values: (complete list)</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The ROUND Function returns a date rounded to a specific unit of measure.</li> </ul> <p>Examples</p> <pre><code>SELECT ROUND(TO_DATE('01-NOV-2022'), 'YEAR') FROM dual;\n-- 01-JAN-2023\n\nSELECT ROUND(TO_DATE('16-NOV-2022'), 'MONTH') FROM dual;\n-- 01-DEC-2022\n\nSELECT ROUND(TO_DATE('16-NOV-2022')) FROM dual;\n-- 16-NOV-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - ROUND (date)</li> </ul>"},{"location":"SQL/functions/#sessiontimezone","title":"SESSIONTIMEZONE","text":"<pre><code>SELECT SESSIONTIMEZONE\nFROM DUAL;\n-- Europe/Berlin\n</code></pre> <p>Notes</p> <ul> <li>SESSIONTIMEZONE returns the time zone of the current session.</li> </ul> Sources <ul> <li>Oracle Documentation - SESSIONTIMEZONE</li> </ul>"},{"location":"SQL/functions/#sysdate","title":"SYSDATE","text":"<pre><code>SELECT SYSDATE\nFROM DUAL;\n-- 06-DEC-2022\n</code></pre> <p>Notes</p> <ul> <li>SYSDATE returns the current date and time set for the operating system on which the database server resides.</li> <li>The data type of the returned value is DATE, and the format returned depends on the value of the NLS_DATE_FORMAT initialization parameter.</li> </ul> Sources <ul> <li>Oracle Documentation - SYSDATE</li> </ul>"},{"location":"SQL/functions/#systimestamp","title":"SYSTIMESTAMP","text":"<pre><code>SELECT SYSTIMESTAMP\nFROM DUAL;\n-- 06-DEC-2022 03.41.91.693169000 PM +01:00\n</code></pre> <p>Notes</p> <ul> <li>SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides.</li> <li>The return type is TIMESTAMP WITH TIME ZONE.</li> </ul> Sources <ul> <li>Oracle Documentation - SYSTIMESTAMP</li> </ul>"},{"location":"SQL/functions/#interval","title":"INTERVAL","text":"<p>The INTERVAL datatype allows you to store periods of time.</p> <p>There are two types of INTERVAL:</p> <ul> <li><code>INTERVAL YEAR TO MONTH</code>: stores intervals using year and month;</li> <li><code>INTERVAL DAY TO SECOND</code>: stores intervals using days, hours, and seconds including fractional seconds.</li> </ul> Sources <ul> <li>Oracle Documentation - Interval Expressions</li> <li>Oracle Documentation - Interval Literals</li> </ul>"},{"location":"SQL/functions/#interval-year-to-month","title":"INTERVAL YEAR TO MONTH","text":"<pre><code>INTERVAL YEAR [(year_precision)] TO MONTH\n</code></pre> <p>Semantics</p> <ul> <li>year_precision: number of digits in the YEAR field (ranges from 0 to 9).</li> </ul> <p>Notes</p> <ul> <li>The INTERVAL YEAR TO MONTH data type allows you to store a period of time using the YEAR and MONTH fields.</li> </ul> Sources <ul> <li>Oracle Documentation - INTERVAL YEAR TO MONTH</li> </ul>"},{"location":"SQL/functions/#interval-year-to-month-literals","title":"INTERVAL YEAR TO MONTH - Literals","text":"<pre><code>INTERVAL 'year[-month]' leading(precision) TO trailing\n</code></pre> <p>Semantics</p> <ul> <li>leading and trailing can only be YEAR or MONTH.</li> <li>If leading is YEAR and trailing is MONTH, then the MONTH field ranges from 0 to 11.</li> <li>The trailing field must be less than the leading field.</li> <li>precision represents the number of digits in the leading field. (ranges from 0 to 9; default is 2).</li> </ul> <p>Examples</p> <pre><code>SELECT INTERVAL '120-3' YEAR(3) TO MONTH FROM dual;\n-- +120-03 (120 years and 3 months)\n\nSELECT INTERVAL '105' YEAR(3) FROM dual;\n-- +105-00 (105 years)\n\nSELECT INTERVAL '9' YEAR FROM dual;\n-- +09-00 (9 years)\n\nSELECT INTERVAL '180' YEAR FROM dual;\n-- ORA-01873: the leading precision of the interval is too small\n</code></pre> Sources <ul> <li>Oracle Documentation - INTERVAL YEAR TO MONTH</li> </ul>"},{"location":"SQL/functions/#interval-day-to-second","title":"INTERVAL DAY TO SECOND","text":"<pre><code>INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]\n</code></pre> <p>Semantics</p> <ul> <li>day_precision: number of digits in the DAY field (ranges from 0 to 9).</li> <li>fractional_seconds_precision: number of digits in the fractional part of the SECOND field (ranges from 0 to 9).</li> </ul> <p>Notes</p> <ul> <li>The INTERVAL DAY TO SECOND stores a period of time in terms of days, hours, minutes, and seconds.</li> </ul> Sources <ul> <li>Oracle Documentation - INTERVAL DAY TO SECOND</li> </ul>"},{"location":"SQL/functions/#interval-day-to-second-literals","title":"INTERVAL DAY TO SECOND - Literals","text":"<pre><code>INTERVAL leading(leading_precision) TO trailing(fractional_seconds_precision)\n</code></pre> <p>Examples</p> <pre><code>SELECT INTERVAL '11 10:09:08.555' DAY TO SECOND(3) FROM dual;\n-- +11 10:09:08.555 (11 days, 10 hours, 9 minutes, 8 seconds and 555 thousandths of a second)\n\nSELECT INTERVAL '11 10:09' DAY TO MINUTE FROM dual;\n-- +11 10:09:00 (11 days, 10 hours and 9 minutes)\n\nSELECT INTERVAL '100 10' DAY(3) TO HOUR FROM dual;\n-- +100 10:00:00 (100 days and 10 hours)\n\nSELECT INTERVAL '8' HOUR YEAR FROM dual;\n-- +00 08:00:00 (8 hours)\n\nSELECT INTERVAL '09:30' HOUR TO MINUTE FROM dual;\n-- +00 09:30:00 (9 hours and 30 minutes)\n</code></pre> Sources <ul> <li>Oracle Documentation - INTERVAL DAY TO SECOND</li> </ul>"},{"location":"SQL/functions/#trunc-date","title":"TRUNC (date)","text":"<pre><code>TRUNC(date [, format])\n</code></pre> <p>Semantics</p> <ul> <li>date: the date to truncate.</li> <li>format: the unit of measure to apply for truncating.<ul> <li>if omitted, the function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off</li> <li>Must be one of the following values: (complete list)</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The TRUNC Function returns a date truncated to a specific unit of measure.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - TRUNC (date)</li> </ul> Sources <ul> <li>Oracle Documentation - TRUNC (date)</li> </ul>"},{"location":"SQL/functions/#null-related-functions","title":"NULL-Related Functions","text":"<ul> <li><code>NVL</code></li> <li><code>DECODE</code></li> <li><code>NVL2</code></li> <li><code>COALESCE</code></li> <li><code>NULLIF</code></li> </ul>"},{"location":"SQL/functions/#nvl","title":"NVL","text":"<pre><code>NVL(string1, replace_with)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to test for a NULL value.</li> <li>replace_with: the value returned if string1 is NULL.<ul> <li>dataype must be the same as string1</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The NVL Function lets you substitute a value when a NULL value is encountered.</li> </ul> <p>Examples</p> <pre><code>SELECT NVL(NULL, 'Hello') FROM dual;\n-- Hello\n\nSELECT NVL('Hello', 'Hello2') FROM dual;\n-- Hello\n</code></pre> Sources <ul> <li>Oracle Documentation - NVL</li> </ul>"},{"location":"SQL/functions/#decode","title":"DECODE","text":"<pre><code>DECODE(expression, search, result, [, search, result]... [, default])\n</code></pre> <p>Semantics</p> <ul> <li>expression: the value to compare.</li> <li>search: the value that is compared against expression.</li> <li>result: the value returned, if expression is equal to search.</li> <li>default: if no matches are found, the DECODE function will return default.    </li> </ul> <p>Notes</p> <ul> <li>The DECODE Function has the functionality of an IF-THEN-ELSE statement.</li> <li>The function returns a value that is the same data type as the first result in the list.</li> <li>If the first result is NULL, then the return vlue is converted to VARCHAR2.</li> <li>If the first result has a data type of CHAR, then the return value is converted to VARCHAR2.</li> </ul> <p>Examples</p> <pre><code>SELECT supplier_name,\nDECODE(supplier_id, 10000, 'IBM',\n                    10001, 'Microsoft',\n                    10002, 'Hewlett Packard',\n                    'Gateway') result\nFROM suppliers;\n\n-- the above code would be equivalent to:\nIF supplier_id = 10000 THEN\n   result := 'IBM';\n\nELSIF supplier_id = 10001 THEN\n   result := 'Microsoft';\n\nELSIF supplier_id = 10002 THEN\n   result := 'Hewlett Packard';\n\nELSE\n   result := 'Gateway';\nEND IF;\n</code></pre> Sources <ul> <li>Oracle Documentation - DECODE</li> </ul>"},{"location":"SQL/functions/#case","title":"CASE","text":"<pre><code>CASE [expression]\n    WHEN condition_1 THEN result_1\n    WHEN condition_2 THEN result_2\n    ...\n    WHEN condition_n THEN result_n\n    [ELSE result]\nEND\n</code></pre> <p>Semantics</p> <ul> <li>expression: the value that you are comparing to the list of conditions.</li> <li>condition_1, condition_2, \u2026 condition_n: the conditions that must all be the same datatype. Conditions are evaluated in the order listed.</li> <li>result_1, result_2, ... result_n: results that must all be the same datatype. This is the value returned once a condition is found to be true.    </li> </ul> <p>Notes</p> <ul> <li>The CASE Statement has the functionality of an IF-THEN-ELSE statement.</li> <li>The CASE Statement returns any datatype such as a String, Numeric, Date, etc.</li> <li>All conditions must be the same datatype.</li> <li>All results must be the same datatype.</li> <li>If ELSE is omitted, the CASE Statement will return NULL if no condition is found to be true.</li> <li>You can have up to 255 comparisons in a CASE Statement (each WHEN ... THEN clause is considered 2 comparisons).</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - CASE</li> </ul> Sources <ul> <li>Oracle Documentation - CASE Statement</li> </ul>"},{"location":"SQL/functions/#nvl2","title":"NVL2","text":"<pre><code>NVL2(string1, value_if_not_null, value_if_null)\n</code></pre> <p>Semantics</p> <ul> <li>string1: the string to test for a NULL value.</li> <li>value_if_not_null: the value returned if string1 is not NULL.</li> <li>value_if_null: the value returned if string1 is NULL.  </li> </ul> <p>Notes</p> <ul> <li>The NVL2 Function lets you substitutes a value when a NULL value is encountered as well as when a non-NULL value is encountered.</li> </ul> <p>Examples</p> <p><pre><code>SELECT NVL2(NULL, 'Hello', 'Hello2') FROM dual;\n-- Hello2\n\nSELECT NVL2('Hello!', 'Hello', 'Hello2') FROM dual;\n-- Hello\n</code></pre> - Oracle Live SQL - NVL2</p> Sources <ul> <li>Oracle Documentation - NVL2</li> </ul>"},{"location":"SQL/functions/#coalesce","title":"COALESCE","text":"<pre><code>COALESCE(expression1, expression2, ... expression_n)\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: the expressions to test for non-NULL values.<ul> <li>the expressions must all be the same datatype</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The COALESCE Function returns the first non-null expression in the list.</li> <li>If all expressions evaluate to NULL, then the COALESCE function will return NULL.</li> </ul> <p>Examples</p> <pre><code>SELECT COALESCE( address1, address2, address3 ) result\nFROM suppliers;\n\n-- the above code would be equivalent to:\nIF address1 is not null THEN\n   result := address1;\nELSIF address2 is not null THEN\n   result := address2;\nELSIF address3 is not null THEN\n   result := address3;\nELSE\n   result := null;\nEND IF;\n</code></pre> Sources <ul> <li>Oracle Documentation - COALESCE</li> </ul>"},{"location":"SQL/functions/#nullif","title":"NULLIF","text":"<pre><code>NULLIF(expr1, expr2)\n</code></pre> <p>Semantics</p> <ul> <li>expr1: first value to compare.<ul> <li>cannot be a literal NULL.</li> </ul> </li> <li>expr2: second value to compare.</li> </ul> <p>Notes</p> <ul> <li>The NULLIF Function compares expr1 and expr2.  </li> <li>If expr1 and expr2 are equal, the NULLIF function returns NULL. Otherwise, it returns expr1.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - NULLIF</li> </ul> Sources <ul> <li>Oracle Documentation - NULLIF</li> </ul>"},{"location":"SQL/functions/#coalesce-vs-nvl","title":"COALESCE vs NVL","text":"<ul> <li>NVL accepts only 2 arguments whereas COALESCE can take multiple arguments.</li> <li>NVL evaluates both the arguments and COALESCE stops at first occurrence of a non-Null value (only exception is a Sequence.NEXTVAL).</li> </ul> <p>Examples</p> <p><pre><code>SELECT SUM(val)\nFROM\n    (SELECT NVL(1, LENGTH(RAWTOHEX(SYS_GUID()))) AS val\n    FROM dual\n    CONNECT BY LEVEL &lt;= 1000000);\n-- this query runs approximately in 0.6 seconds\n\nSELECT SUM(val)\nFROM\n    (SELECT COALESCE(1, LENGTH(RAWTOHEX(SYS_GUID()))) AS val\n    FROM dual\n    CONNECT BY LEVEL &lt;= 1000000);\n-- this query runs approximately in 0.2 seconds\n</code></pre> - NVL does an implicit conversion to the datatype of the first parameter, while COALESCE expect all parameters to have the same datatype.</p> <pre><code>SELECT NVL('a', sysdate)\nFROM dual;\n-- returns 'a'\n\nSELECT COALESCE('a', sysdate)\nFROM dual;\n-- returns ORA-00932: inconsistent datatypes: expected CHAR got DATE\n\nSELECT NVL('test', 500)\nFROM dual;\n-- returns 'test'\n\nSELECT COALESCE('test', 500)\nFROM dual;\n-- returns ORA-00932: inconsistent datatypes: expected CHAR got NUMBER\n</code></pre> Sources <ul> <li>Oracle Documentation - COALESCE</li> <li>Oracle Documentation - NVL</li> </ul>"},{"location":"SQL/functions/#aggregate-functions","title":"Aggregate Functions","text":"<ul> <li><code>COUNT</code></li> <li><code>AVG</code></li> <li><code>SUM</code></li> <li><code>MAX</code></li> <li><code>MIN</code></li> <li><code>LISTAGG</code></li> <li><code>STDDEV</code></li> <li><code>VARIANCE</code></li> </ul> <p>Notes</p> <ul> <li>Aggregate Functions can appear in select lists and in ORDER BY and HAVING clauses.</li> <li>You use Aggregate Functions in the HAVING clause to eliminate groups from the output based on the results of the Aggregate Functions.</li> <li>All Aggregate Functions except COUNT(*) ignore NULLs.</li> <li>COUNT never returns NULL, but returns either a number or zero.</li> </ul> <p>Examples</p> <ul> <li>DISTINCT average of: 1, 1, 1, and 3 \u2192 2 ([1+3]/2)</li> <li>ALL average of: 1, 1, 1, and 3 \u2192 1.5 ([1+1+1+3]/4)</li> </ul> Sources <ul> <li>Oracle Documentation - Aggregate Functions</li> </ul>"},{"location":"SQL/functions/#count","title":"COUNT","text":"<pre><code>SELECT COUNT([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n\n-- syntax with more than one column\nSELECT expression1, expression2, ... expression_n,\nCOUNT([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the COUNT function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression whose non-NULL values will be counted.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The COUNT Function returns the count of an expression.</li> <li>The COUNT function always returns a numeric value.</li> </ul> Sources <ul> <li>Oracle Documentation - COUNT</li> </ul>"},{"location":"SQL/functions/#avg","title":"AVG","text":"<pre><code>SELECT AVG([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n\n-- syntax with more than one column\nSELECT expression1, expression2, ... expression_n,\nAVG([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the AVG function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression that will be averaged.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The AVG Function returns the average value of an expression.</li> <li>The AVG function returns a numeric value.</li> <li>If aggregate_expression is a String, returns <code>ORA-01722: invalid number</code></li> <li>If aggregate_expression is a Date, returns <code>ORA-00932: inconsistent datatypes: expected NUMBER got DATE</code></li> </ul> Sources <ul> <li>Oracle Documentation - AVG</li> </ul>"},{"location":"SQL/functions/#max","title":"MAX","text":"<pre><code>SELECT MAX([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n\n-- syntax with more than one column\nSELECT expression1, expression2, ... expression_n,\nMAX([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MAX function must be included in the GROUP BY clause. </li> <li>aggregate_expression: the column or expression from which the maximum value will be returned.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The MAX Function returns the maximum value of an expression.</li> <li>The MAX function returns either a string/numeric/date value.</li> </ul> Sources <ul> <li>Oracle Documentation - MAX</li> </ul>"},{"location":"SQL/functions/#min","title":"MIN","text":"<pre><code>SELECT MIN([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n\n-- syntax with more than one column\nSELECT expression1, expression2, ... expression_n, \nMIN([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MAX function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression from which the minimum value will be returned.<ul> <li>NULL values are ignored </li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The MIN Function returns the minimum value of an expression.</li> <li>The MIN function returns either a string/numeric/date value.</li> </ul> Sources <ul> <li>Oracle Documentation - MIN</li> </ul>"},{"location":"SQL/functions/#listagg","title":"LISTAGG","text":"<pre><code>LISTAGG(measure_column [, 'delimeter'])\n    WITHIN GROUP (order_by_clause)\n</code></pre> <p>Semantics</p> <ul> <li>measure_column: the column or expression whose values you wish to concatenate together in the result set.</li> <li>delimeter: the delimeter to use when separating the measure_column.</li> <li>order_by_clause: determines the order that the concatenated values are returned.</li> </ul> <p>Notes</p> <ul> <li>The LISTAGG Function concatenates values of the measure_column for each GROUP based on the order_by_clause.</li> <li>NULL values in the measure_column are ignored</li> <li>delimeter's default value is blank space</li> </ul> <p>Examples</p> <p></p> <pre><code>SELECT LISTAGG(product_name, ', ')\n    WITHIN GROUP (ORDER BY product_name) \"Product_Listing\"\nFROM products;\n-- Apples, Bananas, Oranges, Pears\n</code></pre> Sources <ul> <li>Oracle Documentation - LISTAGG</li> </ul>"},{"location":"SQL/functions/#sum","title":"SUM","text":"<pre><code>SELECT SUM([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n\n-- syntax with more than one column\nSELECT expression1, expression2, ... expression_n, \nSUM([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre> <p>Semantics</p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MIN function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression that will be summed.</li> </ul> <p>Notes</p> <ul> <li>The SUM Function returns the summed value of an expression.</li> <li>The SUM function returns a numeric value.</li> <li>NULL values in the aggregate_expression are ignored.</li> <li>If aggregate_expression is a String, returns <code>ORA-01722: invalid number</code></li> <li>If aggregate_expression is a Date, returns <code>ORA-00932: inconsistent datatypes: expected NUMBER got DATE</code></li> </ul> Sources <ul> <li>Oracle Documentation - SUM</li> </ul>"},{"location":"SQL/functions/#conversion-functions","title":"Conversion Functions","text":"<ul> <li><code>TO_NUMBER</code></li> <li><code>TO_CHAR</code></li> <li><code>TO_DATE</code></li> </ul>"},{"location":"SQL/functions/#to_number","title":"TO_NUMBER","text":"<pre><code>TO_NUMBER(string, [,format_mask])\n</code></pre> <p>Notes</p> <ul> <li>The TO_NUMBER (Conversion) Function converts expr to a value of NUMBER data type.</li> </ul> Sources <ul> <li>Oracle Documentation - TO_NUMBER</li> </ul>"},{"location":"SQL/functions/#to_date","title":"TO_DATE","text":"<pre><code>TO_DATE(string, [,format_mask])\n</code></pre> <p>Semantics</p> <ul> <li>string: the string that will be converted to a date.</li> <li>format_mask: the format that will be used to convert string to a date.<ul> <li>must be one or a combination of the following values.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The TO_DATE (Conversion) Function converts a string to a date.</li> </ul> Sources <ul> <li>Oracle Documentation - TO_DATE</li> </ul>"},{"location":"SQL/hints/","title":"Hints","text":"<pre><code>DML_keyword /*+ hint_1 [hint_n] */\nDML_statement\n</code></pre> <p>Semantics</p> <ul> <li>DML_keyword: must be one of the following: SELECT, UPDATE, INSERT, MERGE, DELETE.</li> <li>hint_1, [hint_n]: name of the hint being used. Multiple Hints can be used in one statement.</li> </ul> Sources <ul> <li>Oracle Documentation - Hints</li> </ul>"},{"location":"SQL/hints/#parallel-hint","title":"PARALLEL Hint","text":"<pre><code>DML_keyword /*+ PARALLEL[(degree | DEFAULT | MANUAL)]\nDML_statement\n</code></pre> <p>Semantics</p> <ul> <li>DML_keyword: must be one of the following: SELECT, UPDATE, INSERT, MERGE, DELETE</li> <li>degree: degree of parallelism used for the statement.</li> <li><code>DEFAULT</code>: the optimizer calculates a degree of parallelism equal to the number of CPUs availables times the value of the <code>PARALLEL_THREADS_PER_CPU</code> parameter.</li> <li><code>MANUAL</code>: the optimize uses the degree of parallelism specified in the Object.</li> </ul> <p>Notes</p> <ul> <li>The PARALLEL hint instructs the optimizer to use the specified number of concurrent servers for a parallel operation.</li> <li>Query to get the number of CPUs availables and the <code>PARALLEL_THREADS_PER_CPU</code> parameter's value: <pre><code>SELECT name, value\nFROM v$parameter\nWHERE UPPER(name) IN ('CPU_COUNT','PARALLEL_THREADS_PER_CPU')\n</code></pre></li> </ul> Sources <ul> <li>Oracle Documentation - PARALLEL Hint</li> </ul>"},{"location":"SQL/hints/#append-hint","title":"APPEND Hint","text":"<pre><code>INSERT /*+ APPEND */\nINTO table_name\nsubquery;\n</code></pre> <p>Notes</p> <ul> <li>The APPEND hint instructs the optimizer to use direct-path INSERT with the subquery syntax of the INSERT statement.</li> </ul> Sources <ul> <li>Oracle Documentation - APPEND Hint</li> </ul>"},{"location":"SQL/indexes/","title":"Indexes","text":""},{"location":"SQL/indexes/#create-index","title":"CREATE INDEX","text":"<pre><code>CREATE [UNIQUE] INDEX [schema.]index_name\n    ON table_name (column_1, column_2, ... column_n)\n    [COMPUTE STATISTICS];\n</code></pre> <p>Semantics</p> <ul> <li><code>UNIQUE</code>: indicates that the combination of values in the indexed columns must be unique.</li> <li><code>COMPUTE STATISTICS</code>: tells Oracle to collect stats during the creation of the index. They are then used by the optimizer to choose a \"plan of execution\" when SQL Statements are executed.</li> </ul> <p>Notes</p> <ul> <li>Indexes are optional structures associated with Tables that allow SQL queries to execute more quickly against a Table.</li> <li>Indexes are logically and physically independent of the data in the associated Table. Being independent structures, they require storage space.</li> <li>You can create or drop an Index without affecting the base tables, database applications, or other indexes.</li> <li>If you drop an Index, all applications continue to work. However, access to previously indexed data might be slower.</li> <li>To create an Index in your own schema, you must have the <code>CREATE ANY INDEX</code> system privilege.</li> <li>LONG columns cannot be indexed.</li> <li>By default, Oracle creates B-Tree Indexes.</li> </ul> Sources <ul> <li>Oracle Documentation - CREATE INDEX</li> </ul>"},{"location":"SQL/indexes/#alter-index","title":"ALTER INDEX","text":"<pre><code>ALTER INDEX index_name\n    {RENAME TO new_index_name |\n    [ENABLE | DISABLE] |\n    [VISIBLE | INVISIBLE] |\n    [PARALLEL integer | NOPARALLEL] |\n    [REBUILD [PARALLEL integer]]}\n;\n</code></pre> <p>Semantics</p> <ul> <li><code>RENAME TO new_index_name</code>: renames the Index.</li> <li><code>ENABLE | DISABLE</code>: enables/disables an Index.</li> <li><code>VISIBLE | INVISIBILE</code>: specify whether the Index is visible or invisible to the optimizer.</li> <li><code>PARALLEL integer</code>: change the default degree of parallelism for queries and DML on the Index.</li> <li><code>REBUILD</code>: re-create an existing index or one of its partitions or subpartitions.</li> <li><code>REBUILD PARALLEL integer</code>: parallelize the rebuilding of the index and to change the degree of parallelism for the Index itself.</li> </ul> Sources <ul> <li>Oracle Documentation - ALTER INDEX</li> </ul>"},{"location":"SQL/indexes/#drop-index","title":"DROP INDEX","text":"<pre><code>DROP INDEX index_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - DROP INDEX</li> </ul>"},{"location":"SQL/joins/","title":"Joins","text":""},{"location":"SQL/joins/#cartesian-join","title":"Cartesian Join","text":"<pre><code>SELECT select_list\nFROM table_a, table_b;\n\nSELECT select_list\nFROM table_a CROSS JOIN table_b;\n-- both queries would return the same result.\n</code></pre> <p>Notes</p> <ul> <li>It is also known as Cartesian Product or Cross Join.</li> <li>Replicates each row from the first table with every row from the second table. Creates a Join between tables by displaying every possible record combination.</li> </ul> <p>Examples</p> <pre><code>SELECT *\nFROM oe.orders, oe.customers;\n</code></pre> Sources <ul> <li>Oracle Documentation - Cartesian Product</li> </ul>"},{"location":"SQL/joins/#inner-join","title":"Inner Join","text":"<pre><code>SELECT column_list\nFROM table_a t1 [INNER] JOIN table_b t2\n    USING (column_1 [, column_n]);\n\nSELECT column_list\nFROM table_a t1 [INNER] JOIN table_b t2\n    ON (t1.column_1 = t2.column_1);\n\nSELECT select_list\nFROM table_a t1, table_b t2\nWHERE t1.column_1 = t2.column_1;\n</code></pre> <p>Notes</p> <ul> <li>It is also known as Equijoin, Equality Join or Simple Join.</li> <li>Creates a join by using a commonly named and defined column.  </li> <li>The USING clause specifies which columns to test for equality when two tables are joined.</li> </ul> <p>Examples</p> <pre><code>SELECT *\nFROM oe.orders o JOIN oe.order_items oi\nON o.order_id = oi.order_id;\n</code></pre> Sources <ul> <li>Oracle Documentation - Equijoins</li> </ul>"},{"location":"SQL/joins/#non-equality-join","title":"Non-equality Join","text":"<p>Joins tables when there are no equivalent rows in the tables to be joined; For example, to match values in one column of a table with a range of values in another table. Can be created by two methods:</p> <ul> <li>Using the WHERE clause</li> <li>Using the JOIN method with the <code>JOIN \u2026 ON</code> keywords</li> </ul>"},{"location":"SQL/joins/#self-join","title":"Self-Join","text":"<pre><code>SELECT column_list\nFROM table_a t1 [INNER] JOIN table_a t2\n    USING (column_1 [, column_n]);\n\nSELECT column_list\nFROM table_a t1 [INNER] JOIN table_a t2\n    ON (t1.column_1 = t2.column_1);\n\nSELECT select_list\nFROM table_a t1, table_a t2\nWHERE t1.column_1 = t2.column_1;\n</code></pre> <p>Notes</p> <ul> <li>Joins a table to itself.</li> <li>To correctly perform a Self-Join, both Tables must have an alias defined in the query.</li> </ul> Sources <ul> <li>Oracle Documentation - Self Joins</li> </ul>"},{"location":"SQL/joins/#outer-join","title":"Outer Join","text":"<pre><code>-- LEFT OUTER JOIN: new syntax\nSELECT column_list\nFROM table_a t1 LEFT [OUTER] JOIN table_B t2\n    ON (t1.column_1 = t2.column_1);\n\n-- LEFT OUTER JOIN: old syntax\nSELECT column_list\nFROM table_a t1, table_B t2\nWHERE t1.column_1 = t2.column_1(+);\n\n-- RIGHT OUTER JOIN: new syntax\nSELECT column_list\nFROM table_a t1 RIGHT [OUTER] JOIN table_B t2\n    ON (t1.column_1 = t2.column_1);\n\n-- RIGHT OUTER JOIN: old syntax\nSELECT column_list\nFROM table_a t1, table_B t2\nWHERE t1.column_1(+) = t2.column_1;\n\n-- FULL OUTER JOIN: new syntax\nSELECT column_list\nFROM table_a t1 FULL OUTER JOIN table_B t2\n    ON (t1.column_1 = t2.column_1);\n\n-- FULL OUTER JOIN: old syntax\nSELECT column_list\nFROM table_a t1, table_B t2\nWHERE t1.column_1(+) = t2.column_1(+);\n</code></pre> <p>Notes</p> <ul> <li>Includes records of a table in output when there's no matching record in the other table.</li> </ul> Sources <ul> <li>Oracle Documentation - Outer Joins</li> </ul>"},{"location":"SQL/materialized-views/","title":"Materialized Views","text":""},{"location":"SQL/materialized-views/#create-materialized-view-log","title":"CREATE MATERIALIZED VIEW LOG","text":"<pre><code>CREATE MATERIALIZED VIEW LOG ON [schema.]table_name\n    [PARALLEL integer | NOPARALLEL]\n    [WITH \n        OBJECT ID |\n        PRIMARY KEY |\n        ROWID |\n        SEQUENCE |\n        COMMIT SCN\n    (column_1 [, column_n])\n    ]\n    [PURGE IMMEDIATE {SYNCHRONOUS | ASYNCHRONOUS}]\n    [FOR \n        SYNCHRONOUS REFRESH USING staging_table_name |\n        FAST REFRESH\n    ]\n;\n</code></pre> <p>Semantics</p> <ul> <li><code>PARALLEL integer | NOPARALLEL</code>: indicates whether parallel operations will be supported for the Materialized View Log.</li> <li><code>WITH</code>: indicate whether the Materialized View Log should record the Primary Key, ROWID, OBJECT ID, or a combination of these row identifiers when rows in the master Table are changed. <ul> <li><code>COMMIT SCN</code>: specify COMMIT SCN to instruct the database to use commit SCN data rather than timestamps.</li> <li>column_1 [, column_n]: specify the columns whose values you want to be recorded in the Materialized View Log for all rows that are changed.</li> </ul> </li> <li><code>PURGE IMMEDIATE SYNCHRONOUS</code>: the Materialized View Log is purged immediately after refresh.<ul> <li>this is the default option.</li> </ul> </li> <li><code>PURGE IMMEDIATE ASYNCHRONOUS</code>: the Materialized View Log is purged in a separate Oracle Scheduler job after the refresh operation. </li> <li><code>FOR SYNCHRONOUS REFRESH USING staging_table_name</code>: specify this clause to create a staging log that can be used for synchronous refresh. staging_table_name is the name of the Table that will be created for logging.<ul> <li>the base table must have a PRIMARY KEY constraint defined on it.</li> </ul> </li> <li><code>FOR FAST REFRESH</code>: specify this clause to create a Materialized View Log that can be used for fast refresh.</li> </ul> <p>Notes</p> <ul> <li>A Materialized View Log is a Table associated with the master Table of a Materialized View. They are used for two types of Materialized View refreshes:<ul> <li>Fast Refresh: when DML changes are made to the original Table, they are also stored in the Materialized View Log and the Oracle Database uses them to refresh the Materialized Views.</li> <li>Synchronous Refresh: DML Changes are first described in the Materialized View Log and then to the master Table and Materialized View simultaneously.</li> </ul> </li> <li>This guarantees that the master Table and the Materialized View data are in sync.</li> <li>This refresh method is useful in Data Warehousing environments.</li> <li>Materialized View Logs must be created on Table with a PRIMARY KEY or UNIQUE INDEX defined, otherwise Oracle would return <code>ORA-12014: table 'X' does not contain a primary key constraint</code>.</li> <li>A master Table can have only one Materialized View Log defined on it.</li> <li>To fast refresh or sync refresh a Materialized View that uses Joins, you must create a Materialized View Log for each Table.</li> <li>Materialized View Logs cannot be created on Tables that have Identity Columns or Virtual Columns.</li> <li>Without a Materialized View Log, Oracle must re-execute the Materialized View Query to refresh the data (known as Complete Refresh).</li> <li>If you do not specify the WITH Clause, Oracle Database uses the PRIMARY KEY column(s) by default.</li> <li>If <code>WITH COMMIT SCN</code> is specified, you cannot use <code>FOR SYNCHRONOUS REFRESH</code>.</li> <li>staging_table_name will be created in the same Schema of the master Table.</li> <li>After you create the staging log, you cannot perform DML operations directly on the master table. You must use the procedures in the <code>DBMS_SYNC_REFRESH</code> package to prepare and execute change data operations</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT CREATE ANY TABLE TO user_name;</code></li> <li><code>GRANT COMMENT ANY TABLE TO user_name;</code></li> <li><code>GRANT READ {ANY TABLE | ON table_name} TO user_name;</code> </li> <li><code>GRANT SELECT {ANY TABLE | ON table_name} TO user_name;</code></li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_MVIEW_LOGS</code></li> </ul>"},{"location":"SQL/operators/","title":"Comparison Operators","text":""},{"location":"SQL/operators/#set-comparison-operators","title":"SET COMPARISON OPERATORS","text":"<ul> <li>column_name &lt; ANY (values): Less than maximum</li> <li>column_name &gt; ANY (values): Greater than minimum<ul> <li>Example: <code>x &gt; ANY (1, 2, 3)</code> \u2192 <code>x &gt; 1 OR x &gt; 2 OR x &gt; 3 \u2192 x &gt; 1</code></li> </ul> </li> <li>column_name = ANY (values): Equivalent to IN<ul> <li>Example: <code>x = ANY (1, 2, 3)</code> \u2192 <code>x IN (1, 2, 3) \u2192 x = 1 OR x = 2 OR x = 3</code></li> </ul> </li> <li>column_name &gt; ALL (values): Greater than maximum<ul> <li>Example: <code>x &gt; ALL (1,2,3)</code> \u2192 <code>x &gt; 1 AND x &gt; 2 AND x &gt; 3 \u2192 x &gt; 3</code></li> </ul> </li> <li>column_name &lt; ALL (values): Less than mininum</li> </ul>"},{"location":"SQL/operators/#any-operator","title":"ANY Operator","text":"<pre><code>operator comparison_op ANY ({expr_1, expr_n | subquery})\n</code></pre> <p>Semantics</p> <ul> <li>comparison_op: the comparison operator (=, !=, &gt;, &gt;=, etc.)</li> <li>expr_1, expr_n: values you're comparing to operator.</li> <li>subquery: subquery returning one or more rows. </li> </ul> <p>Notes</p> <ul> <li>The ANY Operator is used to compare a value to a list of values or result set returned by a subquery.</li> <li>If subquery returns no rows, the main query will return no rows as well.</li> </ul> <p>Examples</p> <pre><code>SELECT *\nFROM tablename\nWHERE c &gt; ANY (v1, v2, v3);\n\n-- would be equivalent to:\n\nSELECT *\nFROM tablename\nWHERE c &gt; v1\n    OR c &gt; v2\n    OR c &gt; v2;\n</code></pre>"},{"location":"SQL/operators/#intersect-operator","title":"INTERSECT Operator","text":"<pre><code>SELECT column_list\nFROM table_1\nINTERSECT\nSELECT column_list\nFROM table_2;\n</code></pre> <p>Notes</p> <ul> <li>The INTERSECT operator compares the result of two queries and returns the distinct rows that are output by both queries.</li> <li>The number and order of columns must be the same in the two queries.</li> <li>The data type of the corresponding columns must be in the same data type group such as numeric or character.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/operators/#minus-operator","title":"MINUS Operator","text":"<pre><code>SELECT column_list\nFROM table_1\nMINUS\nSELECT column_list\nFROM table_2;\n</code></pre> <p>Notes</p> <ul> <li>The MINUS operator is used to return all rows in the first SELECT statement that are not returned by the second SELECT statement.</li> <li>The number and order of columns must be the same in the two queries.</li> <li>The data type of the corresponding columns must be in the same data type group such as numeric or character.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/operators/#union-union-all-operators","title":"UNION &amp; UNION ALL Operators","text":"<pre><code>SELECT column_list\nFROM table_1\nUNION [ALL]\nSELECT column_list\nFROM table_2;\n</code></pre> <p>Notes</p> <ul> <li>The UNION &amp; UNION ALL operators are set operators that combines result sets of two or more SELECT statements into a single result set.</li> <li>UNION ALL returns all records including duplicates, while UNION returns only unique records.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/sequences/","title":"Sequences","text":""},{"location":"SQL/sequences/#create-sequence","title":"CREATE SEQUENCE","text":"<pre><code>CREATE SEQUENCE [schema.]sequence_name\n[INCREMENT BY | START WITH integer]\n[NOMAXVALUE | MAXVALUE integer]\n[NOMINVALUE | MINVALUE integer]\n[CYCLE | NOCYCLE]\n[NOCACHE | CACHE integer]\n[ORDER | NOORDER]\n;\n</code></pre> <p>Semantics</p> <ul> <li><code>INCREMENT BY</code>: specify the interval between Sequence numbers.  </li> <li><code>START WITH</code>: specify the first Sequence number to be generated.</li> <li><code>MAXVALUE integer</code>: specify the maximum value the Sequence can generate.</li> <li><code>NOMAXVALUE integer</code>: indicates a minimum value of 1 for an ascending Sequence or -(10^27 -1) for descending Sequence.</li> <li><code>CYCLE</code>: indicates that the Sequence continues to generate values after reaching either its maximum or minimum value.</li> <li><code>NOCYCLE</code>: indicates that the Sequence cannot generate more value after reaching its maximum or minimum value.</li> <li><code>CACHE</code>: specify how many values of the Sequence the Database preallocates and keeps in memory for faster access.</li> <li><code>NOCACHE</code>: indicates that values of the Sequence are not preallocated.</li> <li><code>ORDER</code>: guarantees that Sequence numbers are generated in order of request.</li> <li><code>NOORDER</code>: does not guarantee Sequence numbers to be generated in order of request.</li> </ul> <p>Sequence's Default Options</p> <ul> <li><code>INCREMENT BY 1</code></li> <li><code>START WITH ?</code></li> <li><code>NOMAXVALUE</code></li> <li><code>NOCYCLE</code></li> <li><code>CACHE 20</code></li> <li><code>NOORDER</code></li> </ul> <p>Notes</p> <ul> <li>A Sequence is a database object from which multiple users may generate unique integers.  </li> <li>It can be used to automatically generate primary key values.</li> <li>When a Sequence number is generated, the Sequence is incremented, independent of the transaction committing or rolling back.</li> <li>If two users concurrently increment the same Sequence, then the Sequence numbers each user acquires may have gaps, because Sequence numbers are being generated by the other user.</li> <li>There is no ROLLBACK in the Sequence values.</li> <li><code>INCREMENT BY</code> cannot be 0.</li> <li><code>MAXVALUE</code> must be:</li> <li>Equal to or greater than <code>START WITH</code>. </li> <li>Greater than <code>MINVALUE</code></li> <li>After an ascending Sequence reaches its maximum value, it generates its minimum value.</li> <li>After a descending Sequence reaches its minimum, it generates its maximum value.</li> <li>Mininum value of <code>CACHE</code> is 2.</li> <li>CACHE value must be less than the value determined by this formula: <code>CEIL((MAXVALUE-MINVALUE)/ABS(INCREMENT))</code></li> <li>If a system failure occurs, then all cached Sequence values that have not been used in committed DML statements are lost.</li> <li>Guaranteeing order is usually not important for Sequences used to generate Primary Keys.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>CREATE [ANY] SEQUENCE TO user_name;</code></li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_SEQUENCES</code></li> </ul> Sources <ul> <li>Oracle Documentation - Managing Sequences</li> </ul>"},{"location":"SQL/sequences/#alter-sequence","title":"ALTER SEQUENCE","text":"<pre><code>ALTER SEQUENCE [schema.]sequence_name\n{\n    {INCREMENT BY number | START WITH number} |\n    {MAXVALUE number | NOMAXVALUE number} |\n    {MINVALUE number | NOMINVALUE number} |\n    RESTART |\n    {CYCLE | NOCYCLE} |\n    {CACHE number | NOCACHE} |\n    {ORDER | NOORDER} |\n    {KEEP | NOKEEP} |\n    {SCALE EXTEND | SCALE NOEXTEND | NOSCALE} |\n    {SHARD EXTEND | SHARD NOEXTEND | NOSHARD} |\n    {SESSION | GLOBAL} \n}\n</code></pre> <p>Semantics</p> <ul> <li><code>RESTART</code>: resets NEXTVAL to MINVALUE for an ascending Sequence. For a descending Sequence restarts NEXTVAL to MAXVALUE.</li> </ul> <p>Notes</p> <ul> <li>To restart a Sequence with a different number, specify both RESTART and START WITH.</li> <li>A new MAXVALUE cannot be less than the current Sequence number.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT ALTER {ANY SEQUENCE | sequence_name} TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - ALTER SEQUENCE</li> </ul>"},{"location":"SQL/subqueries/","title":"Subqueries","text":"<p>Work in Progress Section</p>"},{"location":"SQL/subqueries/#correlated-subqueries","title":"Correlated Subqueries","text":"<p>Notes</p> <ul> <li>A Correlated Subquery is a subquery whose some clauses refer to the column expressions in the outer query.</li> <li>The Correlated Subquery executes after the outer query returns the row.</li> <li>Each row returned by the outer query is evaluated for the results returned by the Correlated Subquery.</li> </ul> <p>Examples</p> <pre><code>SELECT product_id, product_name, list_price\nFROM products p\nWHERE list_price &gt;\n    (SELECT AVG(list_price)\n    FROM products\n    WHERE category_id = p.category_id);\n</code></pre>"},{"location":"SQL/subqueries/#single-row-subqueries","title":"Single-Row Subqueries","text":"<p>Notes</p> <ul> <li>A Single-Row Subquery returns zero or one rows to the outer SQL Statement.  </li> <li>A Single-Row Subquery can be placed in a WHERE clause, HAVING clause, or a FROM clause of a SELECT Statement.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - Single-Row Subqueries</li> </ul>"},{"location":"SQL/subqueries/#multiple-row-subqueries","title":"Multiple-Row Subqueries","text":"<p>Notes</p> <ul> <li>A Multiple-Row Subquery returns more than one row to the outer SQL Statement.  </li> <li>Despite it's called \"Multiple-Row Subquery\", it can still return 0 or 1 row.  </li> <li>You can use operators such as IN, ANY, or ALL.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - Multiple-Row Subqueries</li> </ul>"},{"location":"SQL/synonyms/","title":"Synonyms","text":""},{"location":"SQL/synonyms/#create-synonym","title":"CREATE SYNONYM","text":"<pre><code>CREATE [OR REPLACE] [PUBLIC] SYNONYM [schema.]synonym_name\n    FOR [schema.]object_name;\n</code></pre> <p>Semantics</p> <ul> <li><code>OR REPLACE</code>: allows you to recreate the Synonym if it already exists.</li> <li><code>PUBLIC</code>: if specified, the Synonym is a Public Synonym and accessible to all users, otherwise it'll be a Private Synonym.</li> <li>schema: schema on which the Synonym will be created.</li> <li>object_name: the name of the object for which you are creating the Synonym. <ul> <li>can be one of the following:<ul> <li>Table</li> <li>View</li> <li>Sequence</li> <li>Stored Procedure</li> <li>Function</li> <li>Package</li> <li>Materialized View</li> <li>User-defined Object</li> <li>Synonym</li> </ul> </li> </ul> </li> </ul> <p>Notes</p> <ul> <li>A Synonym is an alternative name for objects such as Tables, Views, Sequences, etc.  </li> <li>Synonyms allow underlying obejcts to be renamed or moved, where only the Synonym must be redefined and applications based on the synonym continue to function without modification.</li> </ul> <p>Privilege Restrictions</p> <ul> <li>(Private Synonym) <code>GRANT CREATE [ANY] SYNONYM TO user_name;</code></li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_SYNONYMS</code></li> </ul> Sources <ul> <li>Oracle Documentation - Managing Synonyms</li> <li>Oracle Documentation - CREATE SYNONYM</li> </ul>"},{"location":"SQL/synonyms/#drop-synonym","title":"DROP SYNONYM","text":"<pre><code>DROP [PUBLIC] SYNONYM synonym_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - DROP SYNONYM</li> </ul>"},{"location":"SQL/transactions/","title":"Transactions","text":""},{"location":"SQL/transactions/#rollback","title":"ROLLBACK","text":"<pre><code>ROLLBACK;\n</code></pre> <p>Notes</p> <ul> <li>A rollback of an uncommitted Transaction undoes any changes to data that have been performed by SQL Statements within the transaction.  </li> <li>After a Transaction has been rolled back, the effects of the work done in the Transaction no longer exist.</li> <li>In rolling back an entire Transaction, without referencing any savepoints, Oracle Database performs the following actions:<ul> <li>undoes all changes made by all the SQL Statements in the Transaction</li> <li>releases all the locks of data held by the Transaction</li> <li>erases all savepoints in the Transaction</li> <li>ends the transaction</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - ROLLBACK</li> </ul>"},{"location":"SQL/transactions/#commit","title":"COMMIT","text":"<pre><code>COMMIT;\n</code></pre> <p>Notes</p> <ul> <li>A commit ends the current Transaction and makes permanent all changes performed in the Transaction.</li> <li>When a Transaction commits, the following actions occur:<ul> <li>locks held on rows and table are released.</li> <li>any savepoint is deleted.</li> <li>the transaction is marked as complete.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - COMMIT</li> </ul>"},{"location":"SQL/transactions/#flashback-table","title":"FLASHBACK TABLE","text":"<pre><code>FLASHBACK TABLE\n    [schema.]table_name\n    [, [schema.]table_name]\nTO\n    BEFORE DROP [RENAME TO table_name] |\n    {RESTORE POINT rp_name | SCN number_value | TIMESTAMP date_value ENABLE | DISABLE TRIGGERS}\n;\n</code></pre> <p>Semantics</p> <ul> <li><code>TO BEFORE DROP</code>: retrieve from the Recycle Bin a Table that has been dropped. Tables dropped with the PURGE clause cannot be recovered.</li> <li><code>RENAME TO table_name</code>: specify this clause if you want to rename the Table after it is recovered.</li> <li><code>TO RESTORE POINT rp_name</code>: specify a restore point to which you want to flash back the Table.</li> <li><code>TO SCN number_value</code>: specify the System Change Number (SCN) corrensponding the point in time to which you want to return the Table.</li> <li><code>TO_TIMESTAMP date_value</code>: specify a timestamp value corresponding to the poin in time to which you want to return the Table.</li> <li><code>ENABLE | DISABLE TRIGGERS</code>: by default, Oracle disables all the Triggers related to the Table during the Flashback operation (they get re-enabled after the operation is done). Specify ENABLE if you want to override this option and keep them active.</li> </ul> <p>Notes</p> <ul> <li>This Statement is used to restore an earlier state of a Table in the event of human or application error.  </li> <li>The time in the past to which the Table can be flashed back is dependent on the amount of undo data in the system.</li> <li>You cannot roll back a FLASHBACK TABLE Statement. However, you can issue another FLASHBACK TABLE to undo a previous flashback.</li> <li>During a Flashback operation, Oracle Database locks the Table until the Flashback is done. The operation is done in a single Transaction.</li> <li>If you're issuing a FLASHBACK TABLE on multiple Tables, all of them must succeed to complete the operation, otherwise the Statement will be reverted.</li> <li><code>FLASHBACK TABLE TO BEFORE DROP</code> does not recover referential constraints.</li> <li>If the Table is recovered from the Recycle Bin, then the Database also retrieves:<ul> <li>Indexes (except for Bitmap Join and Domain Indexes)</li> <li>Triggers</li> <li>Constraints</li> </ul> </li> <li>You cannot perform a FLASHBACK TABLE on a Materialized View.</li> <li>FLASHBACK TABLE might require to enable a Table's row movement:<ul> <li>To check if it is enabled: <pre><code>SELECT table_name,row_movement\nFROM dba_tables\nWHERE table_name = your_table_name;\n</code></pre></li> <li>To enable it: <pre><code>ALTER TABLE [schema.]table_name\nENABLE ROW MOVEMENT;\n</code></pre></li> </ul> </li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT FLASHBACK {ON [schema.]table_name | ANY TABLE} TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - FLASHBACK TABLE</li> </ul>"},{"location":"SQL/transactions/#lock-table","title":"LOCK TABLE","text":"<pre><code>LOCK TABLE [schema.]object_name\n    [\n        PARTITION {(partition_name) | FOR (partition_key_value_1 [, partition_key_value_n]) | \n        SUBPARTITION (subpartition_name) | FOR (subpartition_key_vale_1 [, subpartition_key_value_n])\n    ]\nIN lockmode MODE\n[NO WAIT |  WAIT integer]\n;\n</code></pre> <p>Semantics</p> <ul> <li>object_name; specify the Table or View you want to lock.<ul> <li>specifying a View causes the Database to lock the base Tables of the View.</li> </ul> </li> <li>IN lockmode MODE: can be one of the following:<ul> <li><code>ROW SHARE</code>: permits concurrent access to the Locked Table but prohibits users from locking the entire Table for exclusive access.</li> <li><code>ROW EXCLUSIVE</code>: same as ROW SHARE, but prohibits locking in SHARE mode.</li> <li><code>SHARE UPDATE</code>: synonym of ROW SHARE.</li> <li><code>SHARE</code>: permits concurrent queries but prohibits updates to the Locked Table.</li> <li><code>SHARE ROW EXCLUSIVE</code>: allows other users to look at the Table but prohibits locking it in SHARE mode or from updating rows.</li> <li><code>EXCLUSIVE</code>: permits queries on the Locked Table but prohibits any other activity on it.</li> </ul> </li> <li><code>NOWAIT</code>: immediately return an error message if the Table is already locked.</li> <li><code>WAIT integer</code>: wait for integer (in seconds) to acquire a DML Lock.</li> </ul> <p>Notes</p> <ul> <li>A Locked Table remains locked until you either commit your Transaction or roll it back.  </li> <li>A Locked Table does not prevent other users from querying the Table.</li> <li>If you specify neither NOWAIT nor WAIT, the Database waits indefinitely until the Table is available.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT LOCK ANY TABLE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - LOCK TABLE</li> </ul>"},{"location":"SQL/users/","title":"Managing Users","text":"<p>Work in Progress Section</p>"},{"location":"SQL/users/#grant","title":"GRANT","text":"<pre><code>GRANT\n    role_name |\n    ALL PRIVILEGES |\n    system_privilege_name\nTO\n    {user_name | grantee_role_name | PUBLIC} |\n    user_name IDENTIFIED BY password\n[WITH {ADMIN | DELEGATE} OPTION]\n;\n</code></pre> <p>Semantics</p> <ul> <li>role_name: specify the role you want to grant.</li> <li><code>ALL PRIVILEGES</code>: if you want to grant all of the System Privileges<ul> <li>the System Privileges <code>SELECT ANY DICTIONARY</code>,<code>ALTER DATABASE LINK</code>,<code>ALTER PUBLIC DATABASE LINK</code> are not included.</li> </ul> </li> <li>system_privilege_name: specify the System Privilege you want to grant.</li> <li>user_name: specify the user that will be granted the System Privileges.</li> <li>grantee_role_name: specify the role that will be granted the System Privileges.</li> <li><code>PUBLIC</code>: specify PUBLIC to grant the privileges to all users.</li> <li><code>user_name IDENTIFIED BY password</code>: if user_name exists, resets their password, otherwise creates the user with that password.</li> <li><code>WITH ADMIN OPTION</code>: enables the grantee to:<ul> <li>grant the privilege or role to another user or role</li> <li>revoke the privilege or role from another user or role</li> <li>alter the privilege or role to change the authorization needed to access it</li> <li>drop the privilege or role</li> <li>grant the privilege or role to a program unit in the grantee's schema</li> <li>revoke the privilege or role from a program unit in the grantee's schema</li> </ul> </li> <li><code>WITH DELEGATE OPTION</code>: enables the grantee to:<ul> <li>grant the privilege or role to a program unit in the grantee's schema</li> <li>revoke the privilege or role from a program unit in the grantee's schema</li> </ul> </li> </ul>"},{"location":"SQL/users/#grant-object-privileges","title":"GRANT - Object Privileges","text":"<pre><code>GRANT\n    object_privilege_1 [, object_privilege_n] |\n    ALL [PRIVILEGES]\n    [(column_1 [, column_n])]\nON\n    [schema.]object_name |\n    USER user_1 [, user_n]\nTO\n    {user_name | grantee_role_name | PUBLIC}\n[WITH HIERARCHY OPTION]\n[WITH GRANT OPTION]\n;\n</code></pre> <p>Semantics</p> <ul> <li>object_privilege_1, object_privilege_n: specify the Object Privilege(s) you want to grant.</li> <li><code>ALL [PRIVILEGES]</code>: specify ALL to grant all the privileges for object_name.</li> <li>[(column_1 [, column_n])]: specify the Table or View column on which privileges are to be granted. Can only be specified for INSERT, REFERENCES or UPDATE Object Privileges.</li> <li>object_name: specify the schema object on which the privileges are to be granted.</li> <li><code>ON USER user_1 [, user_n]</code>: specify the database user you want to grant privileges to.</li> <li>You cannot specify PUBLIC as user.</li> <li><code>WITH HIERARCHY OPTION</code>: grants the specified Object Privileges on all subobjects of object_name, such as subviews created under a View.</li> <li><code>WITH GRANT OPTION</code>: enables the grantee to grant the Object Privileges to other users and roles.</li> </ul> <p>Notes</p> <ul> <li>A user, role or PUBLIC cannot appear more that once in the grantee clause.</li> <li>An Object Privilege cannot appear more than once in the list of privileges to be granted. </li> <li>To remove the <code>WITH ADMIN OPTION</code> or <code>WITH DELEGATE OPTION</code> from an user or role, you must revoke the privilege or role and the grant again.</li> <li>You cannot grant a role to itself.</li> <li>You cannot grant privileges directly to a single Partition of a Partitioned Table.</li> <li>For Object Privileges, <code>WITH ADMIN OPTION</code> cannot be granted to roles.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT ANY PRIVILEGE TO user_name;</code></li> <li><code>WITH ADMIN OPTION</code> Clause</li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_COL_PRIVS</code></li> </ul> Sources <ul> <li>Oracle Documentation - List of System Privileges</li> <li>Oracle Documentation - List of Object Privileges</li> <li>Oracle Documentation - GRANT</li> </ul>"},{"location":"SQL/users/#with-grant-option-vs-with-admin-option","title":"WITH GRANT OPTION vs. WITH ADMIN OPTION","text":"<p>WITH GRANT OPTION Only for OBJECT PRIVILEGES</p> <ul> <li>The owner of an object can grant it to another user by specifying the WITH GRANT OPTION clause in the GRANT statement.</li> <li>The new grantee can then grant the same level of access to other users or roles.</li> </ul> <p>Notes</p> <ul> <li>You cannot grant WITH GRANT OPTION to a role.</li> <li>If you revoke access to a user who had been granted access to an object WITH GRANT OPTION and that user had granted access to another user, both sets of grants will be revoked (cascade effect).</li> </ul> <p>WITH ADMIN OPTION Only for SYSTEM PRIVILEGES Specify WITH ADMIN OPTION to enable the grantee to:</p> <ul> <li>Grant the role to another user or role, unless the role is a GLOBAL role</li> <li>Revoke the role from another user or role</li> <li>Alter the role to change the authorization needed to access it</li> <li>Drop the role</li> </ul> <p>To revoke the ADMIN OPTION on a Sytem Privilege or role from a user, you must revoke the privilege or role from the user altogether and then grant the privilege or role to the user without the ADMIN OPTION.</p>"},{"location":"SQL/users/#grant-select-vs-grant-read","title":"GRANT SELECT vs GRANT READ","text":"<ul> <li><code>GRANT SELECT</code> allows users to lock Tables through the <code>SELECT .. FOR UPDATE</code> statement.</li> <li><code>GRANT READ</code> only allows SELECT statement, preventing the table's lock.</li> </ul> <pre><code>GRANT READ ON &lt;schema.&gt;&lt;object&gt; TO &lt;user&gt;;\n</code></pre>"},{"location":"SQL/views/","title":"Views","text":""},{"location":"SQL/views/#create-view","title":"CREATE VIEW","text":"<pre><code>CREATE [OR REPLACE] VIEW view_name AS\nquery\n[WITH CHECK OPTION];\n</code></pre> <p>Semantics</p> <ul> <li><code>WITH CHECK OPTION</code>: can be given for an updatable View to prevent inserts to rows for which the WHERE clause in the SELECT Statement is not true.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>CREATE [ANY] VIEW TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - Managing Views</li> <li>Oracle Documentation - CREATE VIEW</li> </ul>"},{"location":"SQL/views/#with-check-option","title":"WITH CHECK OPTION","text":"<p>Usually you can insert rows in a Table through a View even if the rows you're adding violate the View's WHERE condition. (Example 1) To prevent that and make it so the rows you try to insert are valid for the View as well, you can add the WITH CHECK OPTION. (Example 2)</p> <p>Example 1 <pre><code>CREATE TABLE t (t1 number);\n\nCREATE OR REPLACE VIEW vw AS SELECT * FROM t WHERE t1 &gt; 0;\n\nINSERT INTO vw VALUES (0);\n\nSELECT * FROM t;\n-- returns 1 rows\n\nSELECT count(1) FROM vw;\n-- returns 0\n</code></pre></p> <p>Example 2 <pre><code>CREATE OR REPLACE VIEW vw AS SELECT * FROM t WHERE t1 &gt; 0 WITH CHECK OPTION;\n\nINSERT INTO vw VALUES (0);\n-- returns ORA-01402: view WITH CHECK OPTION where-clause violation\n</code></pre></p> Sources <ul> <li>Oracle Documentation - CREATE VIEW</li> </ul>"}]}