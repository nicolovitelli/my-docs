{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"my-docs","text":"<ul> <li>SQL</li> <li>PL/SQL</li> </ul>"},{"location":"PLSQL/accessible_by/","title":"ACCESSIBLE BY Clause","text":"<p>The ACCESSIBLE BY clause restricts access to a unit or subprogram by other units. This clause can be used by the following statements:</p> <ul> <li><code>ALTER TYPE</code></li> <li><code>CREATE FUNCTION</code></li> <li><code>CREATE PROCEDURE</code></li> <li><code>CREATE PACKAGE</code></li> <li><code>CREATE TYPE</code></li> <li><code>CREATE TYPE BODY</code></li> </ul> <p>Syntax <pre><code>ACCESSIBLE BY (\n    [FUNCTION | PROCEDURE | PACKAGE | TRIGGER | TYPE]\n    [schema.]unit_name\n)\n</code></pre></p> <ul> <li>unit_name: specifies a stored PL/SQL unit that can invoke the entity.<ul> <li>it's not required for the unit_name to exist.</li> </ul> </li> <li>type of object (Function, Procedure, Package, Trigger, Type) is optional but is recommended to avoid ambiguity (it's possible to have a Trigger with the same name as a Function).</li> </ul> <p>Examples</p> <pre><code>CREATE OR REPLACE PROCEDURE private_procedure\n    ACCESSIBLE BY (PROCEDURE trusted_procedure)\nIS\nBEGIN \n    dbms_output.put_line('executed private_procedure');\nEND;\n/\n-- Procedure PRIVATE_PROCEDURE compiled\n\nCREATE OR REPLACE PROCEDURE trusted_procedure\nIS \nBEGIN \n    dbms_output.put_line('executed trusted_procedure');\n    private_procedure;  \n    dbms_output.put_line('called private_procedure');\nEND;\n/\n-- Procedure TRUSTED_PROCEDURE compiled\n\nEXEC trusted_procedure;\n-- executed trusted_procedure\n-- executed private_procedure\n-- called private_procedure\n\nEXEC private_procedure;\n-- PLS-00904: insufficient privilege to access object PRIVATE_PROCEDURE\n\nBEGIN\n    private_procedure;\nEND;\n-- PLS-00904: insufficient privilege to access object PRIVATE_PROCEDURE\n</code></pre> Sources <ul> <li>Oracle Documentation - ACCESSIBLE BY Clause</li> </ul>"},{"location":"PLSQL/associative_arrays/","title":"Associative Arrays","text":"<p>An Associative Array is a set of key-value pairs:</p> <ul> <li>Each key is unique and it is used to find the associate value.</li> <li>The index's datatype can be a String (VARCHAR2, CHAR, etc) or PLS_INTEGER.</li> <li>Indexes are stored in sorted order, not creation order.</li> <li>For String Indexes, their sort is determined by the parameters NLS_SORT and NLS_COMP.</li> <li>You can use any value that can be converted to char through the TO_CHAR function as index datatype.</li> <li>It is not recommended to use <code>TO_CHAR(SYSDATE)</code> as index datatype because if the value of NLS_DATE_FORMAT changes, then the Associative Array's indexes change too.</li> </ul> <p>An Associative Array...</p> <ul> <li>is empty (but not null) until you populate it</li> <li>can hold unspecified number of elements</li> <li>does not need disk space or network operations</li> <li>cannot be manipulated with DML statements</li> <li>can be defined only in PL/SQL Blocks</li> </ul> <p>Syntax <pre><code>TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY key_type;\n</code></pre></p> <ul> <li>type_name: name of the collection.</li> <li>element_type: datatype of the elements stored.</li> <li><code>NOT NULL</code>: every element in the array must have a value.</li> <li>key_type: datatype of the index.</li> </ul> <p>You must create a variable of the Associative Array datatype to insert or search for values:</p> <pre><code>TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY key_type;\nvariable_name type_name;\n</code></pre> <p>Examples</p> <pre><code>DECLARE\n   TYPE emp_table_type IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;\n   emp_table emp_table_type;\nBEGIN\n   emp_table(1) := 'John Doe';\n   emp_table(2) := 'Jane Smith';\n   emp_table(3) := 'Robert Brown';\n\n   DBMS_OUTPUT.PUT_LINE(emp_table(1));\nEND;\n/\n    -- OUTPUT: John Doe\n</code></pre> Sources <ul> <li>Oracle Documentation - Associative Arrays</li> </ul>"},{"location":"PLSQL/conditional_compilation/","title":"Conditional Compilation","text":"<p>Conditional Compilation in PL/SQL is generally used for code that needs to be ran on multiple Oracle DB versions. Main constructs are <code>$IF</code>, <code>$THEN</code>, <code>$ELSE</code>, <code>$ELSIF</code>, <code>$END</code>, <code>$DEBUG</code> (to check if debug mode is on) <code>$ERROR</code> (for displaying errors) and <code>$WARNING</code> (for displaying warnings).</p> <p>Examples</p> <pre><code>declare\n    v_version varchar2(10);\nbegin\n    $if dbms_db_version.version = 1 2 $then\n        v_version := 'oracle 12c';\n    $elsif dbms_db_version.version = 11 $then\n        v_version := 'oracle 11g';\n    $else\n        v_version := 'other';\n    $end;\n\n    dbms_output.put_line('database version: ' || v_version);\nend;\n</code></pre> <ul> <li>Oracle Live SQL - Examples of Conditional Compilation</li> </ul> Sources <ul> <li>Oracle-Base - Conditional Compilation in Oracle 10g</li> <li>Oracle Book - PL/SQL Conditional Compilation</li> </ul>"},{"location":"PLSQL/deprecate_pragma/","title":"DEPRECATE Pragma","text":"<p>This pragma marks as Deprecated PL/SQL objects. The compiler shows warning if the program uses deprecated objects. The DEPRECATE pragma can only appear in the Declaration Section and can be applied to:</p> <ul> <li>Subprograms (Procedure/Function)</li> <li>Packages</li> <li>Variables</li> <li>Constants</li> <li>Types</li> <li>Subtypes</li> <li>Exceptions</li> <li>Cursors</li> </ul> <p>Syntax <pre><code>PRAGMA DEPRECATE (pls_identifier [,character_literal]);\n</code></pre></p> <ul> <li>pls_identifer: name of the object that is being deprecated.</li> <li>character_literal: optional warning message.</li> </ul> <p>Examples</p> <pre><code>-- deprecation of Package\ncreate package pack1 as  \n    pragma deprecate (pack1);\n    procedure my_procedure;\nend;\n-- warnings will be issued for any reference to this package and its procedures.\n\n-- deprecation of Variable\ncreate package pack2 as  \n    my_variable number := 1;\n    pragma deprecate(my_variable, 'unused variable');\nend;\n</code></pre> Sources <ul> <li>Oracle Documentation - DEPRECATE Pragma</li> </ul>"},{"location":"PLSQL/functions/","title":"Functions","text":"<p>The CREATE FUNCTION statement creates or replaces a standalone Function or a call specification.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION [schema.]function_name\n    [(parameter [IN | OUT | IN OUT] parameter_datatype [, parameter])]\n    RETURN return_datatype\nIS | AS\n    [declaration_section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND [function_name];\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: recreates the function if it exists</li> <li>schema: name of the schema containing the function (default: current schema)</li> <li>function_name: name of the function to be created</li> <li>parameter: list of parameters passed to the function</li> <li><code>IN/OUT/IN OUT</code>:<ul> <li><code>IN</code>: the parameter's value can be read by the function but cannot be changed.</li> <li><code>OUT</code>: the parameter's value cannot be read by the function but can be changed.</li> <li><code>IN OUT</code>: the parameter's can be read and changed by the function.</li> </ul> </li> <li><code>RETURN datatype</code>: the return datatype of the function. Cannot specify a length, precision or scale.</li> </ul> <p>Notes</p> <ul> <li>Every Function must return one or more values.</li> <li>Parameters are always optional.</li> </ul> <p>Examples</p> <pre><code>CREATE OR REPLACE FUNCTION is_odd (in_number IN NUMBER)\nRETURN boolean\nIS\nBEGIN\n    IF (in_number / 2) != 0 THEN\n        RETURN TRUE;\n    ELSE\n        RETURN FALSE;\n    END IF;\nEND;\n/\n-- Function IS_ODD compiled\n\nBEGIN\n    dbms_output.put_line(\n        CASE WHEN IS_ODD(2)\n            THEN '2 is an odd number'\n            ELSE '2 is not an odd number'\n        END\n    );\nEND;\n-- 2 is an odd number\n\nSELECT\n    CASE WHEN IS_ODD(2)\n            THEN '2 is an odd number'\n            ELSE '2 is not an odd number'\n        END\nFROM dual;\n-- ORA-00920: invalid relational operator\n</code></pre> <p>Privilege Restrictions</p> <ul> <li>In your Schema: <code>GRANT CREATE PROCEDURE TO user_name;</code></li> <li>In another's user Schema: <code>GRANT CREATE ANY PROCEDURE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE FUNCTION Statement</li> </ul>"},{"location":"PLSQL/hints/","title":"NOCOPY","text":"<p>It's a Hint used to improve performance of OUT and IN OUT parameters in PL/SQL. There are two methods to pass OUT/IN OUT parameters:</p> <ul> <li>By Value: happens by default: a copy of the variable is created and any modification is done on the copy. Once the Procedure is completed, the data is passed on the original variable.</li> <li>By Reference: happens with the NOCOPY hint: instead of creating a copy of the variable, modifications are done directly to the original variable. In normal Procedures you wouldn't notice the difference between the two methods, but the difference can become considerable when working with large or complex datatypes.</li> </ul> <p>Syntax <pre><code>CREATE [OR REPLACE] PROCEDURE [schema.]procedure_name (parameter_name {OUT | IN OUT} NOCOPY datatype) IS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p> <p>Examples</p> <pre><code>CREATE OR REPLACE PROCEDURE in_out_nocopy (v_number IN OUT NOCOPY NUMBER) IS\nBEGIN\n    v_number := v_number * 2;\n    dmbs_output.put_line(v_number);\nEND;\n</code></pre>"},{"location":"PLSQL/hints/#parallel-enable","title":"PARALLEL ENABLE","text":"<p>This hint enables the Function on which it is declared for parallel execution.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION function_name (parameters) RETURN datatype\n    PARALLEL_ENABLE\nIS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p>"},{"location":"PLSQL/hints/#deterministic","title":"DETERMINISTIC","text":"<p>The DETERMINISTIC Clause marks a function to return predictable results. It is useful for optimizazion purposes: if the function is called multiple times with the same parameters, Oracle can avoid redundant calculations by reusing the previously computed result.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] FUNCTION function_name (parameters) RETURN datatype\n    DETERMINISTIC\nIS\n[declaration section]\nBEGIN\n    executable_section\n[EXCEPTION\n    exception_section]\nEND;\n</code></pre></p> <p>Examples</p> <pre><code>CREATE OR REPLACE FUNCTION square(n NUMBER)\n    RETURN NUMBER\n    DETERMINISTIC\nIS\nBEGIN\n    RETURN n * n;\nEND;\n</code></pre> Sources <ul> <li>Oracle Documentation - PARALLEL ENABLE Clause</li> <li>Oracle Documentation - DETERMINISTIC Clause</li> </ul>"},{"location":"PLSQL/subprograms/","title":"Subprograms","text":"<p>A PL/SQL subprogram is a PL/SQL block that can be invoked repeatedly. A PL/SQL subprogram can be created:</p> <ul> <li>inside a Package (which is called a package subprogram)</li> <li>at schema level (which is called a standalone subprogram)</li> <li>inside another PL/SQL subprogram (which is called a nested subprogram)</li> </ul> <p>Syntax to invoke a subprogram <pre><code>subprogram_name [([parameter_1 [, parameter_n]...])]\n</code></pre></p> <p>Notes</p> <ul> <li>Subprograms are divided in three sections:<ul> <li>optional declarative part: here you can declare and define Variables, Cursors, etc.</li> <li>executable part: contains one or more statements that will be executed.</li> <li>optional exception-handling part: code that handles exceptions.</li> </ul> </li> <li>Stored subprogram = package subprogram, standalone subprogram or named subprograms.</li> <li>Stored subprograms are stored in the database server.</li> </ul> Sources <ul> <li>Oracle Documentation - PL/SQL Subprograms</li> </ul>"},{"location":"PLSQL/triggers/","title":"Triggers","text":"<p>A Trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs. The main difference with Constraints is that Triggers apply to new data only.</p> <p>Types of Triggers</p> <ul> <li>DML Trigger: a Trigger created on a Table or View, which is composed by DML Statements.</li> <li>INSTEAD OF Trigger: a Trigger that replaces the original triggering DML Statement.</li> <li>System Trigger: a Trigger created on a Schema or Database, which is composed by DDL or Database Operation Statements.</li> <li>Conditional Trigger: a DML or System Trigger that has a WHEN clause.</li> </ul> Sources <ul> <li>Oracle Documentation - PL/SQL Triggers</li> </ul>"},{"location":"PLSQL/triggers/#dml-trigger","title":"DML Trigger","text":"<p>A DML Trigger fires at exactly one of these timing points:</p> <ul> <li>before the triggering statement runs (BEFORE Statement Trigger)</li> <li>after the triggering statement runs (AFTER Statement Trigger)</li> <li>before each row that the triggering statement affects (BEFORE each row Trigger)</li> <li>after each row that the triggering statemet affects (AFTER each row Trigger)</li> </ul> <p>DML Trigger Syntax <pre><code>CREATE [OR REPLACE] TRIGGER [schema.]trigger_name\n  {BEFORE | AFTER} {INSERT | UPDATE [OF column [, column]] | DELETE [OR INSERT | UPDATE [OF column [, column]] | DELETE]}\n  ON [schema.]object_name \n  [FOR EACH ROW]\n  [FOLLOWS | PRECEDES [schema.]trigger_name]\n  [ENABLE | DISABLE]\n  [WHEN (condition)]\n[DECLARE section]\nBEGIN\n  ...\n[EXCEPTION section]\nEND;\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: re-creates the Trigger if it exists.</li> <li>schema: schema on which the Trigger will be created (default is current schema).</li> <li>trigger_name: name of the Trigger.</li> <li><code>BEFORE</code>: Trigger is fired before running the triggering event.</li> <li><code>AFTER</code>: Trigger is fired after running the triggering event.</li> <li><code>INSERT</code>: Trigger is fired whenever an INSERT Statement adds a row to object_name.</li> <li><code>DELETE</code>: Trigger is fired whenever a DELETE Statement removes a row from object_name.</li> <li><code>UPDATE [OF column [, column]]</code>: Trigger is fired whenever an UPDATE Statement changes a value in a specified column.</li> <li>if no column is specified, then the Trigger is fired whenever any column changes.</li> <li>if you specify a column, then that column's value cannot be changed in the Trigger Body.</li> <li>object_name: Table or View on which the Trigger is defined.</li> <li><code>FOR EACH ROW</code>: creates the Trigger as a Row Trigger. The Trigger is fired for each row that is affected.</li> <li><code>FOLLOWS | PRECEDES schema.trigger_name</code>: indicates if the Trigger should be fired after (FOLLOWS) or before (PRECEDES) another Trigger.</li> <li><code>ENABLE | DISABLE</code>: creates the Trigger in an Enabled/Disabled state. Default is ENABLE.</li> <li><code>WHEN (condition)</code>: specifies a SQL condition that the Database evaluates for each row that the triggering statement affects. Trigger Body will run only when condition is true.</li> </ul> <p>Notes</p> <ul> <li>If a Trigger produces compilation errors, then it is still created, but it fails on execution.<ul> <li>Query to check if compiled Trigger has errors: <code>SELECT * FROM all_errors WHERE type = 'TRIGGER';</code> </li> </ul> </li> <li>If a Trigger has a <code>WHEN (condition)</code> clause, then you must also specify <code>FOR EACH ROW</code>.</li> <li><code>WHEN (condition)</code> cannot include a Subquery or PL/SQL Expression (i.e. invokation of Functions, Procedures).</li> <li><code>WHEN (condition)</code> does not need semicolons (:) for OLD and NEW variables.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - DML Trigger - Example 1</li> <li>Oracle Live SQL - DML Trigger - Example 2</li> </ul> Sources <ul> <li>Oracle Documentation - DML Triggers</li> </ul>"},{"location":"PLSQL/triggers/#conditional-predicates","title":"Conditional Predicates","text":"<p>The Trigger can determine which event is happening thanks to Conditional Predicates. They can be used in Boolean Expressions (IF, CASE, etc.):</p> <ul> <li><code>INSERTING</code>: an INSERT Statement</li> <li><code>UPDATING</code>: an UPDATE Statement</li> <li><code>UPDATING ('column')</code>: an UPDATE Statement that affected the specified column</li> <li><code>DELETING</code>: a DELETE Statement\\</li> </ul> <p>Examples</p> <pre><code>IF INSERTING THEN\n  [PL/SQL Statements]\nEND IF;\n\nCASE\n  WHEN INSERTING THEN\n    [PL/SQL Statements]\n  WHEN UPDATING THEN\n    [PL/SQL Statements]\n  WHEN DELETING THEN\n    [PL/SQL Statements]\nEND CASE;\n</code></pre>"},{"location":"PLSQL/triggers/#correlation-names","title":"Correlation Names","text":"<p>(also know as Pseudorecords) Some Trigger Bodies can also use Correlation Names, which by default are:</p> <ul> <li><code>:NEW.column_name</code>: represents the new value</li> <li><code>:OLD.column_name</code>: represents the old value that is being replaced</li> </ul> Triggering Statement OLD.column_name Value NEW.column_name Value <code>INSERT</code> NULL Post-insert value <code>UPDATE</code> Pre-update value Post-update value <code>DELETE</code> Pre-delete value NULL <p>Notes</p> <ul> <li>A Trigger cannot change the OLD values.<ul> <li>This operation raises the <code>ORA-04085</code> error.</li> </ul> </li> <li>A Trigger cannot change NEW values if the Triggering Statement is DELETE.<ul> <li>This operation raises the <code>ORA-04084</code> error.</li> </ul> </li> <li>An AFTER Trigger cannot change NEW values, because the Triggering Statement runs before the Trigger fires.<ul> <li>This operation raises <code>ORA-04084</code> error.</li> </ul> </li> <li>If a Statement triggers both a BEFORE and an AFTER Trigger, and the BEFORE changes a NEW value, then the AFTER Trigger can see that change.</li> </ul>"},{"location":"PLSQL/triggers/#instead-of-trigger","title":"INSTEAD OF Trigger","text":"<p>An INSTEAD OF Trigger is a DML Trigger created on a noneditioning View. The Database fires the INSTEAD OF Trigger instead of running the triggering DML Statement.</p> <p>INSTEAD OF Triggers are always row-level Triggers. They can also use the OLD and NEW variables, but cannot change them.</p> <p>Syntax <pre><code>CREATE [OR REPLACE] TRIGGER [schema.]trigger_name\n  INSTEAD OF {INSERT | UPDATE | DELETE [OR INSERT | UPDATE | DELETE]}\n  ON view_name\n  FOR EACH ROW\n  [FOLLOWS | PRECEDES [schema.]trigger_name]\n  [ENABLE | DISABLE]\n[DECLARE section]\nBEGIN\n  ...\n[EXCEPTION section]\nEND;\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: re-creates the Trigger if it exists.</li> <li>schema: schema on which the Trigger will be created (default is current schema).</li> <li>trigger_name: name of the Trigger.</li> <li><code>DELETE</code>: the Trigger is fired whenever a row is deleted from the Table on which the View is defined.</li> <li><code>INSERT</code>: the Trigger is fired whenever a new row is inserted into the Table on which the View is defined.</li> <li><code>UPDATE</code>: the Trigger is fired whenever a row is updated on the Table on which the View is defined.</li> <li><code>ON view_name</code>: View on which the Trigger is defined. </li> <li><code>FOR EACH ROW</code>: mandatory for INSTEAD OF Triggers. The Trigger is fired for each row that is affected.</li> <li><code>FOLLOWS | PRECEDES schema.trigger_name</code>: indicates if the Trigger should be fired after (FOLLOWS) or before (PRECEDES) another Trigger.</li> <li><code>ENABLE | DISABLE</code>: creates the Trigger in an Enabled/Disables state. Default is ENABLE.</li> </ul> Sources <ul> <li>Oracle Documentation - INSTEAD OF DML Triggers</li> </ul>"},{"location":"PLSQL/triggers/#system-triggers","title":"System Triggers","text":"<p>A System Trigger is created on either a schema or the database. Its triggering event is composed of either DDL Statements or Database Operation Statements.</p> <p>A System Trigger fires at exactly one of these timing points:</p> <ul> <li>Before the Triggering Statement runs (BEFORE Trigger)</li> <li>After the Triggering Statement runs (AFTER Trigger)</li> <li>Instead of the triggering CREATE Statement (INSTEAD OF CREATE Trigger)</li> </ul> <p>DDL Statements These are the DDL Statements that are part of System Triggers:</p> <ul> <li><code>ALTER</code></li> <li><code>ANALYZE</code></li> <li><code>ASSOCIATE STATISTICS</code></li> <li><code>AUDIT</code></li> <li><code>COMMENT</code></li> <li><code>CREATE</code></li> <li><code>DISASSOCIATE STATISTICS</code></li> <li><code>DROP</code></li> <li><code>GRANT</code></li> <li><code>NOAUDIT</code></li> <li><code>RENAME</code></li> <li><code>REVOKE</code></li> <li><code>TRUNCATE</code></li> <li><code>DDL</code><ul> <li>causes the Trigger to fire whenever any of the preceding DDL Statements is issued</li> </ul> </li> </ul> <p>Database Operation Statements Thesere are the Database Operation Statements that are part of System Triggers:</p> <ul> <li><code>AFTER STARTUP</code></li> <li><code>BEFORE SHUTDOWN</code></li> <li><code>AFTER DB_ROLE_CHANGE</code></li> <li><code>AFTER SERVERERROR</code></li> <li><code>AFTER LOGON</code></li> <li><code>BEFORE LOGOFF</code></li> <li><code>AFTER SUSPEND</code></li> <li><code>AFTER CLONE</code></li> <li><code>BEFORE UNPLUG</code></li> <li><code>[BEFORE | AFTER] SET CONTAINER</code></li> </ul> Sources <ul> <li>Oracle Documentation - System Triggers</li> <li>Oracle Documentation - List of DDL Statements</li> <li>Oracle Documentation - List of Database Events</li> </ul>"},{"location":"PLSQL/triggers/#drop-trigger-statement","title":"DROP TRIGGER Statement","text":"<p>Syntax <pre><code>DROP TRIGGER [schema.]trigger_name;\n</code></pre></p> <p>Privilege Restrictions</p> <ul> <li><code>GRANT DROP ANY TRIGGER TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - DROP TRIGGER Statement</li> </ul>"},{"location":"SQL/DDL/","title":"DDL Statements","text":"<p>Data Definition Language (DDL) statements let you to perform these tasks:</p> <ul> <li>Create, alter, and drop schema objects</li> <li>Grant and revoke privileges and roles</li> <li>Analyze information on a table, index, or cluster</li> <li>Establish auditing options</li> <li>Add comments to the data dictionary</li> </ul> <p>The CREATE, ALTER, and DROP commands require exclusive access to the specified object. For example, an ALTER TABLE statement fails if another user has an open transaction on the specified table.</p> <p>The GRANT, REVOKE, ANALYZE, AUDIT, and COMMENT commands do not require exclusive access to the specified object. For example, you can analyze a table while other users are updating the table.</p> <p>Oracle Database implicitly commits the current transaction before and after every DDL statement.</p> <p>The DDL Statements are:</p> <ul> <li><code>ALTER ...</code> (all statements beginning with ALTER)</li> <li><code>ANALYZE</code></li> <li><code>ASSOCIATE STATISTICS</code></li> <li><code>AUDIT</code></li> <li><code>COMMENT</code></li> <li><code>CREATE ...</code> (all statements beginning with CREATE)</li> <li><code>DISASSOCIATE STATISTICS</code></li> <li><code>DROP ...</code> (all statements beginning with DROP)</li> <li><code>FLASHBACK ...</code> (all statements beginning with FLASHBACK)</li> <li><code>GRANT</code></li> <li><code>NOAUDIT</code></li> <li><code>PURGE</code></li> <li><code>RENAME</code></li> <li><code>REVOKE</code></li> <li><code>TRUNCATE</code></li> <li><code>UNDROP</code></li> </ul> Sources <ul> <li>Oracle Documentation - Data Definition Language (DDL) Statements</li> </ul>"},{"location":"SQL/DDL/#create-table","title":"CREATE TABLE","text":"<p>This statement creates a Table in the Database.</p> <p>Syntax <pre><code>-- manual column definition\nCREATE TABLE [schema.]table_name\n    ( columnname datatype [DEFAULT value]\n    [, columnname datatype [DEFAULT value]] );\n\n-- subquery definition\nCREATE TABLE [schema.]table_name\nAS subquery;\n</code></pre></p> <p>Notes</p> <ul> <li>Tables are created with no data unless a Subquery is specified.<ul> <li>if the Subquery returns no rows, then the Table is still created with no data.</li> </ul> </li> <li>It it possible to add rows with the INSERT Statement.</li> <li>After creating a Table, it is possible to define additional columns, partitions and integrity constraints with the ALTER TABLE Statement.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT CREATE ANY TABLE TO user_name</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE TABLE</li> </ul>"},{"location":"SQL/DDL/#temporary-tables","title":"Temporary Tables","text":"<p>A Temporary Table holds data that exists only for the duration of a Transaction or session. Data in a Temporary Table is private to the session. Each session can only see and modify its own data.</p> <p>You cannot specify any FOREIGN KEY constraints on Temporary Tables.</p> <p>You can create either a Global Temporary Table or a Private Temporary Table. The following table shows the essential differences between them: | Characteristic             | Global Temporary Table                                                                 | Private Temporary Table                                                                          | |--------------------------------|--------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------| | Naming rules                   | Same as for permanent tables                                                               | Must be prefixed with ORA$PTT_                                                                       | | Visibility of table definition | All sessions                                                                               | Only the session that created the table                                                              | | Storage of table definition    | Disk                                                                                       | Memory only                                                                                          | | Types                          | Transaction-specific (ON COMMIT DELETE ROWS) or session-specific (ON COMMIT PRESERVE ROWS) | Transaction-specific (ON COMMIT DROP DEFINITION) or session-specific (ON COMMIT PRESERVE DEFINITION) |</p> Sources <ul> <li>Oracle Documentation - Overview of Temporary Tables</li> </ul>"},{"location":"SQL/DDL/#global-temporary-tables","title":"Global Temporary Tables","text":"<p>Use the CREATE GLOBAL TEMPORARY TABLE Statement to create a Global Temporary Table.</p> <p>The definition of a Global Temporary Table is visible to all sessions, but the data in a Global Temporary Table is visible only to the session that inserts the data into the table.</p> <p>The ON COMMIT Clause The ON COMMIT clause indicates if the data in the table is transaction-specific (the default) or session-specific, the implications of which are as follows:</p> <ul> <li><code>DELETE ROWS</code>: The database truncates the table after each commit.<ul> <li>Rows will also be deleted after a failed DDL Statement.</li> <li>N.B.: only certain failed DDL Statements will delete all rows.</li> </ul> </li> <li><code>PRESERVE ROWS</code>: The database truncates the table when you terminate the session.</li> </ul> <p>Global Temporary Tables Syntax <pre><code>CREATE GLOBAL TEMPORARY TABLE global_temp_table_name\n    (column_1 datatype,\n    column_2 datatype,\n    \u2026 column_n datatype)\n[ON COMMIT DELETE ROWS | PRESERVE ROWS];\n</code></pre></p> <p>Notes</p> <ul> <li>DDL operations (except TRUNCATE) are allowed on an existing temporary table only if no session is currently bound to that temporary table. If you rollback a transaction, the data you entered is lost, although the table definition persists.</li> <li>Indexes can be created on global temporary tables. They are also temporary and the data in the index has the same session or transaction scope as the data in the underlying table.</li> </ul>"},{"location":"SQL/DDL/#private-temporary-tables","title":"Private Temporary Tables","text":"<p>Private Temporary Tables are temporary database objects that are dropped at the end of a transaction or session.</p> <p>The ON COMMIT Clause The ON COMMIT clause indicates if the data in the table is transaction-specific (the default) or session-specific, the implications of which are as follows:</p> <ul> <li><code>DROP DEFINITION</code>: All data in the table is lost, and the table is dropped at the end of transaction.</li> <li><code>PRESERVE DEFINITION</code>: All data in the table is lost, and the table is dropped at the end of the session that created the table.</li> </ul> <p>Private Temporary Tables Syntax <pre><code>CREATE PRIVATE TEMPORARY TABLE ORA$PTT_priv_temp_table_name\n    (column_1 datatype,\n    column_2 datatype,\n    \u2026 column_n datatype)\n[ON COMMIT DROP DEFINITION | PRESERVE DEFINITION];\n</code></pre></p> <p>Notes</p> <ul> <li>Private Temporary Tables are stored in memory and each one is visible only to the session that created it.</li> <li>The metadata and content of a Private Temporary Table is visible only within the session that created the it.</li> </ul> <p>Restrictions</p> <ul> <li>Names of Private Temporary Tables must be prefixed according to the initialization parameter private_temp_table_prefix.</li> <li>You cannot create Indexes, Materialized Views on Private Temporary Tables.</li> <li>You cannot define column with default values.</li> <li>You cannot reference Private Temporary Tables in any permanent object (views or triggers).</li> <li>Only three DDL Statements are allowed: CREATE, DROP, and TRUNCATE.<ul> <li>Other DDL Statements will return <code>ORA-00942: table or view does not exist</code>.</li> </ul> </li> <li>You must be a User other than SYS to create Private Temporary Tables.</li> </ul>"},{"location":"SQL/DDL/#global-vs-private-temporary-tables","title":"Global vs. Private Temporary Tables","text":""},{"location":"SQL/DDL/#create-directory","title":"CREATE DIRECTORY","text":"<p>Syntax <pre><code>CREATE [OR REPLACE] DIRECTORY directory_name AS 'path_name';\n</code></pre></p> <ul> <li><code>OR REPLACE</code>: Specify OR REPLACE to re-create the directory database obejct if it already exists.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT CREATE ANY DIRECTORY TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - CREATE DIRECTORY</li> </ul>"},{"location":"SQL/DDL/#drop-directory","title":"DROP DIRECTORY","text":"<p>Use the DROP DIRECTORY Statement to remove a directory object from the Database.</p> <p>Syntax <pre><code>DROP DIRECTORY directory_name;\n</code></pre></p> <p>Privilege Restrictions</p> <ul> <li><code>GRANT DROP ANY DIRECTORY TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - DROP DIRECTORY</li> </ul>"},{"location":"SQL/DDL/#alter-table-add","title":"ALTER TABLE ... ADD","text":"<pre><code>ALTER TABLE tablename\n    ADD (columnname datatype, [DEFAULT] ...);\n</code></pre> <p>Examples</p> <pre><code>ALTER TABLE publisher\n    ADD (ext NUMBER(4));\n</code></pre>"},{"location":"SQL/DDL/#alter-table-modify","title":"ALTER TABLE ... MODIFY","text":"<pre><code>ALTER TABLE tablename\n    MODIFY (columnname datatype [DEFAULT], \u2026);\n</code></pre> <p>Examples</p> <pre><code>ALTER TABLE publisher\n    MODIFY (rating DEFAULT 'N');\n</code></pre>"},{"location":"SQL/DDL/#alter-table-drop","title":"ALTER TABLE ... DROP","text":"<p>Specify DROP to remove the column descriptor and the data associated with the target column from each row in the table. If you explicitly drop a particular column, then all columns currently marked UNUSED in the target table are dropped at the same time.</p> <p>When the column data is dropped:</p> <ul> <li>All indexes defined on any of the target columns are also dropped.</li> <li>All constraints that reference a target column are removed.</li> </ul> <p>Syntax - Dropping One Column <pre><code>ALTER TABLE tablename\n    DROP COLUMN columnname [CASCADE CONSTRAINTS];\n</code></pre></p> <p>Syntax - Dropping Multiple Columns <pre><code>ALTER TABLE tablename\n    DROP (columnname, \u2026) [CASCADE CONSTRAINTS];\n</code></pre></p>"},{"location":"SQL/DDL/#alter-table-set-unused","title":"ALTER TABLE ... SET UNUSED","text":"<p>Specify SET UNUSED to mark one or more columns as unused.</p> <p>Unused columns are treated as if they were dropped, even though their column data remains in the table rows. After a column has been marked UNUSED, you have no access to that column.</p> <p>A SELECT * query will not retrieve data from unused columns. In addition, the names and types of columns marked UNUSED will not be displayed during a DESCRIBE, and you can add to the table a new column with the same name as an unused column.</p> <p>Syntax <pre><code>ALTER TABLE tablename\n    SET UNUSED [COLUMN] (columnname);\n</code></pre></p>"},{"location":"SQL/DDL/#alter-table-drop-unused-columns","title":"ALTER TABLE ... DROP UNUSED COLUMNS","text":"<p>Specify DROP UNUSED COLUMNS to remove from the table all columns currently marked as unused. Use this statement when you want to reclaim the extra disk space from unused columns in the table. If the table contains no unused columns, then the statement returns with no errors.</p> <p>Syntax <pre><code>ALTER TABLE tablename\n    DROP UNUSED COLUMNS;\n</code></pre></p>"},{"location":"SQL/DDL/#alter-table-exchange-partition","title":"ALTER TABLE ... EXCHANGE PARTITION","text":"<pre><code>ALTER TABLE target_table EXCHANGE PARTITION partition_name\n  WITH TABLE source_table;\n</code></pre> <ul> <li>Data from the source_table goes into the target_table.</li> </ul>"},{"location":"SQL/DDL/#rename-statement","title":"RENAME Statement","text":"<pre><code>RENAME [schema.]old_object_name TO [schema.]new_object_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - RENAME</li> </ul>"},{"location":"SQL/DDL/#truncate-table","title":"TRUNCATE TABLE","text":"<pre><code>TRUNCATE TABLE [schema.]table_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - TRUNCATE TABLE</li> </ul>"},{"location":"SQL/DDL/#drop-table","title":"DROP TABLE","text":"<p>This statement is used to move a Table to the recycle bin or to remove the table and all its data from the database entirely.</p> <p>Syntax <pre><code>DROP TABLE table_name [CASCADE CONSTRAINTS] [PURGE];\n</code></pre></p> <ul> <li><code>CASCADE CONSTRAINTS</code>: drop all referential integrity constraints that refer to primary and unique keys in the dropped table.</li> <li><code>PURGE</code>: drop the table and release the space associated with it.</li> </ul> <p>After a successful DROP TABLE\u2026</p> <ul> <li>An uncommited transaction is automatically committed.</li> <li>All indexes and constraints defined on the table are also dropped.</li> <li>The dropped table may be moved to the Recycle Bin.</li> <li>The dropped table cannot be recovered using the ROLLBACK command.</li> <li>Sequences used in the dropped table do remain valid.</li> </ul> Sources <ul> <li>Oracle Documentation - DROP TABLE</li> </ul>"},{"location":"SQL/DDL/#purge-statement","title":"PURGE Statement","text":"<p>The PURGE Statement is used to:</p> <ul> <li>remove a table or index from your Recycle Bin and release all of the space associated with the object;</li> <li>remove part or all of a dropped tablespace or tablespace set from the recycle bin;</li> <li>remove the entire Recycle Bin.</li> </ul> <p>Syntax <pre><code>PURGE {\nTABLE table_name |\nINDEX idx_name |\nTABLESPACE tablespace_name |\nRECYCLEBIN\nDBA_RECYCLEBIN };\n</code></pre></p> <p>Notes</p> <ul> <li>You cannot recover an object after it is purged.</li> <li>See the contents of the Recycle Bin with the following query: <pre><code>SELECT * FROM RECYCLEBIN;\n</code></pre></li> </ul> Sources <ul> <li>Oracle Documentation - PURGE</li> </ul>"},{"location":"SQL/DDL/#add-a-primary-key-constraint-to-existing-table","title":"Add a PRIMARY KEY Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] PRIMARY KEY (column_name);\n</code></pre>"},{"location":"SQL/DDL/#add-a-foreign-key-constraint-to-existing-table","title":"Add a FOREIGN KEY Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] FOREIGN KEY (column_name)\n    REFERENCES referencedtablename (referencedcolumnname);\n</code></pre>"},{"location":"SQL/DDL/#add-a-unique-constraint-to-existing-table","title":"Add a UNIQUE Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] UNIQUE (column_name);\n</code></pre>"},{"location":"SQL/DDL/#add-a-check-constraint-to-existing-table","title":"Add a CHECK Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    ADD [CONSTRAINT constraint_name] CHECK (condition);\n</code></pre>"},{"location":"SQL/DDL/#add-a-not-null-constraint-to-existing-table","title":"Add a NOT NULL Constraint to Existing Table","text":"<pre><code>ALTER TABLE table_name\n    MODIFY (column_name [CONSTRAINT constraint_name] NOT NULL);\n</code></pre>"},{"location":"SQL/DDL/#enabling-constraints","title":"Enabling Constraints","text":"<pre><code>ALTER TABLE table_name\n    DISABLE CONSTRAINT constraint_name;\n\nALTER TABLE table_name\n    ENABLE CONSTRAINT constraint_name;\n</code></pre>"},{"location":"SQL/DDL/#dropping-constraints","title":"Dropping Constraints","text":"<pre><code>ALTER TABLE table_name\n    DROP PRIMARY KEY | UNIQUE (column_name) | CONSTRAINT constraint_name;\n</code></pre>"},{"location":"SQL/DML/","title":"DML Statements","text":"<p>Data Manipulation Language (DDL) statements access and manipulate data in existing schema objects.</p> <p>DML Statements do not implicitly commit the current transaction.</p> <p>The DML Statements are:</p> <ul> <li><code>CALL</code></li> <li><code>DELETE</code></li> <li><code>EXPLAIN PLAN</code></li> <li><code>INSERT</code></li> <li><code>LOCK TABLE</code></li> <li><code>MERGE</code></li> <li><code>SELECT</code></li> <li><code>UPDATE</code></li> </ul> Sources <ul> <li>Oracle Documentation - Data Manipulation Language (DML) Statements</li> </ul>"},{"location":"SQL/DML/#insert","title":"INSERT","text":"<p>INSERT allows to add rows to a Table, the base table of a View or a partition of a partitioned Table.</p> <p>There are two types of INSERTs, Conventional and Direct-Path:</p> <ul> <li>Conventional: Oracle Database reuses free space in the Table into which you are inserting and maintains integrity constraints.</li> <li>Direct-Path: Oracle Database appends the inserted data after existing data in the Table. Data is written directly into data files.<ul> <li>attempting to execute multiple Direct-Path INSERTs in one Transaction returns an error</li> <li>Direct-Path INSERTs cannot be executed on Tables that have Triggers or Referential Integrity Constraints</li> </ul> </li> </ul> <p>Syntax <pre><code>INSERT [hint]\nINTO {[schema.]table_name | subquery}\n[PARTITION (partition_name)]\n    [column_1, column_n]\n{VALUES (column_1_value, column_n_value) | subquery};\n</code></pre></p> <ul> <li>hint: specify a comment that passes instructions to the optimizer on choosing an execution plan for the statement.</li> <li>schema: specify the schema containing the Table, View or Materialized View.</li> <li>table_name | subquery: specify the name of the Object or the Subquery into which rows are to be inserted.</li> <li><code>PARTITION (partition_name)</code>: specify the name or partition key value of the partition or subpartition within table_name.</li> <li>column_1, column_n: optional column list.</li> <li><code>VALUES (column_1_value, column_n_value) | subquery}</code>: values you're inserting into the column list. Instead of specifying the values manually, you can also use a Subquery to insert rows into a table.</li> </ul> <p>Notes</p> <ul> <li>Using the <code>APPEND</code> hint activates Direct-Path INSERT<ul> <li>see more details about Hints</li> </ul> </li> <li>If the column list is omitted, then the VALUES clause must specify values for all columns in the Table.</li> <li>If the specified partition_name does not exist, the database returns an error.</li> <li>If a View was created using the <code>WITH CHECK OPTION</code> clause, then you can insert into the View only rows that satisfy the defining query of the View.</li> <li>You cannot specify <code>DEFAULT</code> in the VALUES clause when inserting into a View.</li> <li>column_1_value can be a Subquery, but must return only 1 row.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - INSERT Statement</li> <li>Oracle Live SQL - Inserting Data through a Subquery</li> </ul> Sources <ul> <li>Oracle Documentation - INSERT</li> </ul>"},{"location":"SQL/DML/#insert-all","title":"INSERT ALL","text":"<p>Unconditional INSERT ALL When using an unconditional INSERT ALL statement, each row produced by the driving query results in a new row in each of the tables listed in the INTO clauses.</p> <p>Unconditional INSERT ALL Syntax <pre><code>INSERT ALL\nINTO table_1 (column_a, column_b) VALUES (column_1, column_2)\n    INTO table_2 (column_c, column_d) VALUES (column_1, column_2)\n    INTO table_3 (column_e, column_f) VALUES (column_1, column_2)\nSELECT column_1[, column_n]\nFROM source_table;\n</code></pre></p> <p>Conditional INSERT ALL In a conditional INSERT ALL statement, conditions can be added to the INTO clauses, which means the total number of rows inserted may be less that the number of source rows multiplied by the number of INTO clauses.</p> <p>Conditional INSERT ALL Syntax <pre><code>INSERT ALL\n    WHEN condition THEN\n        INTO table_1 (column_a, column_b) VALUES (column_1, column_2)\n    WHEN condition THEN\n        INTO table_2 (column_c, column_d) VALUES (column_1, column_2)\n    WHEN condition THEN\n        INTO table_3 (column_e, column_f) VALUES (column_1, column_2)\nSELECT column_1, column_2\nFROM source_table;\n</code></pre></p> <p>Restrictions</p> <ul> <li>Multitable inserts can only be performed on Tables, not on views or Materialized Views.</li> <li>Sequences cannot be used in the multitable insert statement. It is considered a single statement, so only one sequence value will be generated and used for all rows.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - Unconditional INSERT ALL</li> <li>Oracle Live SQL - Conditional INSERT ALL</li> </ul> Sources <ul> <li>Oracle Documentation - INSERT: multi_table_insert</li> </ul>"},{"location":"SQL/DML/#merge","title":"MERGE","text":"<p>The MERGE Statement selects data from one or more source tables and updates or inserts it into a target table.</p> <p>The MERGE statement allows you to specify a condition to determine whether to update data from or insert data into the target table.</p> <p>Syntax <pre><code>MERGE INTO target_table\nUSING source_table\nON (search_condition)\n    WHEN MATCHED THEN\n        UPDATE SET column_1 = value_1, column_2 = value_2, ...\n        WHERE [condition]\n        [DELETE WHERE condition]\n    WHEN NOT MATCHED THEN\n        INSERT (column_1, column_2, ...)\n        VALUES (value_1, value_2, ...)\n        WHERE [condition];\n</code></pre></p> <ul> <li>target_table: Table on which you want to update or insert into.</li> <li>source_table: Source of data to be updated or inserted.</li> <li>search_condition: Search condition upon which the merge operation either updates or inserts.</li> </ul> <p>For each row in the target table, Oracle evaluates the search condition:</p> <ul> <li>If the result is true, then Oracle updates the row with the corresponding data from the source table.</li> <li>In case the result is false for any rows, then Oracle inserts the corresponding row from the source table into the target table.</li> </ul> <p>Examples</p> <p><pre><code>MERGE INTO author a\nUSING customers c\nON (a.authorid = TO_CHAR(c.customer#))\n    WHEN MATCHED THEN\n        UPDATE SET a.lname = c.lastname, a.fname = c.firstname\n    WHEN NOT MATCHED THEN\n        INSERT (a.authorid, a.lname, a.fname)\n        VALUES (c.customer#, c.lastname, c.firstname);\n</code></pre> For each row in Author: - If authorid and customer# are equal, then update the Author's lastname (a.lname) and first name (a.fname) with the Customer's last name (c.lastname) and first name (c.firstname). - Otherwise inserts a new row in Author with Customer's data.</p> Sources <ul> <li>Oracle Documentation - MERGE</li> </ul>"},{"location":"SQL/advanced/","title":"Advanced Concepts","text":""},{"location":"SQL/advanced/#arithmetic-operations-on-dates","title":"Arithmetic Operations on Dates","text":"<p>Rules</p> <ul> <li>Operations between DATE value and Binary Operators<ul> <li>+ Addition: adds days to a DATE value; DATE value must be at the left-side.</li> <li>- Subtraction: subtracts days to a DATE value; DATE value must be at the left-side.</li> <li>* Multiplication: NOT ALLOWED</li> <li>/ Division: NOT ALLOWED</li> </ul> </li> <li>Operations between two DATE values<ul> <li>+ Addition: NOT ALLOWED</li> <li>- Subtraction: return number of days between the two Dates</li> <li>* Multiplication: NOT ALLOWED</li> <li>/ Division: NOT ALLOWED</li> </ul> </li> </ul> <p>Supposing SYSDATE is 28-NOV-22:</p> <ul> <li><code>SYSDATE - 1</code> \u2192 27-NOV-22</li> <li><code>1 - SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE + 1</code> \u2192 29-NOV-22</li> <li><code>1 + SYSDATE</code> \u2192 29-NOV-2022</li> <li><code>SYSDATE * 1</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>1 * SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE / 1</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>1 / SYSDATE</code> \u2192 <code>ORA-00932: inconsistent datatypes</code></li> <li><code>SYSDATE - TO_DATE('27-NOV-2022')</code> \u2192 1<ul> <li>Calculates number of days between two dates.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - Datetime/Interval Arithmetic</li> </ul>"},{"location":"SQL/advanced/#rrrr-vs-yyyy","title":"RRRR vs. YYYY","text":"<ul> <li>YYYY: first two digits will always be current century (99 \u2192 2099).</li> <li>RRRR: first two digits depend on range:<ul> <li>years in range 00 to 49 are assumed to be in current century (21 \u2192 2021)</li> <li>years in range 50 to 99 are assumed to be in the previous century (99 \u2192 1999)</li> </ul> </li> </ul> <p>There's no difference when working with 4-digits years. \"2022\" will always be 2022 no matter if you're using YYYY or RRRR as format mask.</p>"},{"location":"SQL/advanced/#nls_date_format","title":"NLS_DATE_FORMAT","text":"<p><code>NLS_DATE_FORMAT</code> specifies the default date format to use with the <code>TO_CHAR</code> and <code>TO_DATE</code> functions. The default value of this parameter is determined by <code>NLS_TERRITORY</code>.</p> <p>The value of this parameter can be any valid date format mask, and the value must be surrounded by double quotation marks. For example: <pre><code>NLS_DATE_FORMAT = \"MM/DD/YYYY\"\n</code></pre></p> <p>Current Date Mask <pre><code>SELECT VALUE\nFROM NLS_SESSION_PARAMETERS\nWHERE PARAMETER = 'NLS_DATE_FORMAT';\n</code></pre></p> Sources <ul> <li>Oracle Documentation - NLS_DATE_FORMAT</li> </ul>"},{"location":"SQL/advanced/#substitution-variables","title":"Substitution Variables","text":"<p>Syntax <pre><code>-- Definining a new Substitution Variables:\nDEFINE variable_name = variable_value;\n\n-- Confirming the variable definition:\nDEFINE variable_name;\n\n-- Listing all Substitution Variables:\nDEFINE;\n\n-- Deleting a Substitution Variables:\nUNDEFINE variable_name;\n\n-- Referencing to a Substitution Variables:\nSELECT &amp;variable_name_1\nFROM &amp;variable_name_2;\n</code></pre></p> <p>Notes about Substitution Variables</p> <ul> <li>You can use Substitution Variables anywhere in SQL and SQL*Plus commands.</li> <li>When SQL*Plus encounters an undefined Substitution Variables in a command, SQL*PLUS prompts you for the value.</li> </ul> <p>SET Command</p> <ul> <li>After you enter a value at the prompt, SQL*Plus lists the line containing the Substitution Variable twice: once before substituing the value you enter and once after substitution.</li> <li>You can suppress this listing by setting the <code>SET</code> command variable <code>VERIFY</code> to <code>OFF</code>.</li> </ul> <p>Example</p> <p></p> <p>Difference between \"&amp;\" and \"&amp;&amp;\" If a single ampersand prefix is used with an undefined variable, the value you enter at the prompt is not stored. Immediately after the value is substituted in the statement the variable is discarded and remains undefined.\\ If the variable is referenced twice, even in the same statement, then you are prompted twice.</p> <p>Example\\ </p> <p>If a double ampersand reference causes SQL*Plus to prompt you for a value, then SQL*Plus defines the variable as that value (that is, the value is stored until you exit). Any subsequent reference to the variable (even in the same command) using either \"&amp;\" or \"&amp;&amp;\" substitutes the newly defined value. SQL*Plus will not prompt you again:</p> <p>Example</p> <p></p> Sources <ul> <li>Oracle Documentation - Using Substitution Variables</li> <li>Oracle Documentation - DEFINE</li> <li>Oracle Documentation - UNDEFINE</li> <li>Oracle Documentation - SET VERIFY</li> </ul>"},{"location":"SQL/advanced/#pivot","title":"PIVOT","text":"<p>The <code>PIVOT</code> clause allows you to write a cross-tabulation query. This means that you can aggregate your results and rotate rows into columns.</p> <p>Syntax <pre><code>SELECT * FROM\n(\n    SELECT column1, column2\n    FROM tables\n    WHERE condition\n)\nPIVOT\n(\n    aggregate_function(column2)\n    FOR column2\n    IN (expression1, expression2, ... expression_n) | subquery\n)\nORDER BY expression [ASC | DESC];\n</code></pre></p> <p>Example <pre><code>-- Given the data from this query:\nSELECT * FROM CO.CUSTOMER_ORDER_PRODUCTS;\n\n-- Executing the following query returns the total number of Orders Cancelled and Completed for each Customer:\nSELECT * FROM\n(\nSELECT CUSTOMER_ID, FULL_NAME, ORDER_STATUS\nFROM CO.CUSTOMER_ORDER_PRODUCTS\n)\nPIVOT\n(\n    COUNT(ORDER_STATUS)\n    FOR ORDER_STATUS IN ('CANCELLED', 'COMPLETE')\n)\nORDER BY FULL_NAME;\n</code></pre></p> Oracle Live SQL <ul> <li>PIVOT</li> </ul> Sources <ul> <li>Oracle Documentation - SELECT: pivot_clause</li> </ul>"},{"location":"SQL/advanced/#with-function","title":"WITH FUNCTION","text":"<p><code>WITH_FUNCTION</code> clause allows to use temporary functions without physically creating them.</p> <p>Syntax <pre><code>WITH FUNCTION &lt;function_name&gt; (&lt;parameters&gt;) RETURN &lt;datatype&gt;\nIS\n    [declaration_statements]\nBEGIN\n    &lt;function_statements&gt;\n    RETURN &lt;variable&gt;;\nEND;\n&lt;SELECT statement&gt;\n</code></pre></p> <p>Example <pre><code>WITH FUNCTION get_value (in_value IN number) RETURN NUMBER\nIS\n    final_value NUMBER := 2;\nBEGIN\n    final_value := in_value * final_value;\n    RETURN final_value;\nEND;\nSELECT get_value(2)\nFROM dual;\n</code></pre></p>"},{"location":"SQL/basics/","title":"Basic Concepts","text":""},{"location":"SQL/basics/#select-statement","title":"SELECT Statement","text":"<pre><code>SELECT      [DISTINCT | UNIQUE] (, columnname [AS alias], \u2026)\nFROM        tablename\n[WHERE      condition]\n[GROUP BY   group_by_expression]\n[HAVING     group_condition]\n[ORDER BY   columnname];\n</code></pre> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#column-aliases","title":"Column Aliases","text":"<p>Column Aliases can be used to create a temporary name for columns or expressions.</p> <p>Syntax <pre><code>column_name [AS] alias_name\n</code></pre></p> <p>Examples</p> <ul> <li><code>first_name AS Employee</code></li> <li><code>first_name Employee</code></li> <li><code>first_name || ' ' || last_name AS \"Employee Details\"</code></li> <li><code>first_name \"Employee's First Name\"</code></li> </ul> <p>Restrictions</p> <ul> <li>If alias_name contains spaces, you must enclose alias_name in quotes.</li> </ul> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#distinct","title":"DISTINCT","text":"<p>The DISTINCT clause is used to remove duplicates from the result set. This clause can only be used within SELECT Statements.</p> <p>Syntax <pre><code>SELECT DISTINCT column_name\nFROM table_name;\n</code></pre> Notes about DISTINCT</p> <ul> <li>When only one expression is provided in the DISTINCT clause, the query will return the unique values for that expression.</li> <li>When more than one expression is provided in the DISTINCT clause, the query will retrieve unique combinations for the expressions listed.</li> <li>DISTINCT does not ignore NULL values. If there are multiple NULL values, it will return only one NULL.</li> <li>UNIQUE is a synonym of DISTINCT.</li> <li>You cannot specify DISTINCT if the SELECT list contains LOB columns.</li> </ul> Sources <ul> <li>Oracle Documentation - SELECT</li> </ul>"},{"location":"SQL/basics/#query-processing-order-order-of-execution","title":"Query Processing Order / Order of Execution","text":"<pre><code>FROM\nWHERE\nGROUP BY\nSELECT\nHAVING\nORDER BY\n</code></pre> Sources <ul> <li>Oracle SQL and PL/SQL Optimization for Developers - Query Processing Order</li> </ul>"},{"location":"SQL/basics/#alternative-quote-operator-q","title":"Alternative Quote Operator (q)","text":"<p>Syntax <pre><code>SELECT  q'{text}', column_1, ..., column_n\nFROM    tablename;\n</code></pre></p> Examples <ul> <li>Oracle Live SQL - Alternative Quote Operator</li> </ul>"},{"location":"SQL/basics/#operator-and-condition-precedence","title":"Operator and Condition Precedence","text":"<ul> <li>*, /*</li> <li>+, -</li> <li>=, !=, &lt;, &gt;, &lt;=, &gt;=</li> <li><code>IS [NOT] NULL</code>, <code>LIKE</code>, <code>[NOT] BETWEEN</code>, <code>[NOT] IN</code>, <code>EXISTS</code>, <code>IS OF</code></li> <li>NOT</li> <li>AND</li> <li>OR</li> </ul> Sources <ul> <li>Oracle Documentation - Condition Precedence</li> <li>Oracle Documentation - Operator Precedence</li> </ul>"},{"location":"SQL/basics/#describe","title":"DESCRIBE","text":"<p>Syntax <pre><code>DESC[RIBE] [schema.]object;\n</code></pre></p> <ul> <li>object can be:<ul> <li>a Table</li> <li>a View</li> <li>a Synonym</li> <li>a PL/SQL Type</li> <li>a PL/SQL Procedure</li> <li>a PL/SQL Function</li> <li>a PL/SQL Package</li> </ul> </li> </ul> <p>Command Output The description for object contains the following information:</p> <ul> <li>each column's name</li> <li>whether or not null values are allowed (NULL or NOT NULL) for each column</li> <li>datatype of columns and their precision (and scale, if any, for a numeric column)</li> </ul> Examples <ul> <li>Oracle Live SQL - DESC</li> </ul> Sources <ul> <li>Oracle Documentation - DESCRIBE</li> </ul>"},{"location":"SQL/basics/#default-clause","title":"DEFAULT Clause","text":"<p>This clause lets you specify a value to be assigned to the column if a subsequent INSERT statement omits a value for the column.</p> <p>Syntax <pre><code>CREATE TABLE [schema.]table_name (\n    column_1 datatype DEFAULT value\n);\n</code></pre> - <code>DEFAULT value</code>: value must be the same datatype as the column definition (or must be implicitly convertible). </p> <p>Notes</p> <ul> <li>value cannot be a subquery.</li> <li>value can be a Sequence's CURRVAL or NEXTVAL.</li> <li>If the Sequence is dropped, the Database will return an error for all the subsequent INSERTs.</li> <li>value cannot be an user-defined PL/SQL Function.</li> </ul> Examples <ul> <li>Oracle Live SQL - DEFAULT Clause</li> <li>Oracle Live SQL - DEFAULT Clause - Using a Sequence</li> </ul> Sources <ul> <li>Oracle Documentation - DEFAULT</li> </ul>"},{"location":"SQL/constraints/","title":"Constraints","text":"<p>Constraints are used to define an integrity constraint \u2014 a rule that restricts the values in a Database.</p> <ul> <li><code>NOT NULL</code> Constraint</li> <li>Unique Constraint</li> <li>Primary Key Constraint</li> <li>Foreign Key Constraint</li> <li>Check Constraint</li> </ul> <p>Constraints can appear in the following statements:</p> <ul> <li><code>CREATE TABLE</code></li> <li><code>ALTER TABLE</code></li> <li><code>CREATE VIEW</code></li> <li><code>ALTER VIEW</code></li> </ul> <p>And they can be defined in two ways:</p> <ul> <li>inline: as part of the definition of an individual column</li> <li>out-of-line: as part of the Table definition</li> </ul> <p>View Constraints It is possible to create Unique, Primary Key and Foreign Key Constraints on Views, but only if the <code>DISABLE NOVALIDATE</code> clause is specified.</p> <p>General Restrictions</p> <p>These restrictions apply to all Primary Key/Foreign Key/Unique Constraints.</p> <ul> <li>Constraints cannot be created on the following column datatypes:<ul> <li><code>LOB</code></li> <li><code>LONG</code></li> <li><code>LONG RAW</code></li> <li><code>VARRAY</code></li> <li><code>NESTED TABLE</code></li> <li><code>OBJECT</code></li> <li><code>REF</code></li> <li><code>TIMESTAMP WITH TIME ZONE</code></li> <li>user-defined type</li> </ul> </li> </ul>"},{"location":"SQL/constraints/#unique-constraint","title":"UNIQUE Constraint","text":"<p>A UNIQUE Constraint prohibits multiple rows from having the same value in the same column or combination of columns but allows some values to be NULL.</p> <p>Composite Unique Key More than one column can be part of a UNIQUE Constraint: that means the combination of the specified columns will be unique. A Composite Unique Key can only be specified out of line.</p> <p>Syntax <pre><code>-- inline syntax\nCREATE TABLE table_name(\n    column_name datatype [CONSTRAINT constraint_name] UNIQUE\n);\n\n-- out of line syntax\nCREATE TABLE table_name(\n    column_name datatype,\n    [column_name_n datatype,]\n    [CONSTRAINT constraint_name] UNIQUE (column_name)\n);\n</code></pre></p> <p>Syntax - Composite Unique Key <pre><code>CREATE TABLE table_name(\n    column_name_1 datatype,\n    [column_name_n datatype,]\n    [CONSTRAINT constraint_name] UNIQUE (column_name_1, column_name_2)\n);\n</code></pre></p> <p>Notes</p> <ul> <li>When defining a UNIQUE Constraint on one or more columns, Oracle automatically creates an index on the column(s).</li> <li>To improve queries performance, it is recommended to create an UNIQUE INDEX instead of a UNIQUE Constraint.</li> <li>Despite the UNIQUE constraint allowing multiple NULL values, if only one column of a Composite Unique Key has a NULL value, then the other column must have a different value. See this example.</li> </ul> <p>Restrictions</p> <ul> <li>A Primary Key column cannot be part of a UNIQUE Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Unique Constraints</li> </ul>"},{"location":"SQL/constraints/#not-null-constraint","title":"NOT NULL Constraint","text":"<p>A NOT NULL constraint prohibits a column from containing nulls.</p> <p>Syntax <pre><code>CREATE TABLE table_name(\n    column_name_1 datatype [NULL | NOT NULL]\n);\n</code></pre></p> <p>Notes</p> <ul> <li>A NOT NULL Constraint must be defined inline. </li> <li>It is possible to specify NULL to explicitly permit a column to contain NULLs.</li> </ul> <p>Restrictions</p> <ul> <li>You cannot specify NOT NULL in a View Constraint. </li> </ul> Sources <ul> <li>Oracle Documentation - NOT NULL Constraints</li> </ul>"},{"location":"SQL/constraints/#primary-key-constraint","title":"PRIMARY KEY Constraint","text":"<p>A Primary Key constraint designates a column as the Primary Key of a Table or View.</p> <p>A Primary Key constraint cannot:</p> <ul> <li>contain duplicated values</li> <li>contain NULL values</li> </ul> <p>Syntax <pre><code>CREATE TABLE table_name(\n    column_name datatype [CONSTRAINT constraint_name] PRIMARY KEY\n);\n</code></pre></p> <p>Syntax - out of line <pre><code>CREATE TABLE table_name(\n    column_name datatype,\n    [column_name_n datatype]\n    [CONSTRAINT constraint_name] PRIMARY KEY (column_name)\n);\n</code></pre></p> <p>Notes</p> <ul> <li>Multiple columns can be part of a Primary Key (Composite Primary Key).</li> <li>If no Index is defined on the PRIMARY KEY columns, then Oracle automatically creates an Unique Index.<ul> <li>If an Unique Index is already defined on the Primary Key columns, then no new Index will be created and when the Primary Key Constraint is dropped, the Index will stay on the columns.</li> <li>Otherwise, the related Index will be dropped as well.</li> </ul> </li> </ul> <p>Restrictions</p> <ul> <li>A Table or View can have only one Primary Key.</li> <li>A Primary Key column cannot be part of a UNIQUE Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Primary Key Constraints</li> </ul>"},{"location":"SQL/constraints/#foreign-key-constraints","title":"FOREIGN KEY Constraints","text":"<p>A Foreign Key Constraint (also called a Referential Integrity Constraint) designates a column as the Foreign Key and establishes a relationship between that Foreign Key and a specified Primary or Unique key, called the Referenced Key.</p> <p>The Table or View containing the Foreign Key is called the child object, and the Table or View containing the referenced key is called the parent object.</p> <p>Syntax <pre><code>CREATE TABLE parent_table_name(\n    parent_column_name datatype {PRIMARY KEY | UNIQUE}\n);\n\n-- out of line declaration\nCREATE TABLE child_table_name(\n    child_column_name datatype,\n    [column_name_n datatype]\n    [CONSTRAINT constraint_name] FOREIGN KEY (child_column_name) REFERENCES parent_table_name (parent_column_name) [ON DELETE {CASCADE | SET NULL}]\n);\n\n-- inline declaration\nCREATE TABLE child_table_name(\n    child_column_name datatype [CONSTRAINT constraint_name] REFERENCES parent_table_name (parent_column_name) [ON DELETE {CASCADE | SET NULL}]\n);\n</code></pre></p> <p>ON DELETE Clause The ON DELETE clause lets you determine how Oracle Database automatically maintains referential integrity if you remove a Referenced Primary or Unique Key value:</p> <ul> <li><code>CASCADE</code>: remove dependent Foreign Key values (will remove the entire row)</li> <li><code>SET NULL</code>: convert dependent Foreign Key values to NULL<ul> <li>This cannot be specified for a Virtual Column</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The Foreign Key and the Referenced Key can be in the same Table or View.</li> <li>Multiple columns can be part of a Foreign Key (Composite Foreign Key).</li> <li>A single column can be part of more than one Foreign Key.</li> <li>A Table can have multiple Foreign Keys.</li> <li>A Primary Key can also be a Foreign Key.</li> </ul> <p>Restrictions</p> <ul> <li>The Referenced Unique or Primary Key constraint on the Parent Table or View must already be defined.</li> <li>The ON DELETE Clause cannot be specified for a View Constraint.</li> </ul> Sources <ul> <li>Oracle Documentation - Foreign Key Constraints</li> </ul>"},{"location":"SQL/data-dictionary/","title":"Data Dictionary","text":"<p>The Data Dictionary is a read-only set of tables that provides information about the database. A data dictionary contains:</p> <ul> <li>The definitions of all schema objects in the database (tables, views, indexes, clusters, synonyms, sequences, procedures, functions, packages, triggers, and so on)</li> <li>How much space has been allocated for, and is currently used by, the schema objects</li> <li>Default values for columns</li> <li>Integrity constraint information</li> <li>The names of Oracle users</li> <li>Privileges and roles each user has been granted</li> <li>Auditing information, such as who has accessed or updated various schema objects</li> <li>Other general database information</li> </ul> <p>The data dictionary is structured in tables and views, just like other database data.</p>"},{"location":"SQL/data-dictionary/#prefixes-of-data-dictionary-views","title":"Prefixes of Data Dictionary Views","text":"<ul> <li><code>USER_</code> \u2192 Objects owned by the current user accessing the view.</li> <li><code>ALL_</code> \u2192 Objects owned by any user in the Database to which the current user has privileges.</li> <li><code>DBA_</code> \u2192 All objects in the Database.</li> <li><code>V_$</code> (views) or <code>V$</code> (public synonyms) \u2192 Dynamic Pperformance Views, each of which has a public synonym counterpart. Stores information about the local database instance.</li> <li><code>GV_$</code> (views) or <code>GV$</code> (public synonyms) \u2192 Global Dynamic Performance Views.</li> </ul>"},{"location":"SQL/data-dictionary/#dynamic-performance-views","title":"Dynamic Performance Views","text":"<p>Dynamic Performance Views display information about current database activity in real time. They are maintaned automatically by the system and are available for querying with some limitations.</p> <p>Dynamic Performance Views start with the prefix V_$ or their public synonym counterpart starts with V$.</p> <p>List of Dynamic Performance Views</p> <ul> <li><code>V$DATABASE</code>: includes information about the Database itself, including the database name, the date created, etc.</li> <li><code>V$INSTANCE</code>: includes the instance name, host name, etc.</li> <li><code>V$PARAMETER</code>: current settings for system parameters such as NLS_LANGUAGE, NLS_DATE_LANGUAGE, NLS_CURRENCY, etc.</li> <li><code>V$SESSION</code>: current settings for each individual user session, showing active connections, login times, etc.</li> <li><code>V$RESERVED_WORDS</code>: current list of reserved words, including information indicating whether the keyword is always reserved, and if not, under what circumstances it is reserved.</li> <li><code>V$OBJECT_USAGE</code>: useful for monitoring the usage of INDEX objects</li> <li><code>V$TIMEZONE_NAMES</code>: includes two columns:<ul> <li><code>TZNAME</code>: time zone region</li> <li><code>TZABBREV</code>: time zone abbreviation</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - Overview of the Dynamic Performance Views</li> </ul>"},{"location":"SQL/data-dictionary/#checking-privileges-in-the-data-dictionary","title":"Checking Privileges in the Data Dictionary","text":"<p>Privileges can be inspected using the following views:</p> <ul> <li><code>USER_SYS_PRIVS</code>: System privileges granted to the current user</li> <li><code>USER_TAB_PRIVS</code>: Granted privileges on objects for which the user is the owner, grantor or grantee.</li> <li><code>USER_ROLE_PRIVS</code>: Roles granted to the current user.</li> <li><code>DBA_SYS_PRIVS</code>: System privileges granted to users and roles.</li> <li><code>DBA_TAB_PRIVS</code>: All grants on objects in the Database.</li> <li><code>DBA_ROLE_PRIVS</code>: Role granted to users and roles.</li> <li><code>ROLE_SYS_PRIVS</code>: System privileges granted to roles.</li> <li><code>ROLE_TAB_PRIVS</code>: Table privileges granted to roles.</li> <li><code>SESSION_PRIVS</code>: Session privileges that the user currenlty has set.</li> </ul>"},{"location":"SQL/data-dictionary/#user_catalog","title":"USER_CATALOG","text":"<p>The USER_CATALOG view displays a summary listing of tables, views, synonym, and sequences owned by the user. There are two columns in USER_CATALOG:</p> <ul> <li><code>TABLE_TYPE</code>: indicates the Database Object (SEQUENCE, TABLE, VIEW, etc.).</li> <li><code>TABLE_NAME</code>: name of the Table.</li> </ul> Sources <ul> <li>Oracle Documentation - USER_CATALOG</li> </ul>"},{"location":"SQL/data-dictionary/#user_objects","title":"USER_OBJECTS","text":"<p>The USER_OBJECTS view contain information about all objects owned by the user.</p> Sources <ul> <li>Oracle Documentation - USER_OBJECTS</li> </ul>"},{"location":"SQL/data-dictionary/#user_synonyms","title":"USER_SYNONYMS","text":"<p>The USER_SYNONYMS View describes the private synonyms (synonyms owned by the current user). Its columns (except for OWNER) are the same as those in ALL_SYNONYMS.</p> Sources <ul> <li>Oracle Documentation - USER_SYNONYMS</li> </ul>"},{"location":"SQL/data-dictionary/#user_tables","title":"USER_TABLES","text":"<p>The USER_TABLES view shows detailed information about the Tables owned by current session account.</p> <p>Some of the columns include:</p> <ul> <li><code>TABLE_NAME</code>: Name of the Table.</li> <li><code>STATUS</code>: Indicates whether the Table is currently valid and therefore available for use.</li> <li><code>ROW_MOVEMENT</code>: Indicates whether ROW MOVEMENT has been enabled for the Table.</li> <li><code>AVG_ROW_LEN</code>: Average length of the rows currently stored in the Table.</li> </ul> Sources <ul> <li>Oracle Documentation - USER_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#all_tables","title":"ALL_TABLES","text":"<p>The ALL_TABLES view shows detailed information about the Tables to which the current User has privileges, regardless of owner.</p> Sources <ul> <li>Oracle Documentation - ALL_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#dba_tables","title":"DBA_TABLES","text":"<p>The DBA_TABLES view shows detailed information about the Tables in the entire Database, regardless of owner or Table privileges.</p> Sources <ul> <li>Oracle Documentation - DBA_TABLES</li> </ul>"},{"location":"SQL/data-dictionary/#all_constraints","title":"ALL_CONSTRAINTS","text":"<p>ALL_CONSTRAINTS describes constraint definitions on tables accessible to the current user.</p> <p>Columns</p> <ul> <li><code>OWNER</code>: owner of the constraint</li> <li><code>CONSTRAINT_NAME</code>: constraint name</li> <li><code>CONSTRAINT_TYPE</code>: type of constraint (full list below)</li> <li><code>TABLE_NAME</code>: table on which the constraint is defined</li> <li><code>SEARCH_CONDITION</code>: text of search condition for a CHECK constraint</li> <li><code>R_OWNER</code>: owner of the parent constraint</li> <li><code>R_CONSTRAINT_NAME</code>: name of parent constraint (only for Foreign Keys)</li> <li><code>DELETE_RULE</code>: delete rule for a referential constraint (CASCADE, SET NULL, NO ACTION)</li> <li><code>STATUS</code>: constraint status (ENABLED, DISABLED)</li> <li><code>DEFERRABLE</code>: indicates if the constraint is DEFERRABLE or NOT DEFERRABLE</li> <li><code>DEFERRED</code>: indicates if the constraint was initially DEFERRED or not (IMMEDIATE)</li> <li><code>VALIDATED</code>:<ul> <li>if STATUS=ENABLED, possible values are:<ul> <li>VALIDATED: all data in the table obeys the constraint</li> <li>NOT VALIDATED: alla data in the table may not obey the constraint</li> </ul> </li> <li>if STATUS=DISABLED, possible values are:<ul> <li>VALIDATED: all data obeys the constraint but the unique index on the constraint has been dropped.</li> <li>NOT VALIDATED: all data may not obey the constraint</li> </ul> </li> </ul> </li> <li><code>GENERATED</code>: indicates if the constraint name is user-generated (USER NAME) or system-generated (GENERATED NAME)</li> <li><code>BAD</code>: indicates whether this constraint specifies a century in an ambiguous manner (BAD) or not (NULL).<ul> <li>to resolve the issue, rewrite the constraint using the TO_DATE function with a four-digit year</li> </ul> </li> <li><code>RELY</code>: [...]</li> <li><code>LAST_CHANGE</code>: when the constraint was last enabled or disabled</li> <li><code>INDEX_OWNER</code>: name of the user owning the index</li> <li><code>INDEX_NAME</code>: name of the index (only for UNIQUE and Primary Key constraints)</li> <li><code>INVALID</code>: indicates if the constraint is INVALID or not (NULL).</li> <li><code>VIEW_RELATED</code>: indicated if the constraint depends on a view (DEPEND ON VIEW) or not</li> <li><code>ORIGIN_CON_ID</code>: [...]</li> </ul> <p>Constraint Types</p> <ul> <li>C \u2192 CHECK Constraint</li> <li>P \u2192 PRIMARY KEY Constraint</li> <li>U \u2192 UNIQUE Key</li> <li>R \u2192 Referential Integrity</li> <li>V \u2192 WITH CHECK OPTION, on a View</li> <li>O \u2192 WITH READ ONLY, on a View</li> <li>H \u2192 Hash Expression</li> <li>F \u2192 Constraint that involves a REF Column</li> <li>S \u2192 Supplemental Logging</li> </ul> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> </ul>"},{"location":"SQL/data-dictionary/#get-existing-constraints-on-a-table","title":"Get existing Constraints on a Table","text":"<pre><code>SELECT \n    constraint_name\n    , constraint_type\n    , search_condition\n    , r_constraint_name\n    , delete_rule\n    , status\nFROM all_constraints\nWHERE UPPER(table_name) = UPPER('tablename');\n</code></pre> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> </ul>"},{"location":"SQL/data-dictionary/#get-primary-key-details-about-table","title":"Get Primary Key details about Table","text":"<pre><code>SELECT\n    cols.table_name\n    , cols.column_name\n    , cols.position\n    , cons.status, cons.owner\nFROM\n    all_constraints cons\n    INNER JOIN all_cons_columns cols\n        ON cons.constraint_name = cols.constraint_name\n        AND cons.owner = cols.owner\nWHERE cons.constraint_type = 'P'\nAND UPPER(cols.table_name) = UPPER('table_name')\nORDER BY cols.table_name, cols.position;\n</code></pre> Sources <ul> <li>Oracle Documentation - ALL_CONSTRAINTS</li> <li>Oracle Documentation - ALL_CONS_COLUMNS</li> </ul>"},{"location":"SQL/data-dictionary/#get-current-date-format","title":"Get current Date format","text":"<pre><code>SELECT *\nFROM nls_session_parameters\nWHERE parameter = 'NLS_DATE_FORMAT';\n</code></pre> Sources <ul> <li>Oracle Documentation - NLS_SESSION_PARAMETERS</li> </ul>"},{"location":"SQL/data-dictionary/#get-list-of-updatable-columns-on-a-view","title":"Get List of updatable Columns on a View","text":"<pre><code>SELECT \n    table_name\n    , column_name\n    , updatable\n    , insertable\n    , deletable\nFROM USER_UPDATABLE_COLUMNS\nWHERE table_name= 'view_name'; \n</code></pre> Sources <ul> <li>Oracle Documentation - USER_UPDATABLE_COLUMNS</li> </ul>"},{"location":"SQL/data-dictionary/#nls_length_semantics","title":"NLS_LENGTH_SEMANTICS","text":"<p>Syntax <pre><code>SELECT PARAMETER, VALUE \nFROM NLS_SESSION_PARAMETERS \nWHERE PARAMETER = 'NLS_LENGTH_SEMANTICS';\n</code></pre></p> <p>Examples</p> <pre><code>SELECT PARAMETER, VALUE \nFROM NLS_SESSION_PARAMETERS \nWHERE PARAMETER = 'NLS_LENGTH_SEMANTICS';\n\n/*\nPARAMETER            | VALUE\n-------------------- | -----\nNLS_LENGTH_SEMANTICS | BYTE\n*/\n</code></pre> Sources <ul> <li>Oracle Documentation - NLS_LENGTH_SEMANTICS</li> </ul>"},{"location":"SQL/data-dictionary/#updating-nls_length_semantics","title":"Updating NLS_LENGTH_SEMANTICS","text":"<p>Syntax <pre><code>-- for the current session\nALTER SESSION SET NLS_LENGTH_SEMANTICS = '{CHAR | BYTE}';\n\n-- for the Database\nALTER SYSTEM SET NLS_LENGTH_SEMANTICS = '{CHAR | BYTE}' SCOPE = {BOTH | SPFILE};\n</code></pre></p> <ul> <li><code>CHAR | BYTE</code>: any new Character column will use CHAR or BYTE by default.</li> <li><code>BOTH</code>: makes the change for the running istance and in the parameter file (so it persists across database restarts)</li> <li><code>SPFILE</code>: makes the change after the next database restart.</li> </ul> <p>Notes</p> <ul> <li>This change only affects new Tables and not existing ones.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>ALTER SESSION</code>:<ul> <li>no Privilege is required to change the value for the current session.</li> </ul> </li> <li><code>ALTER SYSTEM</code>:<ul> <li><code>GRANT ALTER SYSTEM TO user_name;</code></li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - ALTER SESSION</li> <li>Oracle Documentation - ALTER SYSTEM</li> </ul>"},{"location":"SQL/datatypes/","title":"Datatypes","text":""},{"location":"SQL/datatypes/#character-dataypes","title":"Character Dataypes","text":"<ul> <li><code>CHAR</code></li> <li><code>VARCHAR2</code></li> <li><code>NCHAR</code></li> <li><code>NVARCHAR2</code></li> </ul>"},{"location":"SQL/datatypes/#char","title":"CHAR","text":"<p>The CHAR data type specifies a fixed-length character string in the database character set.</p> <p>Syntax <pre><code>CHAR[(size [BYTE | CHAR])]\n</code></pre></p> <ul> <li>size: integer number which represents the size in BYTE or CHAR.</li> <li><code>BYTE | CHAR</code>: BYTE indicates the column will have byte length semantics. CHAR indicates that the column will have character semantics. </li> </ul> <p>Notes</p> <ul> <li>Default and minimum size is 1.</li> <li>Maximum size is 2000 Bytes or Characters.</li> <li>If neither BYTE nor CHAR are specified, then the Database uses the value of <code>NLS_LENGTH_SEMANTICS</code>.</li> <li>If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length.</li> </ul> Sources <ul> <li>Oracle Documentation - CHAR Data Type</li> </ul>"},{"location":"SQL/datatypes/#varchar2","title":"VARCHAR2","text":"<p>Variable-length character string having maximum length size bytes or characters.</p> <p>Oracle stores a character value in a VARCHAR2 column exactly as you specify it, without any blank-padding.</p> <p>Syntax <pre><code>VARCHAR2(size [BYTE | CHAR])\n</code></pre></p> <ul> <li>size: integer number which represents the size in BYTE or CHAR. </li> <li><code>BYTE | CHAR</code>: BYTE indicates the column will have byte length semantics. CHAR indicates that the column will have character semantics.</li> </ul> <p>Notes</p> <ul> <li>Minimum size is 1.</li> <li>Maximum size is 32767 for Bytes or 4000 for Characters.</li> <li>If neither BYTE nor CHAR are specified, then the Database uses the value of <code>NLS_LENGTH_SEMANTICS</code>.</li> </ul> Sources <ul> <li>Oracle Documentation - VARCHAR2 Data Type</li> </ul>"},{"location":"SQL/datatypes/#nchar","title":"NCHAR","text":"<p>The NCHAR data type specifies a fixed-length character string in the national character set (which can be <code>AL16UTF16</code> or <code>UTF8</code>).</p> <p>Syntax <pre><code>NCHAR[(size)]\n</code></pre></p> <ul> <li>size: integer number which represents the column size. </li> </ul> <p>Notes</p> <ul> <li>Default and minimum size is 1.</li> <li>Maximum size is 1000 characters for <code>AL16UTF16</code> or 2000 for <code>UTF8</code>.<ul> <li>However, the maximum lenght of any character value that can be stored into an NCHAR column is 2000 bytes.</li> </ul> </li> <li>When specifying size, you're specifying code points. 1 code point is equivalent to 2 bytes in <code>AL16UTF16</code> and from 1 to 3 bytes in <code>UTF8</code>.</li> <li>If you insert a value that is shorter than the column length, then Oracle blank-pads the value to column length.</li> <li>This datatype is generally used for storing characters in multiple languages.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - CHAR vs. NCHAR</li> </ul> Sources <ul> <li>Oracle Documentation - NCHAR Data Type</li> </ul>"},{"location":"SQL/datatypes/#nvarchar2","title":"NVARCHAR2","text":"<p>The NVARCHAR2 data type specifies a variable-length character string in the national character set (which can be <code>AL16UTF16</code> or <code>UTF8</code>).</p> <p>Syntax <pre><code>NVARCHAR2(size)\n</code></pre></p> <ul> <li>size: integer number which represents the column size. </li> </ul> <p>Notes</p> <ul> <li>Minimum size is 1.</li> <li>Maximum size is:<ul> <li>1363 -- if <code>MAX_STRING_SIZE = EXTENDED</code> and national character set is AL16UTF16.</li> <li>2000 -- if <code>MAX_STRING_SIZE = STANDARD</code> and national character set is AL16UTF16.</li> <li>32767 -- if <code>MAX_STRING_SIZE = EXTENDED</code> and national character set is UTF8.</li> <li>4000 -- if <code>MAX_STRING_SIZE = STANDARD</code>and national character set is UTF8.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - NVARCHAR2 Data Type</li> </ul>"},{"location":"SQL/datatypes/#number-datatypes","title":"Number Datatypes","text":"<ul> <li><code>NUMBER</code></li> <li><code>FLOAT</code></li> <li><code>BINARY_FLOAT</code></li> <li><code>BINARY_DOUBLE</code></li> </ul>"},{"location":"SQL/datatypes/#number","title":"NUMBER","text":"<p>The NUMBER data type stores zero as well as positive and negative fixed numbers.</p> <p>Syntax <pre><code>NUMBER[(precision [,scale])]\n</code></pre></p> <ul> <li>precision: maximum number of significant decimal digits.</li> <li>scale: number of digits from the decimal point to the least significant digit.</li> </ul> <p>Notes</p> <ul> <li>The precision can range from 1 to 38.</li> <li>The scale can range from -84 to 127.</li> <li>If not specified, the scale is 0.</li> <li>Numbers can go from \\(1.0\\) x \\(10^{-130}\\) to \\(1.0\\) x \\(10^{126}\\).</li> <li>If a value exceeds the precision, then Oracle returns an error. If a value exceeds the scale, then Oracle rounds it.</li> <li>The absence of precision and scale designators specifies the maximum range and precision for an Oracle number.</li> </ul> <p>Examples</p> <pre><code>NUMBER      \u2192 123.89 \u2192 123.89\nNUMBER(3)   \u2192 123.89 \u2192 124\nNUMBER(3,2) \u2192 123.89 \u2192 ORA-01438: value larger than specified precision allowed for this column\nNUMBER(5,2) \u2192 123.89 \u2192 123.89\nNUMBER(6,1) \u2192 123.89 \u2192 123.9 \n</code></pre> Sources <ul> <li>Oracle Documentation - NUMBER Data Type</li> </ul>"},{"location":"SQL/datatypes/#float-data-type","title":"FLOAT Data Type","text":"<p>The FLOAT data type is a subtype of NUMBER. It can be specified with or without precision, which has the same definition it has for NUMBER.</p> <p>Syntax <pre><code>FLOAT[(precision)]\n</code></pre></p> <ul> <li>precision: maximum number of significant decimal digits.</li> </ul> <p>Notes</p> <ul> <li>Oracle recommends that you use the <code>BINARY_FLOAT</code> and <code>BINARY_DOUBLE</code> data types instead.</li> </ul>"},{"location":"SQL/datatypes/#datetime-datatypes","title":"Datetime Datatypes","text":"<ul> <li><code>DATE</code></li> <li><code>TIMESTAMP</code></li> <li><code>INTERVAL YEAR TO MONTH</code></li> <li><code>INTERVAL DAY TO SECOND</code></li> </ul>"},{"location":"SQL/datatypes/#ansi-datatypes","title":"ANSI Datatypes","text":"<ul> <li><code>CHARACTER</code></li> <li><code>CHAR VARYING</code></li> <li><code>NCHAR VARYING</code></li> <li><code>VARCHAR</code></li> <li><code>NATIONAL CHARACTER</code>, <code>NATIONAL CHAR</code></li> <li><code>NUMERIC</code>, <code>DECIMAL</code>, <code>DEC</code></li> <li><code>INTEGER</code>, <code>INT</code>, <code>SMALLINT</code></li> <li><code>FLOAT</code></li> <li><code>DOUBLE PRECISION</code></li> <li><code>REAL</code></li> </ul>"},{"location":"SQL/datatypes/#other-datatypes","title":"Other Datatypes","text":"<ul> <li><code>LONG</code></li> <li><code>LONG RAW</code></li> <li><code>RAW</code></li> <li><code>BLOB</code></li> <li><code>CLOB</code></li> <li><code>NCLOB</code></li> <li><code>BFILE</code></li> <li><code>ROWID</code></li> <li><code>UROWID</code></li> </ul>"},{"location":"SQL/db-objects/","title":"Other Database Objects","text":""},{"location":"SQL/db-objects/#create-index","title":"CREATE INDEX","text":"<p>Indexes are optional structures associated with Tables that allow SQL queries to execute more quickly against a Table.</p> <p>Syntax <pre><code>CREATE [UNIQUE] INDEX index_name\n    ON table_name (column_1, column_2, ... column_n)\n    [COMPUTE STATISTICS];\n</code></pre></p> <ul> <li><code>UNIQUE</code>: Indicates that the combination of values in the indexed columns must be unique.</li> <li>index_name: the name to assign to the index.</li> <li>table_name: the name of the table in which to create the index.</li> <li><code>COMPUTE STATISTICS</code>: tells Oracle to collect stats during the creation of the index. They are then used by the optimizer to choose a \"plan of execution\" when SQL Statements are executed.</li> </ul> <p>Notes</p> <ul> <li>Indexes are logically and physically independent of the data in the associated table. Being independent structures, they require storage space.</li> <li>You can create or drop an index without affecting the base tables, database applications, or other indexes.</li> <li>The database automatically maintains indexes when you insert, update, and delete rows of the associated table.</li> <li>If you drop an index, all applications continue to work. However, access to previously indexed data might be slower.</li> <li>To create an index in your own schema, you must have the CREATE ANY INDEX system privilege.</li> <li>LONG columns cannot be indexed.</li> <li>By default, Oracle creates B-Tree Indexes.</li> </ul> Sources <ul> <li>Oracle Documentation - CREATE INDEX</li> </ul>"},{"location":"SQL/db-objects/#alter-index","title":"ALTER INDEX","text":"<pre><code>ALTER INDEX index_name\n    RENAME TO new_index_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - ALTER INDEX</li> </ul>"},{"location":"SQL/db-objects/#drop-index","title":"DROP INDEX","text":"<pre><code>DROP INDEX index_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - DROP INDEX</li> </ul>"},{"location":"SQL/db-objects/#synonyms","title":"Synonyms","text":"<p>A Synonym is an alternative name for objects such as Tables, Views, Sequences, etc. You can perform tasks such as creating Synonyms, using Synonyms, and dropping Synonyms.</p> <p>Synonyms allow underlying obejcts to be renamed or moved, where only the Synonym must be redefined and applications based on the synonym continue to function without modification.</p> <p>Privilege Restrictions</p> <ul> <li>(Private Synonym) in your schema: <code>CREATE SYNONYM</code> System Privilege</li> <li>(Private Synonym) in another's user schema: <code>CREATE ANY SYNONYM</code> System Privilege</li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_SYNONYMS</code></li> </ul> Sources <ul> <li>Oracle Documentation - Managing Synonyms</li> </ul>"},{"location":"SQL/db-objects/#create-synonym","title":"CREATE SYNONYM","text":"<pre><code>CREATE [OR REPLACE] [PUBLIC] SYNONYM [schema.]synonym_name\n    FOR [schema.]object_name;\n</code></pre> <ul> <li><code>OR REPLACE</code>: allows you to recreate the Synonym if it already exists.</li> <li><code>PUBLIC</code>: if specified, the Synonym is a Public Synonym and accessible to all users, otherwise it'll be a Private Synonym.</li> <li>schema: schema on which the Synonym will be created.</li> <li>object_name: the name of the object for which you are creating the Synonym. <ul> <li>can be one of the following:<ul> <li>Table</li> <li>View</li> <li>Sequence</li> <li>Stored Procedure</li> <li>Function</li> <li>Package</li> <li>Materialized View</li> <li>User-defined Object</li> <li>Synonym</li> </ul> </li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - CREATE SYNONYM</li> </ul>"},{"location":"SQL/db-objects/#drop-synonym","title":"DROP SYNONYM","text":"<pre><code>DROP [PUBLIC] SYNONYM synonym_name;\n</code></pre> Sources <ul> <li>Oracle Documentation - DROP SYNONYM</li> </ul>"},{"location":"SQL/db-objects/#views","title":"Views","text":"<p>A View is a logical representation of a Table or combination of Tables. In essence, a View is a stored query.</p> <p>Notes</p> <ul> <li>A View derives its data from the Tables on which it is based. These Tables are called base Tables.</li> <li>All operations performed on a View actually affect the base Table of the View.</li> <li>You can use Views in almost the same way as Tables. You can query, update, insert into, and delete from Views.</li> </ul> <p>Restrictions on DML Operations</p> <ul> <li>You need the appropriate privigiles on the base Tables to run DML Statements.</li> <li>DML Operations are not allowed on Views with SET or DISTINCT operators, GROUP BY clause, Group Functions or Subqueries.</li> <li>If a View is defined with WITH CHECK OPTION, DML Operations are not allowed if the View cannot select the row from the base Table.</li> <li>If a NOT NULL column that does not have a DEFAULT clause is omitted from the View, then a row cannot be inserted into the base Table using the View.</li> <li>INSERT and UPDATE Operations are not allowed on Views with expressions such as DECODE.</li> <li>Any DML Operation on a Join View can modify only one underlying base Table at a time.</li> </ul> <p>Key-Preserved Tables A Table is key-preserved if every key of the Table can also be a key of the result of the Join that is based on the Table.</p> Sources <ul> <li>Oracle Documentation - Managing Views</li> </ul>"},{"location":"SQL/db-objects/#create-view","title":"CREATE VIEW","text":"<p>Syntax <pre><code>CREATE [OR REPLACE] VIEW view_name AS\nquery\n[WITH CHECK OPTION];\n</code></pre></p> <ul> <li><code>WITH CHECK OPTION</code>: can be given for an updatable View to prevent inserts to rows for which the WHERE clause in the SELECT Statement is not true.</li> </ul> <p>Privilege Restrictions</p> <ul> <li>In your schema: <code>CREATE VIEW</code> System Privilege</li> <li>In another's user schema: <code>CREATE ANY VIEW</code> System Privilege</li> </ul> Sources <ul> <li>Oracle Documentation - CREATE VIEW</li> </ul>"},{"location":"SQL/db-objects/#with-check-option","title":"WITH CHECK OPTION","text":"<p>Usually you can insert rows in a Table through a View even if the rows you're adding violate the View's WHERE condition. (Example 1) To prevent that and make it so the rows you try to insert are valid for the View as well, you can add the WITH CHECK OPTION. (Example 2)</p> <p>Example 1 <pre><code>CREATE TABLE t (t1 number);\n\nCREATE OR REPLACE VIEW vw AS SELECT * FROM t WHERE t1 &gt; 0;\n\nINSERT INTO vw VALUES (0);\n\nSELECT * FROM t;\n-- returns 1 rows\n\nSELECT count(1) FROM vw;\n-- returns 0\n</code></pre></p> <p>Example 2 <pre><code>CREATE OR REPLACE VIEW vw AS SELECT * FROM t WHERE t1 &gt; 0 WITH CHECK OPTION;\n\nINSERT INTO vw VALUES (0);\n-- returns ORA-01402: view WITH CHECK OPTION where-clause violation\n</code></pre></p> Sources <ul> <li>Oracle Documentation - CREATE VIEW</li> </ul>"},{"location":"SQL/db-objects/#sequences","title":"Sequences","text":"<p>A Sequence is a database object from which multiple users may generate unique integers. It can be used to automatically generate primary key values.</p> <p>When a Sequence number is generated, the Sequence is incremented, independent of the transaction committing or rolling back.</p> <p>If two users concurrently increment the same Sequence, then the Sequence numbers each user acquires may have gaps, because Sequence numbers are being generated by the other user.</p> <p>Syntax <pre><code>CREATE SEQUENCE [schema.]sequence_name\n[INCREMENT BY | START WITH integer]\n[NOMAXVALUE | MAXVALUE integer]\n[NOMINVALUE | MINVALUE integer]\n[CYCLE | NOCYCLE]\n[NOCACHE | CACHE integer]\n[ORDER | NOORDER]\n;\n</code></pre></p> <ul> <li>schema: specify the scema to contain the Sequence.</li> <li>sequence_name: specify the name of the Sequence to be created.</li> <li><code>INCREMENT BY</code>: specify the interval between Sequence numbers.  </li> <li><code>START WITH</code>: specify the first Sequence number to be generated.</li> <li><code>MAXVALUE integer</code>: specify the maximum value the Sequence can generate.</li> <li><code>NOMAXVALUE integer</code>: indicates a minimum value of 1 for an ascending Sequence or -(10^27 -1) for descending Sequence.</li> <li><code>CYCLE</code>: indicates that the Sequence continues to generate values after reaching either its maximum or minimum value.</li> <li><code>NOCYCLE</code>: indicates that the Sequence cannot generate more value after reaching its maximum or minimum value.</li> <li><code>CACHE</code>: specify how many values of the Sequence the Database preallocates and keeps in memory for faster access.</li> <li><code>NOCACHE</code>: indicates that values of the Sequence are not preallocated.</li> <li><code>ORDER</code>: guarantees that Sequence numbers are generated in order of request.</li> <li><code>NOORDER</code>: does not guarantee Sequence numbers to be generated in order of request.</li> </ul> <p>Sequence's Default Options</p> <ul> <li><code>INCREMENT BY 1</code></li> <li><code>START WITH ?</code></li> <li><code>NOMAXVALUE</code></li> <li><code>NOCYCLE</code></li> <li><code>CACHE 20</code></li> <li><code>NOORDER</code></li> </ul> <p>Notes</p> <ul> <li>There is no ROLLBACK in the Sequence values.</li> <li><code>INCREMENT BY</code> cannot be 0.</li> <li><code>MAXVALUE</code> must be:</li> <li>Equal to or greater than <code>START WITH</code>. </li> <li>Greater than <code>MINVALUE</code></li> <li>After an ascending Sequence reaches its maximum value, it generates its minimum value.</li> <li>After a descending Sequence reaches its minimum, it generates its maximum value.</li> <li>Mininum value of <code>CACHE</code> is 2.</li> <li>CACHE value must be less than the value determined by this formula: <code>CEIL((MAXVALUE-MINVALUE)/ABS(INCREMENT))</code></li> <li>If a system failure occurs, then all cached Sequence values that have not been used in committed DML statements are lost.</li> <li>Guaranteeing order is usually not important for Sequences used to generate Primary Keys.</li> </ul> <p>Privilege Restrictions</p> <ul> <li>In your schema: <code>CREATE SEQUENCE</code> System Privilege</li> <li>In another's user schema: <code>CREATE ANY SEQUENCE</code> System Privilege</li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_SEQUENCES</code></li> </ul> Sources <ul> <li>Oracle Documentation - Managing Sequences</li> </ul>"},{"location":"SQL/db-objects/#alter-sequence","title":"ALTER SEQUENCE","text":"<pre><code>ALTER SEQUENCE [schema.]sequence_name\n{\n    {INCREMENT BY number | START WITH number} |\n    {MAXVALUE number | NOMAXVALUE number} |\n    {MINVALUE number | NOMINVALUE number} |\n    RESTART |\n    {CYCLE | NOCYCLE} |\n    {CACHE number | NOCACHE} |\n    {ORDER | NOORDER} |\n    {KEEP | NOKEEP} |\n    {SCALE EXTEND | SCALE NOEXTEND | NOSCALE} |\n    {SHARD EXTEND | SHARD NOEXTEND | NOSHARD} |\n    {SESSION | GLOBAL} \n}\n</code></pre> <ul> <li><code>RESTART</code>: resets NEXTVAL to MINVALUE for an ascending Sequence. For a descending Sequence restarts NEXTVAL to MAXVALUE.</li> </ul> <p>Notes</p> <ul> <li>To restart a Sequence with a different number, specify both RESTART and START WITH.</li> <li>A new MAXVALUE cannot be less than the current Sequence number.</li> </ul> <p>Privilege Restrictions</p> <ul> <li>In your schema: <code>GRANT ALTER sequence_name TO user_name;</code></li> <li>In another's user schema: <code>GRANT ALTER ANY SEQUENCE TO user_name</code>;</li> </ul> Sources <ul> <li>Oracle Documentation - ALTER SEQUENCE</li> </ul>"},{"location":"SQL/functions/","title":"Functions","text":""},{"location":"SQL/functions/#character-functions","title":"Character Functions","text":"<p>Character functions operate on values of dataype CHAR or VARCHAR2.</p> <p>List of Character Functions covered</p> <ul> <li><code>CONCAT</code></li> <li><code>INITCAP</code></li> <li><code>LOWER</code></li> <li><code>LPAD</code></li> <li><code>LTRIM</code></li> <li><code>REPLACE</code></li> <li><code>RPAD</code></li> <li><code>RTRIM</code></li> <li><code>SUBSTR</code></li> <li><code>TRIM</code></li> <li><code>UPPER</code></li> <li><code>INSTR</code></li> <li><code>LENGTH</code></li> </ul>"},{"location":"SQL/functions/#concat","title":"CONCAT","text":"<p>The CONCAT (Single-Row) Function concatenates two strings and returns the combined string.</p> <p>The two strings do not need to be the same data type.</p> <p>Syntax <pre><code>CONCAT(string1, string2)\n</code></pre></p> <ul> <li>string1: the first string to concatenate.</li> <li>string2: the second string to concatenate.</li> </ul> Sources <ul> <li>Oracle Documentation - CONCAT</li> </ul>"},{"location":"SQL/functions/#initcap","title":"INITCAP","text":"<p>The INITCAP (Single-Row) Function sets the first character in each word to uppercase and the rest to lowercase.</p> <p>Syntax <pre><code>INITCAP(string1)\n</code></pre></p> <ul> <li>string1: the string argument whose first character in each word will be converted to uppercase and all remaining characters converted to lowercase.</li> </ul> <p>Notes</p> <ul> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT INITCAP('hello everyone!') FROM dual;\n-- Hello Everyone!\n\nSELECT INITCAP(1234567890) FROM dual;\n-- 1234567890\n\nSELECT INITCAP(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-Nov-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - INITCAP</li> </ul>"},{"location":"SQL/functions/#lower","title":"LOWER","text":"<p>The LOWER (Single-Row) Function converts all letters in the specified string to lowercase.</p> <p>Syntax <pre><code>LOWER(string1)\n</code></pre></p> <ul> <li>string1: the string to convert to lowercase.</li> </ul> <p>Notes</p> <ul> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT LOWER('hello EVERYONE!') FROM dual;\n-- hello everyone!\n\nSELECT LOWER(1234567890) FROM dual;\n-- 1234567890\n\nSELECT LOWER(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-nov-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - LOWER</li> </ul>"},{"location":"SQL/functions/#upper","title":"UPPER","text":"<p>The UPPER (Single-Row) Function converts all letters in the specified string to uppercase.</p> <p>Syntax <pre><code>UPPER(string1)\n</code></pre></p> <ul> <li>string1: the string to convert to uppercase.</li> </ul> <p>Notes</p> <ul> <li>Special characters and numbers are unaffected by this function.</li> </ul> <p>Examples</p> <pre><code>SELECT UPPER('hello EVERYONE!') FROM dual;\n-- HELLO EVERYONE!\n\nSELECT UPPER(1234567890) FROM dual;\n-- 1234567890\n\nSELECT UPPER(TO_DATE('20-NOV-2022')) FROM dual;\n-- 20-NOV-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - UPPER</li> </ul>"},{"location":"SQL/functions/#lpad-rpad","title":"LPAD &amp; RPAD","text":"<p>The LPAD &amp; RPAD (Single-Row) Functions pad the left/right-side of a string with a specific set of characters.</p> <p>Syntax <pre><code>LPAD(string1, padded_length, [, pad_string])\nRPAD(string1, padded_length, [, pad_string])\n</code></pre></p> <ul> <li>string1: the string to pad characters to (the left/right-hand side).</li> <li>padded_length: the number of characters to return.</li> <li>pad_string the string that will be padded to the left/right-hand side of string1.<ul> <li>optional value; default is blank space.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>If string1 is NULL, the function returns NULL.</li> <li>If the padded_length is smaller than the original string, the function will truncate the string to the size of padded_length.</li> </ul> <p>Examples</p> <pre><code>SELECT LPAD('Hello!', 10, 'a') FROM dual;\n-- aaaaHello!\n\nSELECT RPAD('Hello!', 10, 'a') FROM dual;\n-- Hello!aaaa\n</code></pre> Sources <ul> <li>Oracle Documentation - LPAD</li> <li>Oracle Documentation - RPAD</li> </ul>"},{"location":"SQL/functions/#ltrim-rtrim","title":"LTRIM &amp; RTRIM","text":"<p>The LTRIM &amp; RTRIM (Single-Row) Functions remove all specified characters from the left/right-hand side of a string.</p> <p>Syntax <pre><code>LTRIM(string1, [, trim_string])\nRPAD(string1, [, trim_string])\n</code></pre></p> <ul> <li>string1: the string to trim the characters from the left/right-hand side.</li> <li>trim_string: the string that will be removed from the left/right-hand side of string1.<ul> <li>default is blank space.</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT LTRIM('Hello!','H') FROM dual;\n-- ello!\n\nSELECT RTRIM('Hello!', '!') FROM dual;\n-- Hello\n\nSELECT LTRIM('Hello!', 'h') FROM dual;\n-- Hello!\n</code></pre> Sources <ul> <li>Oracle Documentation - LTRIM</li> <li>Oracle Documentation - RTRIM</li> </ul>"},{"location":"SQL/functions/#trim","title":"TRIM","text":"<p>The TRIM (Single-Row) Function removes all specified characters either from the beginning or the end of a string.</p> <p>Syntax <pre><code>TRIM([[LEADING | TRAILING | BOTH] trim_character FROM] string1)\n</code></pre></p> <ul> <li><code>LEADING</code>: the function will remove trim_character from the front of string1.</li> <li><code>TRAILING</code>: the function will remove trim_character from the end of string1.</li> <li><code>BOTH</code>: the function will remove trim_character from the front and end of string1.</li> <li>trim_character: the character that will be removed from string1.<ul> <li>optional value; default is blank space.</li> <li>this argument cannot contain more than 1 character.</li> </ul> </li> <li>string1: the string to trim.</li> </ul> <p>Examples</p> <pre><code>SELECT TRIM(LEADING 'H' FROM 'Hello!') FROM dual;\n-- ello!\n\nSELECT TRIM(TRAILING 'o' FROM 'Hello') FROM dual;\n-- Hell\n\nSELECT TRIM('!' FROM 'Hello!') FROM dual;\n-- Hello\n</code></pre> Sources <ul> <li>Oracle Documentation - TRIM</li> </ul>"},{"location":"SQL/functions/#replace","title":"REPLACE","text":"<p>The REPLACE (Single-Row) Function replaces a sequence of characters in a string with another set of characters.</p> <p>Syntax <pre><code>REPLACE(string1, string_to_replace [, replacement_string])\n</code></pre></p> <ul> <li>string1: the string to replace a sequence of characters with another set of characters.</li> <li>string_to_replace: the string that will be searched for in string1.</li> <li>replacement_string: all occurrences of string_to_replace will be replaced with replacement_string in string1.<ul> <li>if omitted, the function removes all occurrences of string_to_replace.</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT REPLACE('123Hello123', '123') FROM dual;\n-- Hello\n\nSELECT REPLACE('123Hello123', '456') FROM dual;\n-- 456Hello456\n\nSELECT REPLACE('0123456789', '0') FROM dual;\n-- 123456789\n</code></pre> Sources <ul> <li>Oracle Documentation - REPLACE</li> </ul>"},{"location":"SQL/functions/#length","title":"LENGTH","text":"<p>The LENGTH (Single-Row) Function returns the length of the specified string.</p> <p>Syntax <pre><code>LENGTH(string1)\n</code></pre></p> <ul> <li>string1: the string to return the length for.</li> </ul> <p>Notes</p> <ul> <li>LENGTH does not count dashes in DATE values.</li> </ul> <p>Examples</p> <pre><code>SELECT LENGTH('Hello World!') FROM dual;\n-- 12\n\nSELECT LENGTH(1234567890) FROM dual;\n-- 10\n\nSELECT LENGTH(TO_DATE('20-NOV-2022')) FROM dual;\n-- 9\n</code></pre> Sources <ul> <li>Oracle Documentation - LENGTH</li> </ul>"},{"location":"SQL/functions/#substr","title":"SUBSTR","text":"<p>The SUBSTR (Single-Row) Function allows to extract a substring from a string.</p> <p>Syntax <pre><code>SUBSTR(string. start_position [, length])\n</code></pre></p> <ul> <li>string: the source string.</li> <li>start_position: the starting position for extraction. First position is always 1.</li> <li>length: number of characters to extract.</li> </ul> <p>Notes</p> <ul> <li>If string is SYSDATE, Oracle will execute an implicit data type conversion.</li> <li>If start_position is 0, SUBSTR treats start_position as 1.</li> <li>If start_position is negative, SUBSTR start from the end of the string and count backwards.</li> <li>If length is omitted, SUBSTR will return the entire string.</li> <li>If length is negative, SUBSTR returns a NULL value.</li> </ul> Sources <ul> <li>Oracle Documentation - SUBSTR</li> </ul>"},{"location":"SQL/functions/#instr","title":"INSTR","text":"<p>The INSTR (Single-Row) Function returns the location of a substring in a string.</p> <p>Syntax <pre><code>INSTR(string, substring [, start_position [, nth_appearance]])\n</code></pre></p> <ul> <li>string: the string to search.</li> <li>substring: substring to search for in string.</li> <li>start_position: position in string where the search will start.<ul> <li>default is 1.</li> </ul> </li> <li>nth_appearance: the nth appearance of substring.<ul> <li>default is 1.</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>If either string or substring is NULL, INSTR returns NULL.</li> <li>If substring is not found in string, INSTR returns 0.</li> <li>If start_position negative, the INSTR function counts backwards.</li> </ul> <p>Examples</p> <pre><code>SELECT INSTR('ciaoc', 'c', 1, 2)\nFROM dual;\n-- 5\n</code></pre> Sources <ul> <li>Oracle Documentation - INSTR</li> </ul>"},{"location":"SQL/functions/#least","title":"LEAST","text":"<p>The LEAST (Single-Row) Function returns the smallest value in a list of expressions.</p> <p>Syntax <pre><code>LEAST(expr1 [, expr2, ... expr_n])\n</code></pre></p> <ul> <li>expr1: the first expression to evaluate whether it is the smallest.</li> <li>expr2, expr_n: additional expressions that are to be evaluated.</li> </ul> <p>Notes</p> <ul> <li>If either expr1 or expr2 is NULL, LEAST returns NULL.</li> </ul> <p>Examples</p> <pre><code>SELECT LEAST('hello', 'HELLO', 'z') FROM dual;\n-- HELLO\n\nSELECT LEAST(NULL, 'HELLO', 'hELLO', 'zzz') FROM dual;\n-- NULL\n\nSELECT LEAST(8, 56, 99, 5, NULL) FROM dual;\n-- NULL\n</code></pre> Sources <ul> <li>Oracle Documentation - LEAST</li> </ul>"},{"location":"SQL/functions/#numeric-functions","title":"Numeric Functions","text":"<p>The Numeric Functions take a numeric input as an expression and return numeric values. The return type for most of the Numeric Functions is NUMBER.</p> <p>List of Numeric Functions covered</p> <ul> <li><code>CEIL</code></li> <li><code>FLOOR</code></li> <li><code>MOD</code></li> <li><code>POWER</code></li> <li><code>REMAINDER</code></li> <li><code>ROUND</code></li> <li><code>TRUNC</code></li> </ul>"},{"location":"SQL/functions/#ceil","title":"CEIL","text":"<p>The CEIL (Single-Row) Function returns the smallest integer value that is greater than or equal to a number.</p> <p>Syntax <pre><code>CEIL(number)\n</code></pre></p> <ul> <li>number: the value used to find the smallest integer value.</li> </ul> <p>Examples</p> <pre><code>SELECT CEIL(21.65) FROM dual;\n-- 21\n\nSELECT CEIL(21.21) FROM dual;\n-- 22\n\nSELECT CEIL(21) FROM dual;\n-- 21\n\nSELECT CEIL(-21.65) FROM dual;\n-- -21\n</code></pre> Sources <ul> <li>Oracle Documentation - CEIL</li> </ul>"},{"location":"SQL/functions/#floor","title":"FLOOR","text":"<p>The FLOOR (Single-Row) Function returns the largest integer value that is equal to or less than a number.</p> <p>Syntax <pre><code>FLOOR(number)\n</code></pre></p> <ul> <li>number: the value used to determine the largest integer value that is equal to or less than a number.</li> </ul> <p>Examples</p> <pre><code>SELECT FLOOR(21.65) FROM dual;\n-- 21\n\nSELECT FLOOR(21.21) FROM dual;\n-- 21\n\nSELECT FLOOR(21) FROM dual;\n-- 21\n\nSELECT FLOOR(-21.65) FROM dual;\n-- -22\n</code></pre> Sources <ul> <li>Oracle Documentation - FLOOR</li> </ul>"},{"location":"SQL/functions/#mod","title":"MOD","text":"<p>The MOD (Single-Row) Function returns the remainder of m divided by n.</p> <p>The difference with the REMAINDER function is that REMAINDER uses ROUND in its calculation, and MOD uses the FLOOR function.</p> <p>Syntax <pre><code>MOD(m, n)\n</code></pre></p> <ul> <li>m: the numeric value used in the calculation.</li> <li>n: the numeric value used in the calculation.<ul> <li><code>MOD</code> returns m if n is 0.</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT MOD(15, 4) FROM dual;\n-- 3\n\nSELECT MOD(15, 0) FROM dual;\n-- 0\n\nSELECT MOD(11.6, 2) FROM dual;\n-- 1.6\n</code></pre> Sources <ul> <li>Oracle Documentation - MOD</li> </ul>"},{"location":"SQL/functions/#power","title":"POWER","text":"<p>The POWER (Single-Row) Function returns m raised to the nth power.</p> <p>Syntax <pre><code>POWER(m, n)\n</code></pre></p> <ul> <li>m: the base used in the calculation.<ul> <li>if m s negative, then n must be an integer.</li> </ul> </li> <li>n: the exponent used in the calculation.</li> </ul> <p>Examples</p> <pre><code>SELECT POWER(3, 2) FROM dual;\n-- 9\n\nSELECT POWER(5, 3) FROM dual;\n-- 125\n\nSELECT POWER(-5, 3) FROM dual;\n-- -125\n</code></pre> Sources <ul> <li>Oracle Documentation - POWER</li> </ul>"},{"location":"SQL/functions/#remainder","title":"REMAINDER","text":"<p>The REMAINDER (Single-Row) Function returns the remainder of m divided by n.</p> <p>The difference with the MOD function is that REMAINDER uses ROUND in its calculation, and MOD uses the FLOOR function.</p> <p>The REMAINDER is calculated as follows: <code>m - (n * X)</code> where X is the integer nearest n / n</p> <p>Syntax <pre><code>REMAINDER(m, n)\n</code></pre></p> <ul> <li>m: a numeric value used in the calculation.</li> <li>n: a numeric value used in the calculation.</li> </ul> <p>Examples</p> <pre><code>SELECT REMAINDER(15, 6) FROM dual;\n-- 3\n\nSELECT REMAINDER(15, 5) FROM dual;\n-- 0\n\nSELECT REMAINDER(15, 4) FROM dual;\n-- -1\n</code></pre> Sources <ul> <li>Oracle Documentation - REMAINDER</li> </ul>"},{"location":"SQL/functions/#round-number","title":"ROUND (number)","text":"<p>The ROUND (Single-Row) Function returns a number rounded to a certain number of decimal places.</p> <p>Syntax <pre><code>ROUND(number [, decimal_places])\n</code></pre></p> <ul> <li>number: the number to round.</li> <li>decimal_places: the number of decimal places rounded to.<ul> <li>if omitted, the ROUND function will round the number to 0 decimal places.</li> <li>ff negative, rounds a number one digit to the left of the decimal point.</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT ROUND(152.3435, -1)\nFROM dual;\n-- 150\n</code></pre> Sources <ul> <li>Oracle Documentation - ROUND (number)</li> </ul>"},{"location":"SQL/functions/#trunc-number","title":"TRUNC (number)","text":"<p>The TRUNC (Single-Row) Function returns a number truncated to a certain number of decimal places.</p> <p>Syntax <pre><code>TRUNC(number [, decimal_places])\n</code></pre></p> <ul> <li>number: the number to truncate.</li> <li>decimal_places: the number of decimal places to truncate to.<ul> <li>if omitted, the TRUNC function will truncate the number to 0 decimal places.</li> <li>if negative, replaces digits to the left of the decimal point with 0.</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT TRUNC(152.3435, -1)\nFROM dual;\n-- 150\n</code></pre> Sources <ul> <li>Oracle Documentation - TRUNC (number)</li> </ul>"},{"location":"SQL/functions/#date-functions","title":"Date Functions","text":"<p>Character functions can be used to manipulate temporal values.</p> <p>List of Date Functions covered - <code>ADD_MONTHS</code> - <code>CURRENT_DATE</code> - <code>CURRENT_TIMESTAMP</code> - <code>DBTIMEZONE</code> - <code>LAST_DAY</code> - <code>LOCALTIMESTAMP</code> - <code>MONTHS_BETWEEN</code> - <code>NEXT_DAY</code> - <code>ROUND</code> - <code>SESSIONTIMEZONE</code> - <code>SYSDATE</code> - <code>SYSTIMESTAMP</code> - <code>TRUNC</code></p>"},{"location":"SQL/functions/#add_months","title":"ADD_MONTHS","text":"<p>The ADD_MONTHS (Single-Row) Function returns a date with a specified number of months added.</p> <p>Syntax <pre><code>ADD_MONTHS(date1, number_months)\n</code></pre></p> <ul> <li>date1: the starting date (before the n months have been added).</li> <li>number_months: number of months to add to date1.</li> </ul> Sources <ul> <li>Oracle Documentation - ADD_MONTHS</li> </ul>"},{"location":"SQL/functions/#current_date","title":"CURRENT_DATE","text":"<p>CURRENT_DATE returns the current date in the session time zone, in a value in the Gregorian calendar of data type DATE.</p> <p>Examples</p> <pre><code>SELECT CURRENT_DATE\nFROM DUAL;\n-- 06-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - CURRENT_DATE</li> </ul>"},{"location":"SQL/functions/#current_timestamp","title":"CURRENT_TIMESTAMP","text":"<p>CURRENT_TIMESTAMP returns the current date and time in the session time zone, in a value of data type TIMESTAMP WITH TIME ZONE. The time zone offset reflects the current local time of the SQL session.</p> <p>Examples</p> <pre><code>SELECT CURRENT_TIMESTAMP\nFROM DUAL;\n-- 06-DEC-22 03.20.35.553971000 PM EUROPE/BERLIN\n</code></pre> Sources <ul> <li>Oracle Documentation - CURRENT_TIMESTAMP</li> </ul>"},{"location":"SQL/functions/#dbtimezone","title":"DBTIMEZONE","text":"<p>DBTIMEZONE returns the value of the database time zone.</p> <p>Examples</p> <pre><code>SELECT DBTIMEZONE\nFROM DUAL;\n-- +00:00\n</code></pre> Sources <ul> <li>Oracle Documentation - DBTIMEZONE</li> </ul>"},{"location":"SQL/functions/#last_day","title":"LAST_DAY","text":"<p>The LAST_DAY (Single-Row) Function returns the last day of the month based on a date value.</p> <p>Syntax <pre><code>LAST_DAY(date)\n</code></pre></p> <ul> <li>date: the date value to use to calculate the last day of the month</li> </ul> <p>Examples</p> <pre><code>SELECT LAST_DAY(TO_DATE('01-DEC-2022')) FROM dual;\n-- 31-DEC-2022\n\nSELECT LAST_DAY(TO_DATE('31-DEC-2022')) FROM dual;\n-- 31-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - LAST_DAY</li> </ul>"},{"location":"SQL/functions/#localtimestamp","title":"LOCALTIMESTAMP","text":"<p>LOCALTIMESTAMP returns the current date and time in the session time zone in a value of data type TIMESTAMP.</p> <p>Examples</p> <pre><code>SELECT LOCALTIMESTAMP\nFROM DUAL;\n-- 06-DEC-22 03.20.04.446137000 PM\n</code></pre> Sources <ul> <li>Oracle Documentation - LOCALTIMESTAMP</li> </ul>"},{"location":"SQL/functions/#current_date-vs-current_timestamp-vs-localtimestamp","title":"CURRENT_DATE vs. CURRENT_TIMESTAMP vs. LOCALTIMESTAMP","text":""},{"location":"SQL/functions/#months_between","title":"MONTHS_BETWEEN","text":"<p>The MONTHS_BETWEEN (Single-Row) Function returns the number of months between date1 and date2.</p> <p>Syntax <pre><code>MONTHS_BETWEEN(date1, date2)\n</code></pre></p> <ul> <li>date1: the first date used to calculate the number of months between.</li> <li>date2: the second date used to calculate the number of months between.</li> </ul> <p>Examples</p> <pre><code>SELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('01-JAN-2023')) FROM dual;\n-- -1\n\nSELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('01-NOV-2022')) FROM dual;\n-- 1\n\nSELECT MONTHS_BETWEEN(TO_DATE('01-DEC-2022'), TO_DATE('31-DEC-2022')) FROM dual;\n-- 0.96\n</code></pre> Sources <ul> <li>Oracle Documentation - MONTHS_BETWEEN</li> </ul>"},{"location":"SQL/functions/#next_day","title":"NEXT_DAY","text":"<p>The NEXT_DAY (Single-Row) Function returns the first weekday that is greater than a date.</p> <p>Syntax <pre><code>NEXT_DAY(date, weekday)\n</code></pre></p> <ul> <li>date: a date value used to find the next weekday.</li> <li>weekday: the day of the week that you wish to return.<ul> <li>must be one of the following:<ul> <li>SUNDAY or SUN</li> <li>MONDAY or MON</li> <li>TUESDAY or TUE</li> <li>WEDNESDAY or WED</li> <li>THURSDAY or THU</li> <li>FRIDAY or FRI</li> <li>SATURDAY or SAT</li> </ul> </li> </ul> </li> </ul> <p>Examples</p> <pre><code>-- considering 6 December 2022 was a Tuesday:\nSELECT NEXT_DAY(TO_DATE('06-DEC-2022'), 'Sunday') FROM dual;\n-- 11-DEC-2022\n\nSELECT NEXT_DAY(TO_DATE('06-DEC-2022'), 'Tuesday') FROM dual;\n-- 13-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - NEXT_DAY</li> </ul>"},{"location":"SQL/functions/#round-date","title":"ROUND (date)","text":"<p>The ROUND (Single-Row) Function returns a date rounded to a specific unit of measure.</p> <p>Syntax <pre><code>ROUND(date [, format])\n</code></pre></p> <ul> <li>date: the date to round.</li> <li>format: the unit of measure to apply for rounding.<ul> <li>if omitted, the function will round to the nearest day</li> <li>must be one of the following values: (complete list)</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT ROUND(TO_DATE('01-NOV-2022'), 'YEAR') FROM dual;\n-- 01-JAN-2023\n\nSELECT ROUND(TO_DATE('16-NOV-2022'), 'MONTH') FROM dual;\n-- 01-DEC-2022\n\nSELECT ROUND(TO_DATE('16-NOV-2022')) FROM dual;\n-- 16-NOV-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - ROUND (date)</li> </ul>"},{"location":"SQL/functions/#sessiontimezone","title":"SESSIONTIMEZONE","text":"<p>SESSIONTIMEZONE returns the time zone of the current session.</p> <p>Examples</p> <pre><code>SELECT SESSIONTIMEZONE\nFROM DUAL;\n-- Europe/Berlin\n</code></pre> Sources <ul> <li>Oracle Documentation - SESSIONTIMEZONE</li> </ul>"},{"location":"SQL/functions/#sysdate","title":"SYSDATE","text":"<p>SYSDATE returns the current date and time set for the operating system on which the database server resides.</p> <p>The data type of the returned value is DATE, and the format returned depends on the value of the NLS_DATE_FORMAT initialization parameter.</p> <p>Examples</p> <pre><code>SELECT SYSDATE\nFROM DUAL;\n-- 06-DEC-2022\n</code></pre> Sources <ul> <li>Oracle Documentation - SYSDATE</li> </ul>"},{"location":"SQL/functions/#systimestamp","title":"SYSTIMESTAMP","text":"<p>SYSTIMESTAMP returns the system date, including fractional seconds and time zone, of the system on which the database resides.</p> <p>The return type is TIMESTAMP WITH TIME ZONE.</p> <p>Examples</p> <pre><code>SELECT SYSTIMESTAMP\nFROM DUAL;\n-- 06-DEC-2022 03.41.91.693169000 PM +01:00\n</code></pre> Sources <ul> <li>Oracle Documentation - SYSTIMESTAMP</li> </ul>"},{"location":"SQL/functions/#interval","title":"INTERVAL","text":"<p>The INTERVAL datatype allows you to store periods of time.</p> <p>There are two types of INTERVAL:</p> <ul> <li><code>INTERVAL YEAR TO MONTH</code>: stores intervals using year and month;</li> <li><code>INTERVAL DAY TO SECOND</code>: stores intervals using days, hours, and seconds including fractional seconds.</li> </ul> Sources <ul> <li>Oracle Documentation - Interval Expressions</li> <li>Oracle Documentation - Interval Literals</li> </ul>"},{"location":"SQL/functions/#interval-year-to-month","title":"INTERVAL YEAR TO MONTH","text":"<p>The INTERVAL YEAR TO MONTH data type allows you to store a period of time using the YEAR and MONTH fields.</p> <p>Syntax <pre><code>INTERVAL YEAR [(year_precision)] TO MONTH\n</code></pre></p> <ul> <li>year_precision: number of digits in the YEAR field (ranges from 0 to 9).</li> </ul> <p>Literals Syntax <pre><code>INTERVAL 'year[-month]' leading(precision) TO trailing\n</code></pre></p> <ul> <li>leading and trailing can only be YEAR or MONTH.</li> <li>If leading is YEAR and trailing is MONTH, then the MONTH field ranges from 0 to 11.</li> <li>The trailing field must be less than the leading field.</li> <li>precision represents the number of digits in the leading field. (ranges from 0 to 9; default is 2).</li> </ul> <p>Examples</p> <pre><code>SELECT INTERVAL '120-3' YEAR(3) TO MONTH FROM dual;\n-- +120-03 (120 years and 3 months)\n\nSELECT INTERVAL '105' YEAR(3) FROM dual;\n-- +105-00 (105 years)\n\nSELECT INTERVAL '9' YEAR FROM dual;\n-- +09-00 (9 years)\n\nSELECT INTERVAL '180' YEAR FROM dual;\n-- ORA-01873: the leading precision of the interval is too small\n</code></pre> Sources <ul> <li>Oracle Documentation - INTERVAL YEAR TO MONTH</li> </ul>"},{"location":"SQL/functions/#interval-day-to-second","title":"INTERVAL DAY TO SECOND","text":"<p>The INTERVAL DAY TO SECOND stores a period of time in terms of days, hours, minutes, and seconds.</p> <p>Syntax <pre><code>INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]\n</code></pre></p> <ul> <li>day_precision: number of digits in the DAY field (ranges from 0 to 9).</li> <li>fractional_seconds_precision: number of digits in the fractional part of the SECOND field (ranges from 0 to 9).</li> </ul> <p>Literals Syntax <pre><code>INTERVAL leading(leading_precision) TO trailing(fractional_seconds_precision)\n</code></pre></p> <p>Examples</p> <pre><code>SELECT INTERVAL '11 10:09:08.555' DAY TO SECOND(3) FROM dual;\n-- +11 10:09:08.555 (11 days, 10 hours, 9 minutes, 8 seconds and 555 thousandths of a second)\n\nSELECT INTERVAL '11 10:09' DAY TO MINUTE FROM dual;\n-- +11 10:09:00 (11 days, 10 hours and 9 minutes)\n\nSELECT INTERVAL '100 10' DAY(3) TO HOUR FROM dual;\n-- +100 10:00:00 (100 days and 10 hours)\n\nSELECT INTERVAL '8' HOUR YEAR FROM dual;\n-- +00 08:00:00 (8 hours)\n\nSELECT INTERVAL '09:30' HOUR TO MINUTE FROM dual;\n-- +00 09:30:00 (9 hours and 30 minutes)\n</code></pre> Sources <ul> <li>Oracle Documentation - INTERVAL DAY TO SECOND</li> </ul>"},{"location":"SQL/functions/#trunc-date","title":"TRUNC (date)","text":"<p>The TRUNC (Single-Row) Function returns a date truncated to a specific unit of measure.</p> <p>Syntax <pre><code>TRUNC(date [, format])\n</code></pre></p> <ul> <li>date: the date to truncate.</li> <li>format: the unit of measure to apply for truncating.<ul> <li>if omitted, the function will truncate the date to the day value, so that any hours, minutes, or seconds will be truncated off</li> <li>Must be one of the following values: (complete list)</li> </ul> </li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - TRUNC (date)</li> </ul> Sources <ul> <li>Oracle Documentation - TRUNC (date)</li> </ul>"},{"location":"SQL/functions/#null-related-functions","title":"NULL-Related Functions","text":"<p>NULL-Related functions are used to handle NULL values.</p> <p>List of NULL-Related Functions covered</p> <ul> <li><code>NVL</code></li> <li><code>DECODE</code></li> <li><code>NVL2</code></li> <li><code>COALESCE</code></li> <li><code>NULLIF</code></li> </ul>"},{"location":"SQL/functions/#nvl","title":"NVL","text":"<p>The NVL (Single-Row) Function lets you substitute a value when a NULL value is encountered.</p> <p>Syntax <pre><code>NVL(string1, replace_with)\n</code></pre></p> <ul> <li>string1: the string to test for a NULL value.</li> <li>replace_with: the value returned if string1 is NULL.<ul> <li>dataype must be the same as string1</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT NVL(NULL, 'Hello') FROM dual;\n-- Hello\n\nSELECT NVL('Hello', 'Hello2') FROM dual;\n-- Hello\n</code></pre> Sources <ul> <li>Oracle Documentation - NVL</li> </ul>"},{"location":"SQL/functions/#decode","title":"DECODE","text":"<p>The DECODE (Single-Row) Function has the functionality of an IF-THEN-ELSE statement.</p> <p>Syntax <pre><code>DECODE(expression, search, result, [, search, result]... [, default])\n</code></pre></p> <ul> <li>expression: the value to compare.</li> <li>search: the value that is compared against expression.</li> <li>result: the value returned, if expression is equal to search.</li> <li>default: if no matches are found, the DECODE function will return default.</li> </ul> <p>Notes</p> <ul> <li>The function returns a value that is the same data type as the first result in the list.</li> <li>If the first result is NULL, then the return vlue is converted to VARCHAR2.</li> <li>If the first result has a data type of CHAR, then the return value is converted to VARCHAR2.</li> </ul> <p>Examples</p> <pre><code>SELECT supplier_name,\nDECODE(supplier_id, 10000, 'IBM',\n                    10001, 'Microsoft',\n                    10002, 'Hewlett Packard',\n                    'Gateway') result\nFROM suppliers;\n\n-- the above code would be equivalent to:\nIF supplier_id = 10000 THEN\n   result := 'IBM';\n\nELSIF supplier_id = 10001 THEN\n   result := 'Microsoft';\n\nELSIF supplier_id = 10002 THEN\n   result := 'Hewlett Packard';\n\nELSE\n   result := 'Gateway';\nEND IF;\n</code></pre> Sources <ul> <li>Oracle Documentation - DECODE</li> </ul>"},{"location":"SQL/functions/#case","title":"CASE","text":"<p>The CASE Statement has the functionality of an IF-THEN-ELSE statement.</p> <p>Syntax <pre><code>CASE [expression]\n    WHEN condition_1 THEN result_1\n    WHEN condition_2 THEN result_2\n    ...\n    WHEN condition_n THEN result_n\n    [ELSE result]\nEND\n</code></pre></p> <ul> <li>expression: the value that you are comparing to the list of conditions.</li> <li>condition_1, condition_2, \u2026 condition_n: the conditions that must all be the same datatype. Conditions are evaluated in the order listed.</li> <li>result_1, result_2, ... result_n: results that must all be the same datatype. This is the value returned once a condition is found to be true.</li> </ul> <p>Notes</p> <ul> <li>The CASE Statement returns any datatype such as a String, Numeric, Date, etc.</li> <li>All conditions must be the same datatype.</li> <li>All results must be the same datatype.</li> <li>If ELSE is omitted, the CASE Statement will return NULL if no condition is found to be true.</li> <li>You can have up to 255 comparisons in a CASE Statement (each WHEN ... THEN clause is considered 2 comparisons).</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - CASE</li> </ul> Sources <ul> <li>Oracle Documentation - CASE Statement</li> </ul>"},{"location":"SQL/functions/#nvl2","title":"NVL2","text":"<p>The NVL2 (Single-Row) Function lets you substitutes a value when a NULL value is encountered as well as when a non-NULL value is encountered.</p> <p>Syntax <pre><code>NVL2(string1, value_if_not_null, value_if_null)\n</code></pre></p> <ul> <li>string1: the string to test for a NULL value.</li> <li>value_if_not_null: the value returned if string1 is not NULL.</li> <li>value_if_null: the value returned if string1 is NULL.</li> </ul> <p>Examples</p> <p><pre><code>SELECT NVL2(NULL, 'Hello', 'Hello2') FROM dual;\n-- Hello2\n\nSELECT NVL2('Hello!', 'Hello', 'Hello2') FROM dual;\n-- Hello\n</code></pre> - Oracle Live SQL - NVL2</p> Sources <ul> <li>Oracle Documentation - NVL2</li> </ul>"},{"location":"SQL/functions/#coalesce","title":"COALESCE","text":"<p>The COALESCE (Single-Row) Function returns the first non-null expression in the list.\\ If all expressions evaluate to NULL, then the COALESCE function will return NULL.</p> <p>Syntax <pre><code>COALESCE(expression1, expression2, ... expression_n)\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: the expressions to test for non-NULL values.<ul> <li>the expressions must all be the same datatype</li> </ul> </li> </ul> <p>Examples</p> <pre><code>SELECT COALESCE( address1, address2, address3 ) result\nFROM suppliers;\n\n-- the above code would be equivalent to:\nIF address1 is not null THEN\n   result := address1;\nELSIF address2 is not null THEN\n   result := address2;\nELSIF address3 is not null THEN\n   result := address3;\nELSE\n   result := null;\nEND IF;\n</code></pre> Sources <ul> <li>Oracle Documentation - COALESCE</li> </ul>"},{"location":"SQL/functions/#nullif","title":"NULLIF","text":"<p>The NULLIF (Single-Row) Function compares expr1 and expr2. If expr1 and expr2 are equal, the NULLIF function returns NULL. Otherwise, it returns expr1.</p> <p>Syntax <pre><code>NULLIF(expr1, expr2)\n</code></pre></p> <ul> <li>expr1: first value to compare.<ul> <li>cannot be a literal NULL.</li> </ul> </li> <li>expr2: second value to compare.</li> </ul> <p>Examples</p> <ul> <li>Oracle Live SQL - NULLIF</li> </ul> Sources <ul> <li>Oracle Documentation - NULLIF</li> </ul>"},{"location":"SQL/functions/#coalesce-vs-nvl","title":"COALESCE vs NVL","text":"<ul> <li>NVL accepts only 2 arguments whereas COALESCE can take multiple arguments.</li> <li>NVL evaluates both the arguments and COALESCE stops at first occurrence of a non-Null value (only exception is a Sequence.NEXTVAL).</li> </ul> <p>Examples</p> <p><pre><code>SELECT SUM(val)\nFROM\n    (SELECT NVL(1, LENGTH(RAWTOHEX(SYS_GUID()))) AS val\n    FROM dual\n    CONNECT BY LEVEL &lt;= 1000000);\n-- this query runs approximately in 0.6 seconds\n\nSELECT SUM(val)\nFROM\n    (SELECT COALESCE(1, LENGTH(RAWTOHEX(SYS_GUID()))) AS val\n    FROM dual\n    CONNECT BY LEVEL &lt;= 1000000);\n-- this query runs approximately in 0.2 seconds\n</code></pre> - NVL does an implicit conversion to the datatype of the first parameter, while COALESCE expect all parameters to have the same datatype.</p> <pre><code>SELECT NVL('a', sysdate)\nFROM dual;\n-- returns 'a'\n\nSELECT COALESCE('a', sysdate)\nFROM dual;\n-- returns ORA-00932: inconsistent datatypes: expected CHAR got DATE\n\nSELECT NVL('test', 500)\nFROM dual;\n-- returns 'test'\n\nSELECT COALESCE('test', 500)\nFROM dual;\n-- returns ORA-00932: inconsistent datatypes: expected CHAR got NUMBER\n</code></pre> Sources <ul> <li>Oracle Documentation - COALESCE</li> <li>Oracle Documentation - NVL</li> </ul>"},{"location":"SQL/functions/#aggregate-functions","title":"Aggregate Functions","text":"<p>Aggregate (or Group) Functions return a single result row based on groups of rows, rather than on single rows.</p> <p>They are commonly used with the GROUP BY clause in a SELECT statement, where Oracle Database divides the rows of a queried table or view into groups. If you omit the GROUP BY clause, then Oracle applies Aggregate Functions in the select list to all the rows in the queried table or view.</p> <p>Many Aggregate Functions accept these clauses:</p> <ul> <li>DISTINCT and UNIQUE (which are synonymous) cause an aggregate function to consider only distinct values of the argument expression.</li> <li>ALL causes an aggregate function to consider all values, including all duplicates.</li> </ul> <p>If both are ommitted, default clause is ALL.</p> <p>List of Aggregate Functions covered</p> <ul> <li><code>COUNT</code></li> <li><code>AVG</code></li> <li><code>SUM</code></li> <li><code>MAX</code></li> <li><code>MIN</code></li> <li><code>LISTAGG</code></li> <li><code>STDDEV</code></li> <li><code>VARIANCE</code></li> </ul> <p>Notes</p> <ul> <li>Aggregate Functions can appear in select lists and in ORDER BY and HAVING clauses.</li> <li>You use Aggregate Functions in the HAVING clause to eliminate groups from the output based on the results of the Aggregate Functions.</li> <li>All Aggregate Functions except COUNT(*) ignore NULLs.</li> <li>COUNT never returns NULL, but returns either a number or zero.</li> </ul> <p>Examples</p> <ul> <li>DISTINCT average of: 1, 1, 1, and 3 \u2192 2 ([1+3]/2)</li> <li>ALL average of: 1, 1, 1, and 3 \u2192 1.5 ([1+1+1+3]/4)</li> </ul> Sources <ul> <li>Oracle Documentation - Aggregate Functions</li> </ul>"},{"location":"SQL/functions/#count","title":"COUNT","text":"<p>The COUNT (Aggregate) Function returns the count of an expression.</p> <p>Syntax <pre><code>SELECT COUNT([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n</code></pre></p> <p>Syntax with more than one column <pre><code>SELECT expression1, expression2, ... expression_n,\nCOUNT([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the COUNT function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression whose non-NULL values will be counted.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The COUNT function always returns a numeric value.</li> </ul> Sources <ul> <li>Oracle Documentation - COUNT</li> </ul>"},{"location":"SQL/functions/#avg","title":"AVG","text":"<p>The AVG (Aggregate) Function returns the average value of an expression.</p> <p>Syntax <pre><code>SELECT AVG([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n</code></pre></p> <p>Syntax with more than one column <pre><code>SELECT expression1, expression2, ... expression_n,\nAVG([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the AVG function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression that will be averaged.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The AVG function returns a numeric value.</li> <li>If aggregate_expression is a String, returns <code>ORA-01722: invalid number</code></li> <li>If aggregate_expression is a Date, returns <code>ORA-00932: inconsistent datatypes: expected NUMBER got DATE</code></li> </ul> Sources <ul> <li>Oracle Documentation - AVG</li> </ul>"},{"location":"SQL/functions/#max","title":"MAX","text":"<p>The MAX (Aggregate) Function returns the maximum value of an expression.</p> <p>Syntax <pre><code>SELECT MAX([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n</code></pre></p> <p>Syntax with more than one column <pre><code>SELECT expression1, expression2, ... expression_n,\nMAX([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MAX function must be included in the GROUP BY clause. </li> <li>aggregate_expression: the column or expression from which the maximum value will be returned.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The MAX function returns either a string/numeric/date value.</li> </ul> Sources <ul> <li>Oracle Documentation - MAX</li> </ul>"},{"location":"SQL/functions/#min","title":"MIN","text":"<p>The MIN (Aggregate) Function returns the minimum value of an expression.</p> <p>Syntax <pre><code>SELECT MIN([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n</code></pre></p> <p>Syntax with more than one column <pre><code>SELECT expression1, expression2, ... expression_n, \nMIN([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MAX function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression from which the minimum value will be returned.<ul> <li>NULL values are ignored</li> </ul> </li> </ul> <p>Notes</p> <ul> <li>The MIN function returns either a string/numeric/date value.</li> </ul> Sources <ul> <li>Oracle Documentation - MIN</li> </ul>"},{"location":"SQL/functions/#listagg","title":"LISTAGG","text":"<p>The LISTAGG (Aggregate) Function concatenates values of the measure_column for each GROUP based on the order_by_clause.</p> <p>Syntax <pre><code>LISTAGG(measure_column [, 'delimeter'])\n    WITHIN GROUP (order_by_clause)\n</code></pre></p> <ul> <li>measure_column: the column or expression whose values you wish to concatenate together in the result set.</li> <li>delimeter: the delimeter to use when separating the measure_column.</li> <li>order_by_clause: determines the order that the concatenated values are returned.</li> </ul> <p>Notes</p> <ul> <li>NULL values in the measure_column are ignored</li> <li>delimeter's default value is blank space</li> </ul> <p>Examples</p> <p></p> <pre><code>SELECT LISTAGG(product_name, ', ')\n    WITHIN GROUP (ORDER BY product_name) \"Product_Listing\"\nFROM products;\n-- Apples, Bananas, Oranges, Pears\n</code></pre> Sources <ul> <li>Oracle Documentation - LISTAGG</li> </ul>"},{"location":"SQL/functions/#sum","title":"SUM","text":"<p>The SUM (Aggregate) Function returns the summed value of an expression.</p> <p>Syntax <pre><code>SELECT SUM([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\n</code></pre></p> <p>Syntax with more than one column <pre><code>SELECT expression1, expression2, ... expression_n, \nSUM([DISTINCT | ALL] aggregate_expression)\nFROM tablename\n[WHERE condition];\nGROUP BY expression1, expression2, ... expression_n;\n</code></pre></p> <ul> <li>expression1, expression2, ... expression_n: expressions that are not encapsulated within the MIN function must be included in the GROUP BY clause.</li> <li>aggregate_expression: the column or expression that will be summed.</li> </ul> <p>Notes</p> <ul> <li>The SUM function returns a numeric value.</li> <li>NULL values in the aggregate_expression are ignored.</li> <li>If aggregate_expression is a String, returns <code>ORA-01722: invalid number</code></li> <li>If aggregate_expression is a Date, returns <code>ORA-00932: inconsistent datatypes: expected NUMBER got DATE</code></li> </ul> Sources <ul> <li>Oracle Documentation - SUM</li> </ul>"},{"location":"SQL/functions/#conversion-functions","title":"Conversion Functions","text":"<p>Conversion Functions convert a value from one form to another.</p> <p>List of Conversion Functions covered</p> <ul> <li><code>TO_NUMBER</code></li> <li><code>TO_CHAR</code></li> <li><code>TO_DATE</code></li> </ul>"},{"location":"SQL/functions/#to_number","title":"TO_NUMBER","text":"<p>The TO_NUMBER (Conversion) Function converts expr to a value of NUMBER data type.</p> <p>Syntax <pre><code>TO_NUMBER(string, [,format_mask])\n</code></pre></p> <p>Format Mask [...]</p> Sources <ul> <li>Oracle Documentation - TO_NUMBER</li> </ul>"},{"location":"SQL/functions/#to_date","title":"TO_DATE","text":"<p>The TO_DATE (Conversion) Function converts a string to a date.</p> <p>Syntax <pre><code>TO_DATE(string, [,format_mask])\n</code></pre></p> <ul> <li>string: the string that will be converted to a date.</li> <li>format_mask: the format that will be used to convert string to a date.<ul> <li>must be one or a combination of the following values.</li> </ul> </li> </ul> Sources <ul> <li>Oracle Documentation - TO_DATE</li> </ul>"},{"location":"SQL/hints/","title":"Hints","text":"<p>Hints are comments in a SQL statement that pass instructions to the Oracle Database optimizer. Hints can only be used in SELECT, UPDATE, INSERT, MERGE or DELETE Statements.</p> <p>Syntax <pre><code>DML_keyword /*+ hint_1 [hint_n] */\nDML_statement\n</code></pre></p> <ul> <li>DML_keyword: must be one of the following: SELECT, UPDATE, INSERT, MERGE, DELETE.</li> <li>hint_1, [hint_n]: name of the hint being used. Multiple Hints can be used in one statement.</li> </ul> Sources <ul> <li>Oracle Documentation - Hints</li> </ul>"},{"location":"SQL/hints/#parallel-hint","title":"PARALLEL Hint","text":"<p>The PARALLEL hint instructs the optimizer to use the specified number of concurrent servers for a parallel operation.</p> <p>Syntax <pre><code>DML_keyword /*+ PARALLEL[(degree | DEFAULT | MANUAL)]\nDML_statement\n</code></pre></p> <ul> <li>DML_keyword: must be one of the following: SELECT, UPDATE, INSERT, MERGE, DELETE</li> <li>degree: degree of parallelism used for the statement.</li> <li><code>DEFAULT</code>: the optimizer calculates a degree of parallelism equal to the number of CPUs availables times the value of the <code>PARALLEL_THREADS_PER_CPU</code> parameter.</li> <li><code>MANUAL</code>: the optimize uses the degree of parallelism specified in the Object.</li> </ul> <p>Notes</p> <ul> <li>Query to get the number of CPUs availables and the <code>PARALLEL_THREADS_PER_CPU</code> parameter's value: <pre><code>SELECT name, value\nFROM v$parameter\nWHERE UPPER(name) IN ('CPU_COUNT','PARALLEL_THREADS_PER_CPU')\n</code></pre></li> </ul> Sources <ul> <li>Oracle Documentation - PARALLEL Hint</li> </ul>"},{"location":"SQL/hints/#append-hint","title":"APPEND Hint","text":"<p>The APPEND hint instructs the optimizer to use direct-path INSERT with the subquery syntax of the INSERT statement.</p> <p>Syntax <pre><code>INSERT /*+ APPEND */\nINTO table_name\nsubquery;\n</code></pre></p> <ul> <li>table_name: table on which you're inserting data.</li> <li>subquery: SELECT Statement from which you're getting data.</li> </ul> Sources <ul> <li>Oracle Documentation - APPEND Hint</li> </ul>"},{"location":"SQL/joins/","title":"Joins","text":""},{"location":"SQL/joins/#cartesian-join","title":"Cartesian Join","text":"<p>also known as Cartesian Product or Cross Join</p> <p>Replicates each row from the first table with every row from the second table. Creates a join between tables by displaying every possible record combination. Can be created by two methods:</p> <ul> <li>Not including a joining condition in a WHERE clause</li> <li>Using the JOIN method with the CROSS JOIN keywords</li> </ul> <p></p> <p>Examples</p> <pre><code>SELECT *\nFROM oe.orders, oe.customers;\n</code></pre> Sources <ul> <li>Oracle Documentation - Cartesian Product</li> </ul>"},{"location":"SQL/joins/#inner-join","title":"Inner Join","text":"<p>also known as Equijoin, Equality Join or Simple Join</p> <p>Creates a join by using a commonly named and defined column. Can be created by two methods:</p> <ul> <li>Using the WHERE clause</li> <li>Using the JOIN method with the <code>NATURAL JOIN</code>, <code>JOIN \u2026 ON</code>, or <code>JOIN \u2026 USING</code> keywords</li> </ul> <p>Syntax <pre><code>SELECT column_list\nFROM table_1 t1 JOIN table_2 t2 USING (column_1 [, column_2, ... column_n]);\n</code></pre></p> <p>Notes</p> <ul> <li>The USING clause specifies which columns to test for equality when two tables are joined.</li> </ul> <p>Examples</p> <pre><code>SELECT *\nFROM oe.orders o JOIN oe.order_items oi\nON o.order_id = oi.order_id;\n</code></pre> Sources <ul> <li>Oracle Documentation - Equijoins</li> </ul>"},{"location":"SQL/joins/#non-equality-join","title":"Non-equality Join","text":"<p>Joins tables when there are no equivalent rows in the tables to be joined; For example, to match values in one column of a table with a range of values in another table. Can be created by two methods:</p> <ul> <li>Using the WHERE clause</li> <li>Using the JOIN method with the <code>JOIN \u2026 ON</code> keywords</li> </ul>"},{"location":"SQL/joins/#self-join","title":"Self-Join","text":"<p>Joins a table to itself. Can be created by two methods:</p> <ul> <li>Using the WHERE clause</li> <li>Using the JOIN method with the <code>JOIN \u2026 ON</code> keywords</li> </ul> Sources <ul> <li>Oracle Documentation - Self Joins</li> </ul>"},{"location":"SQL/joins/#outer-join","title":"Outer Join","text":"<p>Includes records of a table in output when there\u2019s no matching record in the other table. Can be created by two methods:</p> <ul> <li>Using the WHERE clause with a (\u00fe) operator</li> <li>Using the JOIN method with the OUTER JOIN keywords and the assigned type of LEFT, RIGHT, or FULL</li> </ul> Sources <ul> <li>Oracle Documentation - Outer Joins</li> </ul>"},{"location":"SQL/operators/","title":"Comparison Operators","text":""},{"location":"SQL/operators/#set-comparison-operators","title":"SET COMPARISON OPERATORS","text":"<ul> <li>&lt; ANY ( ): Less than maximum</li> <li>&gt; ANY ( ): Greater than minimum<ul> <li>Example: <code>x &gt; ANY (1, 2, 3)</code> \u2192 <code>x &gt; 1 OR x &gt; 2 OR x &gt; 3 \u2192 x &gt; 1</code></li> </ul> </li> <li>= ANY ( ): Equivalent to IN<ul> <li>Example: <code>x = ANY (1, 2, 3)</code> \u2192 <code>x IN (1, 2, 3) \u2192 x = 1 OR x = 2 OR x = 3</code></li> </ul> </li> <li>&gt; ALL ( ): Greater than maximum<ul> <li>Example: <code>x &gt; ALL (1,2,3)</code> \u2192 <code>x &gt; 1 AND x &gt; 2 AND x &gt; 3 \u2192 x &gt; 3</code></li> </ul> </li> <li>&lt; ALL ( ): Less than mininum</li> </ul>"},{"location":"SQL/operators/#any-operator","title":"ANY Operator","text":"<p>The ANY Operator is used to compare a value to a list of values or result set returned by a subquery.</p> <p>Syntax <pre><code>operator comparison_op ANY ({expr_1, expr_n | subquery})\n</code></pre></p> <ul> <li>comparison_op: the comparison operator (=, !=, &gt;, &gt;=, etc.)</li> <li>expr_1, expr_n: values you're comparing to operator.</li> <li>subquery: subquery returning one or more rows. </li> </ul> <p>Notes</p> <ul> <li>If subquery returns no rows, the main query will return no rows as well.</li> </ul> <p>Examples</p> <pre><code>SELECT *\nFROM tablename\nWHERE c &gt; ANY (v1, v2, v3);\n\n-- would be equivalent to:\n\nSELECT *\nFROM tablename\nWHERE c &gt; v1\n    OR c &gt; v2\n    OR c &gt; v2;\n</code></pre>"},{"location":"SQL/operators/#intersect-operator","title":"INTERSECT Operator","text":"<p>The INTERSECT operator compares the result of two queries and returns the distinct rows that are output by both queries.</p> <p>INTERSECT does not ignore NULL values.</p> <p></p> <p>Syntax <pre><code>SELECT column_list_1\nFROM tablename_1\nINTERSECT\nSELECT column_list_2\nFROM tablename_2;\n</code></pre></p> <p>Restrictions</p> <ul> <li>The number and order of columns must be the same in the two queries.</li> <li>The data type of the corresponding columns must be in the same data type group such as numeric or character.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/operators/#minus-operator","title":"MINUS Operator","text":"<p>The MINUS operator is used to return all rows in the first SELECT statement that are not returned by the second SELECT statement.</p> <p></p> <p>Syntax <pre><code>SELECT column_list_1\nFROM tablename_1\nMINUS\nSELECT column_list_2\nFROM tablename_2;\n</code></pre></p> <p>Restrictions</p> <ul> <li>The number and order of columns must be the same in the two queries.</li> <li>The data type of the corresponding columns must be in the same data type group such as numeric or character.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/operators/#union-union-all-operators","title":"UNION &amp; UNION ALL Operators","text":"<p>The UNION &amp; UNION ALL operators are set operators that combines result sets of two or more SELECT statements into a single result set.</p> <p></p> <p>Syntax <pre><code>SELECT column_list_1\nFROM tablename_1\nUNION [ALL]\nSELECT column_list_2\nFROM tablename_2;\n</code></pre></p> <p>Notes</p> <ul> <li>UNION ALL returns all records including duplicates, while UNION returns only unique records.</li> </ul> Sources <ul> <li>Oracle Documentation - The Set Operators</li> </ul>"},{"location":"SQL/subqueries/","title":"Subqueries","text":""},{"location":"SQL/subqueries/#correlated-subqueries","title":"Correlated Subqueries","text":"<p>A Correlated Subquery is a subquery whose some clauses refer to the column expressions in the outer query.</p> <p>Notes</p> <ul> <li>The Correlated Subquery executes after the outer query returns the row.</li> <li>Each row returned by the outer query is evaluated for the results returned by the Correlated Subquery.</li> </ul> <p>Examples</p> <pre><code>SELECT product_id, product_name, list_price\nFROM products p\nWHERE list_price &gt;\n    (SELECT AVG(list_price)\n    FROM products\n    WHERE category_id = p.category_id);\n</code></pre>"},{"location":"SQL/subqueries/#single-row-subqueries","title":"Single-Row Subqueries","text":"<p>A Single-Row Subquery returns zero or one rows to the outer SQL Statement. A Single-Row Subquery can be placed in a WHERE clause, HAVING clause, or a FROM clause of a SELECT Statement.</p> <p>Examples</p> <ul> <li>Oracle Live SQL - Single-Row Subqueries</li> </ul>"},{"location":"SQL/subqueries/#multiple-row-subqueries","title":"Multiple-Row Subqueries","text":"<p>A Multiple-Row Subquery returns more than one row to the outer SQL Statement. Despite it's called \"Multiple-Row Subquery\", it can still return 0 or 1 row(s). You can use operators such as IN, ANY, or ALL.</p> <p>Examples</p> <ul> <li>Oracle Live SQL - Multiple-Row Subqueries</li> </ul>"},{"location":"SQL/transactions/","title":"Transactions","text":"<p>A Transaction is a logical, atomic unit of work that contains one or more SQL statements</p> <p>A Transaction groups SQL statements so that they are either all committed, which means they are applied to the database, or all rolled back, which means they are undone from the database. Oracle Database assigns every transaction a unique identifier called a transaction ID.</p> <p>ACID All Oracle transactions obey the basic properties of a database transaction, known as ACID properties. ACID is an acronym for the following:</p> <ul> <li>ATOMICITY: All tasks of a Transaction are performed or none of them are. There are no partial Transactions.<ul> <li>For example, if a Transaction starts updating 100 rows, but the system fails after 20 updates, then the Database rolls back the changes to these 20 rows.</li> </ul> </li> <li>CONSISTENCY: The Transaction takes the Database from one consistent state to another consistent state.<ul> <li>For example, in a banking Transaction that debits a savings account and credits a checking account, a failure must not cause the Database to credit only one account, which would lead to inconsistent data.</li> </ul> </li> <li>ISOLATION: The effect of a Transaction is not visible to other Transactions until the Transaction is committed.<ul> <li>For example, one user updating the hr.employees table does not see the uncommitted changes to employees made concurrently by another user. Thus, it appears to users as if Transactions are executing serially.</li> </ul> </li> <li>DURABILITY: Changes made by committed Transactions are permanent. After a Transaction completes, the Database ensures through its recovery mechanisms that changes from the Transaction are not lost.</li> </ul> <p>Structure of a Transaction A Database Transaction consists of one or more statements. Specifically, a Transaction consists of one of the following:</p> <ul> <li>One or more DML Statements that together constitute an atomic change to the Database;</li> <li>One DDL Statement.</li> </ul> <p>Beginning of a Transaction A Transaction begins when the first executable SQL Statement is encountered.</p> <p>A Transaction ID is unique to a Transaction and represents the undo segment number, slot, and sequence number.</p> <p>End of a Transaction A Transaction ends when any of the following actions occurs:</p> <ul> <li>A user issues a COMMIT or ROLLBACK statement without a SAVEPOINT clause.</li> <li>A user runs a DDL command such as CREATE, DROP, RENAME, or ALTER.</li> <li>A user exits normally from most Oracle Database utilities and tools, causing the current transaction to be implicitly committed. The commit behavior when a user disconnects is application-dependent and configurable.</li> <li>A client process terminates abnormally, causing the transaction to be implicitly rolled back using metadata stored in the transaction table and the undo segment.</li> </ul> Sources <ul> <li>Oracle Documentation - Transactions</li> </ul>"},{"location":"SQL/transactions/#rollback","title":"ROLLBACK","text":"<p>A rollback of an uncommitted Transaction undoes any changes to data that have been performed by SQL Statements within the transaction. After a Transaction has been rolled back, the effects of the work done in the Transaction no longer exist.</p> <p>In rolling back an entire Transaction, without referencing any savepoints, Oracle Database performs the following actions:</p> <ul> <li>Undoes all changes made by all the SQL Statements in the Transaction</li> <li>Releases all the locks of data held by the Transaction</li> <li>Erases all savepoints in the Transaction</li> <li>Ends the transaction</li> </ul> <p>Syntax <pre><code>ROLLBACK;\n</code></pre></p> Sources <ul> <li>Oracle Documentation - ROLLBACK</li> </ul>"},{"location":"SQL/transactions/#commit","title":"COMMIT","text":"<p>A commit ends the current Transaction and makes permanent all changes performed in the Transaction.</p> <p>When a Transaction commits, the following actions occur:</p> <ul> <li>Oracle Database releases locks held on rows and tables</li> <li>Oracle Database deletes savepoints.</li> <li>Oracle Database marks the transaction complete.</li> </ul> <p>After a Transaction commits, users can view the changes.</p> <p>Syntax <pre><code>COMMIT;\n</code></pre></p> Sources <ul> <li>Oracle Documentation - COMMIT</li> </ul>"},{"location":"SQL/transactions/#flashback-table","title":"FLASHBACK TABLE","text":"<p>This Statement is used to restore an earlier state of a Table in the event of human or application error. The time in the past to which the Table can be flashed back is dependent on the amount of undo data in the system.</p> <p>Syntax <pre><code>FLASHBACK TABLE\n    [schema.]table_name\n    [, [schema.]table_name]\nTO\n    BEFORE DROP [RENAME TO table_name] |\n    {RESTORE POINT rp_name | SCN number_value | TIMESTAMP date_value ENABLE | DISABLE TRIGGERS}\n;\n</code></pre></p> <ul> <li>schema: the schema containing the Table to be restored.</li> <li>table_name: the table(s) that needs to be restored.</li> <li><code>TO BEFORE DROP</code>: retrieve from the Recycle Bin a Table that has been dropped. Tables dropped with the PURGE clause cannot be recovered.</li> <li><code>RENAME TO table_name</code>: specify this clause if you want to rename the Table after it is recovered.</li> <li><code>TO RESTORE POINT rp_name</code>: specify a restore point to which you want to flash back the Table.</li> <li><code>TO SCN number_value</code>: specify the System Change Number (SCN) corrensponding the point in time to which you want to return the Table.</li> <li><code>TO_TIMESTAMP date_value</code>: specify a timestamp value corresponding to the poin in time to which you want to return the Table.</li> <li><code>ENABLE | DISABLE TRIGGERS</code>: by default, Oracle disables all the Triggers related to the Table during the Flashback operation (they get re-enabled after the operation is done). Specify ENABLE if you want to override this option and keep them active.</li> </ul> <p>Notes</p> <ul> <li>You cannot roll back a FLASHBACK TABLE Statement. However, you can issue another FLASHBACK TABLE to undo a previous flashback.</li> <li>During a Flashback operation, Oracle Database locks the Table until the Flashback is done. The operation is done in a single Transaction.</li> <li>If you're issuing a FLASHBACK TABLE on multiple Tables, all of them must succeed to complete the operation, otherwise the Statement will be reverted.</li> <li><code>FLASHBACK TABLE TO BEFORE DROP</code> does not recover referential constraints.</li> <li>If the Table is recovered from the Recycle Bin, then the Database also retrieves:<ul> <li>Indexes (except for Bitmap Join and Domain Indexes)</li> <li>Triggers</li> <li>Constraints</li> </ul> </li> <li>You cannot perform a FLASHBACK TABLE on a Materialized View.</li> <li>FLASHBACK TABLE might require to enable a Table's row movement:<ul> <li>To check if it is enabled: <code>SELECT table_name,row_movement FROM all_tables WHERE table_name = your_table_name;</code></li> <li>To enable it: <code>ALTER TABLE [schema.]table_name ENABLE ROW MOVEMENT;</code></li> </ul> </li> </ul> <p>Privilege Restrictions</p> <ul> <li>In your Schema: <code>GRANT FLASHBACK ON [schema.]table_name TO user_name;</code></li> <li>In another's user Schema: <code>GRANT FLASHBACK ANY TABLE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - FLASHBACK TABLE</li> </ul>"},{"location":"SQL/transactions/#lock-table","title":"LOCK TABLE","text":"<p>Use this Statement to lock:</p> <ul> <li>one or more Tables</li> <li>Table Partitions</li> <li>Table Subpartitions</li> </ul> <p>A Locked Table remains locked until you either commit your Transaction or roll it back. A Locked Table does not prevent other users from querying the Table.</p> <p>Syntax <pre><code>LOCK TABLE [schema.]object_name\n    [\n        PARTITION {(partition_name) | FOR (partition_key_value_1 [, partition_key_value_n]) | \n        SUBPARTITION (subpartition_name) | FOR (subpartition_key_vale_1 [, subpartition_key_value_n])\n    ]\nIN lockmode MODE\n[NO WAIT |  WAIT number_value]\n</code></pre></p> <ul> <li>object_name; specify the Table or View you want to lock.<ul> <li>specifying a View causes the Database to lock the base Tables of the View.</li> </ul> </li> <li>IN lockmode MODE: can be one of the following:<ul> <li><code>ROW SHARE</code>: permits concurrent access to the Locked Table but prohibits users from locking the entire Table for exclusive access.</li> <li><code>ROW EXCLUSIVE</code>: same as ROW SHARE, but prohibits locking in SHARE mode.</li> <li><code>SHARE UPDATE</code>: synonym of ROW SHARE.</li> <li><code>SHARE</code>: permits concurrent queries but prohibits updates to the Locked Table.</li> <li><code>SHARE ROW EXCLUSIVE</code>: allows other users to look at the Table but prohibits locking it in SHARE mode or from updating rows.</li> <li><code>EXCLUSIVE</code>: permits queries on the Locked Table but prohibits any other activity on it.</li> </ul> </li> <li><code>NOWAIT</code>: immediately return an error message if the Table is already locked.</li> <li><code>WAIT number_value</code>: wait for number_value (in seconds) to acquire a DML Lock.</li> </ul> <p>Notes</p> <ul> <li>If you specify neither NOWAIT nor WAIT, the Database waits indefinitely until the Table is available.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT LOCK ANY TABLE TO user_name;</code></li> </ul> Sources <ul> <li>Oracle Documentation - LOCK TABLE</li> </ul>"},{"location":"SQL/users/","title":"Managing Users","text":""},{"location":"SQL/users/#grant","title":"GRANT","text":"<p>Use this Statement to grant:</p> <ul> <li>System Privileges to Users and Roles</li> <li>Roles to Users, Roles and Program Unites</li> <li>Object Privileges for a particular Object to Users and Roles</li> </ul> <p>Syntax - System Privileges <pre><code>GRANT\n    role_name |\n    ALL PRIVILEGES |\n    system_privilege_name\nTO\n    {user_name | grantee_role_name | PUBLIC} |\n    user_name IDENTIFIED BY password\n[WITH {ADMIN | DELEGATE} OPTION]\n;\n</code></pre></p> <ul> <li>role_name: specify the role you want to grant.</li> <li><code>ALL PRIVILEGES</code>: if you want to grant all of the System Privileges<ul> <li>the System Privileges <code>SELECT ANY DICTIONARY</code>,<code>ALTER DATABASE LINK</code>,<code>ALTER PUBLIC DATABASE LINK</code> are not included.</li> </ul> </li> <li>system_privilege_name: specify the System Privilege you want to grant.</li> <li>user_name: specify the user that will be granted the System Privileges.</li> <li>grantee_role_name: specify the role that will be granted the System Privileges.</li> <li><code>PUBLIC</code>: specify PUBLIC to grant the privileges to all users.</li> <li><code>user_name IDENTIFIED BY password</code>: if user_name exists, resets their password, otherwise creates the user with that password.</li> <li><code>WITH ADMIN OPTION</code>: enables the grantee to:<ul> <li>grant the privilege or role to another user or role</li> <li>revoke the privilege or role from another user or role</li> <li>alter the privilege or role to change the authorization needed to access it</li> <li>drop the privilege or role</li> <li>grant the privilege or role to a program unit in the grantee's schema</li> <li>revoke the privilege or role from a program unit in the grantee's schema</li> </ul> </li> <li><code>WITH DELEGATE OPTION</code>: enables the grantee to:<ul> <li>grant the privilege or role to a program unit in the grantee's schema</li> <li>revoke the privilege or role from a program unit in the grantee's schema</li> </ul> </li> </ul> <p>Syntax - Object Privileges <pre><code>GRANT\n    object_privilege_1 [, object_privilege_n] |\n    ALL [PRIVILEGES]\n    [(column_1 [, column_n])]\nON\n    [schema.]object_name |\n    USER user_1 [, user_n]\nTO\n    {user_name | grantee_role_name | PUBLIC}\n[WITH HIERARCHY OPTION]\n[WITH GRANT OPTION]\n;\n</code></pre></p> <ul> <li>object_privilege_1, object_privilege_n: specify the Object Privilege(s) you want to grant.</li> <li><code>ALL [PRIVILEGES]</code>: specify ALL to grant all the privileges for object_name.</li> <li>[(column_1 [, column_n])]: specify the Table or View column on which privileges are to be granted. Can only be specified for INSERT, REFERENCES or UPDATE Object Privileges.</li> <li>object_name: specify the schema object on which the privileges are to be granted.<ul> <li>Must be one of the following:<ul> <li>Table</li> <li>View</li> <li>Materialized View</li> <li>Sequence</li> <li>Procedure</li> <li>Function</li> <li>Package</li> <li>User-defined Type</li> <li>Synonym</li> <li>Directory</li> </ul> </li> </ul> </li> <li><code>ON USER user_1 [, user_n]</code>: specify the database user you want to grant privileges to.<ul> <li>You cannot specify PUBLIC as user.</li> </ul> </li> <li><code>WITH HIERARCHY OPTION</code>: grants the specified Object Privileges on all subobjects of object_name, such as subviews created under a View.</li> <li><code>WITH GRANT OPTION</code>: enables the grantee to grant the Object Privileges to other users and roles.</li> </ul> <p>Notes</p> <ul> <li>A user, role or PUBLIC cannot appear more that once in the grantee clause.</li> <li>An Object Privilege cannot appear more than once in the list of privileges to be granted. </li> <li>To remove the <code>WITH ADMIN OPTION</code> or <code>WITH DELEGATE OPTION</code> from an user or role, you must revoke the privilege or role and the grant again.</li> <li>You cannot grant a role to itself.</li> <li>You cannot grant privileges directly to a single Partition of a Partitioned Table.</li> <li>For Object Privileges, <code>WITH ADMIN OPTION</code> cannot be granted to roles.</li> </ul> <p>Privilege Restrictions</p> <ul> <li><code>GRANT ANY PRIVILEGE TO user_name;</code></li> <li><code>WITH ADMIN OPTION</code> Clause</li> </ul> <p>Data Dictionary</p> <ul> <li><code>*_COL_PRIVS</code></li> </ul> Sources <ul> <li>Oracle Documentation - List of System Privileges</li> <li>Oracle Documentation - List of Object Privileges</li> <li>Oracle Documentation - GRANT</li> </ul>"},{"location":"SQL/users/#with-grant-option-vs-with-admin-option","title":"WITH GRANT OPTION vs. WITH ADMIN OPTION","text":"<p>WITH GRANT OPTION Only for OBJECT PRIVILEGES</p> <ul> <li>The owner of an object can grant it to another user by specifying the WITH GRANT OPTION clause in the GRANT statement.</li> <li>The new grantee can then grant the same level of access to other users or roles.</li> </ul> <p>Notes</p> <ul> <li>You cannot grant WITH GRANT OPTION to a role.</li> <li>If you revoke access to a user who had been granted access to an object WITH GRANT OPTION and that user had granted access to another user, both sets of grants will be revoked (cascade effect).</li> </ul> <p>WITH ADMIN OPTION Only for SYSTEM PRIVILEGES Specify WITH ADMIN OPTION to enable the grantee to:</p> <ul> <li>Grant the role to another user or role, unless the role is a GLOBAL role</li> <li>Revoke the role from another user or role</li> <li>Alter the role to change the authorization needed to access it</li> <li>Drop the role</li> </ul> <p>To revoke the ADMIN OPTION on a Sytem Privilege or role from a user, you must revoke the privilege or role from the user altogether and then grant the privilege or role to the user without the ADMIN OPTION.</p>"},{"location":"SQL/users/#grant-select-vs-grant-read","title":"GRANT SELECT vs GRANT READ","text":"<ul> <li><code>GRANT SELECT</code> allows users to lock Tables through the <code>SELECT .. FOR UPDATE</code> statement.</li> <li><code>GRANT READ</code> only allows SELECT statement, preventing the table's lock.</li> </ul> <pre><code>GRANT READ ON &lt;schema.&gt;&lt;object&gt; TO &lt;user&gt;;\n</code></pre>"}]}